<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>יישומון ריצוף צורות</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .grid-cell {
            width: 16px;
            height: 16px;
            border: 1px solid #e5e7eb;
            cursor: pointer;
            transition: all 0.1s;
        }
        .grid-cell:hover {
            border-color: #374151;
        }
        
        @keyframes pulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1.05);
            }
            50% {
                opacity: 0.8;
                transform: scale(1.02);
            }
        }
        
        @keyframes shake {
            0%, 100% {
                transform: translateX(0) scale(0.95);
            }
            25% {
                transform: translateX(-1px) scale(0.95);
            }
            75% {
                transform: translateX(1px) scale(0.95);
            }
        }
        
        @keyframes smoothMove {
            0% {
                transform: scale(1.05);
                opacity: 0.9;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
        .color-btn {
            width: 30px;
            height: 30px;
            border: 2px solid #374151;
            cursor: pointer;
            transition: all 0.2s;
        }
        .color-btn:hover {
            transform: scale(1.1);
        }
        .color-btn.selected {
            border-width: 3px;
            border-color: #000;
        }
        .tile-cell {
            width: 16px;
            height: 16px;
            border: 1px solid #d1d5db;
            cursor: pointer;
            transition: all 0.1s;
        }
        .tile-cell:hover {
            border-color: #374151;
        }
        .control-btn {
            background: #3b82f6;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        .control-btn:hover {
            background: #2563eb;
            transform: translateY(-1px);
        }
        .control-btn:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
        }
        
        /* מניעת גלילה/בחירה בזמן גרירה על הגריד */
        #targetGrid, #targetGrid .grid-cell {
            touch-action: none;
            -ms-touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }
        
        /* סטיילים רספונסיביים למובייל */
        @media (max-width: 768px) {
            .max-w-7xl {
                max-width: 100%;
                padding: 0 5px;
            }
            
            .bg-white {
                margin: 0 2px 10px 2px;
                padding: 10px 8px;
            }
            
            .flex {
                flex-wrap: wrap;
                gap: 4px;
                justify-content: center;
            }
            
            .control-btn {
                padding: 4px 8px;
                font-size: 10px;
                min-width: auto;
                white-space: nowrap;
            }
            
            .color-btn {
                width: 20px;
                height: 20px;
            }
            
            input[type="number"] {
                width: 40px;
                padding: 2px;
                font-size: 10px;
            }
            
            .text-3xl {
                font-size: 1.2rem;
                margin-bottom: 10px;
            }
            
            .grid-cell {
                width: 4px;
                height: 4px;
                border-width: 0.5px;
            }
            
            .tile-cell {
                width: 8px;
                height: 8px;
                border-width: 0.5px;
            }
            
            #targetGrid {
                max-height: 200px;
                overflow: auto;
                width: 100%;
                max-width: calc(100vw - 20px);
            }
            
            .flex-1 {
                width: 100%;
                margin-top: 10px;
            }
            
            .gap-6 {
                gap: 0;
                flex-direction: column;
            }
            
            /* התאמה מיוחדת לגריד במובייל */
            #targetGrid .grid-cell {
                min-width: 4px;
                min-height: 4px;
            }
            
            /* התאמת כפתורים למובייל */
            .flex.items-center.gap-3 {
                gap: 2px;
                flex-wrap: wrap;
                justify-content: center;
            }
            
            .flex.items-center.gap-2 {
                gap: 1px;
                flex-wrap: wrap;
                justify-content: center;
            }
            
            .flex.gap-2 {
                gap: 2px;
                flex-wrap: wrap;
                justify-content: center;
            }
        }
        
        @media (max-width: 480px) {
            .max-w-7xl {
                padding: 0 2px;
            }
            
            .grid-cell {
                width: 3px;
                height: 3px;
                border-width: 0.5px;
            }
            
            .tile-cell {
                width: 6px;
                height: 6px;
                border-width: 0.5px;
            }
            
            .control-btn {
                padding: 3px 6px;
                font-size: 9px;
            }
            
            .color-btn {
                width: 18px;
                height: 18px;
            }
            
            #targetGrid {
                max-height: 150px;
                max-width: calc(100vw - 10px);
            }
            
            input[type="number"] {
                width: 35px;
                padding: 1px;
                font-size: 9px;
            }
        }
    </style>
</head>
<body class="bg-gray-50 p-6 font-sans">
    <div class="max-w-7xl mx-auto">
        <h1 class="text-3xl font-bold text-center mb-8 text-gray-800">יישומון ריצוף צורות מאת ים רון</h1>
        
        <!-- כלי בקרה עליונים -->
        <div class="bg-white p-4 rounded-lg shadow-lg mb-6">
            <div class="flex flex-wrap items-center justify-center gap-6">
                <!-- פלטת צבעים -->
                <div class="flex items-center gap-3">
                    <span class="text-sm font-medium text-gray-700">צבע:</span>
                    <div class="flex gap-2">
                        <div class="color-btn selected" style="background-color: #ef4444" data-color="#ef4444"></div>
                        <div class="color-btn" style="background-color: #3b82f6" data-color="#3b82f6"></div>
                        <div class="color-btn" style="background-color: #10b981" data-color="#10b981"></div>
                        <div class="color-btn" style="background-color: #f59e0b" data-color="#f59e0b"></div>
                        <div class="color-btn" style="background-color: #8b5cf6" data-color="#8b5cf6"></div>
                        <div class="color-btn" style="background-color: #ec4899" data-color="#ec4899"></div>
                        <div class="color-btn" style="background-color: #ffffff; border-color: #374151" data-color="#ffffff"></div>
                    </div>
                </div>
                
                <!-- יצירת שטח אוטומטי -->
                <div class="flex items-center gap-2">
                    <span class="text-sm font-medium text-gray-700">יצירת שטח:</span>
                    <input type="number" id="shapeWidth" value="10" min="1" max="30" class="w-16 px-2 py-1 border border-gray-300 rounded text-center">
                    <span class="text-xs text-gray-500">×</span>
                    <input type="number" id="shapeHeight" value="10" min="1" max="30" class="w-16 px-2 py-1 border border-gray-300 rounded text-center">
                    <button class="control-btn bg-purple-600 hover:bg-purple-700" onclick="createAutoShape()">צור שטח ריצוף</button>
                    <button class="control-btn bg-orange-600 hover:bg-orange-700" onclick="finishShapeCreation()">סיים יצירת שטח</button>
                </div>
                
                <!-- כפתורי בקרה -->
                <div class="flex gap-2">
                    <button class="control-btn" onclick="clearTarget()">נקה שטח</button>
                    <button class="control-btn" onclick="clearTile()">נקה אריח</button>
                    <button class="control-btn" onclick="rotateTile()">סובב 90°</button>
                    <button class="control-btn" onclick="flipTile()">הפוך</button>
                </div>
                
                <!-- כפתורי ריצוף -->
                <div class="flex gap-2">
                    <button class="control-btn bg-green-600 hover:bg-green-700" onclick="startTiling()">התחל ריצוף</button>
                    <button class="control-btn bg-red-600 hover:bg-red-700" onclick="stopTiling()">בטל ריצוף</button>
                    <button class="control-btn bg-yellow-600 hover:bg-yellow-700" onclick="toggleTileMoveMode()">🔄 הזזת אריחים</button>
                    <button class="control-btn bg-red-500 hover:bg-red-600" onclick="deleteSelectedTile()" id="deleteTileBtn" style="display: none;">🗑️ מחק אריח</button>
                    <button class="control-btn bg-blue-500 hover:bg-blue-600" onclick="rotateSelectedTile()" id="rotateTileBtn" style="display: none;">🔄 סובב אריח</button>
                    <button class="control-btn bg-green-500 hover:bg-green-600" onclick="flipSelectedTile()" id="flipTileBtn" style="display: none;">🔃 הפוך אריח</button>
                    <button class="control-btn" onclick="clearTiling()">נקה ריצוף</button>
                </div>
                
                <!-- כפתורי ביטול וחזרה -->
                <div class="flex gap-2">
                    <button class="control-btn bg-gray-600 hover:bg-gray-700" onclick="undo()" id="undoBtn">↶ ביטול</button>
                    <button class="control-btn bg-gray-600 hover:bg-gray-700" onclick="redo()" id="redoBtn">↷ חזרה</button>
                    <button class="control-btn bg-indigo-600 hover:bg-indigo-700" onclick="showInstructions()">📖 הוראות שימוש</button>
                </div>
            </div>
            
            <!-- סטטוס -->
            <div id="tilingStatus" class="mt-3 p-2 rounded text-center text-sm font-medium"></div>
        </div>
        
        <div class="flex gap-6">
            <!-- עיצוב האריח -->
            <div class="bg-white p-4 rounded-lg shadow-lg">
                <h3 class="text-lg font-bold mb-3 text-gray-700 text-center">עיצוב האריח</h3>
                
                <!-- גריד עיצוב האריח -->
                <div class="border-2 border-gray-300 p-2 bg-white inline-block mb-3">
                    <div id="tileGrid" class="grid grid-cols-10 gap-0"></div>
                </div>
                
                <!-- תצוגת כל תצורות האריח -->
                <div class="text-center">
                    <p class="text-sm text-gray-600 mb-2">כל תצורות האריח:</p>
                    <div id="allTileVariations" class="flex flex-wrap gap-2 justify-center max-w-xs"></div>
                </div>
            </div>
            
            <!-- שטח היעד -->
            <div class="bg-white p-4 rounded-lg shadow-lg flex-1">
                <h3 id="gridTitle" class="text-lg font-bold mb-3 text-gray-700 text-center">שטח הריצוף (30×60)</h3>
                
                <!-- גריד היעד -->
                <div class="border-2 border-gray-300 p-2 bg-white inline-block overflow-auto max-h-96">
                    <div id="targetGrid" class="grid gap-0" style="grid-template-columns: repeat(60, 1fr);"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- חלון הוראות שימוש -->
    <div id="instructionsModal" class="fixed inset-0 bg-black bg-opacity-50 z-50 hidden flex items-center justify-center p-4">
        <div class="bg-white rounded-lg max-w-4xl max-h-[90vh] overflow-y-auto p-6 relative">
            <button onclick="hideInstructions()" class="absolute top-4 left-4 text-gray-500 hover:text-gray-700 text-2xl font-bold">×</button>
            
            <h2 class="text-2xl font-bold text-center mb-6 text-gray-800">📖 הוראות שימוש ביישומון ריצוף צורות</h2>
            
            <div class="space-y-6 text-right">
                <div class="bg-blue-50 p-4 rounded-lg">
                    <h3 class="text-lg font-bold text-blue-800 mb-2">🎯 מטרת היישומון</h3>
                    <p class="text-gray-700">יישומון זה מאפשר לך ליצור שטחי ריצוף מותאמים אישית ולרצף אותם באמצעות אריחים שעיצבת בעצמך.</p>
                </div>
                
                <div class="bg-green-50 p-4 rounded-lg">
                    <h3 class="text-lg font-bold text-green-800 mb-3">🏗️ שלב 1: יצירת שטח ריצוף</h3>
                    <ul class="space-y-2 text-gray-700">
                        <li><strong>יצירה אוטומטית:</strong> הזן רוחב וגובה (1-30) ולחץ "צור שטח ריצוף" ליצירת מלבן צבעוני</li>
                        <li><strong>יצירה ידנית:</strong> בחר צבע ולחץ על תאים בגריד הימני ליצירת צורות חופשיות (רק במצב יצירת שטח)</li>
                        <li><strong>גרירה:</strong> ניתן לגרור שטחים קיימים למיקומים חדשים על ידי לחיצה וגרירה בתוך השטח</li>
                        <li><strong>שכבות:</strong> שטחים יכולים לחפוף זה את זה - השטח האחרון שנוצר יהיה עליון</li>
                        <li><strong>צבעים:</strong> כל שטח נוצר בצבע שנבחר בפלטת הצבעים</li>
                        <li><strong>חשוב:</strong> חובה ללחוץ "סיים יצירת שטח" לפני מעבר לריצוף!</li>
                    </ul>
                </div>
                
                <div class="bg-purple-50 p-4 rounded-lg">
                    <h3 class="text-lg font-bold text-purple-800 mb-3">🧩 שלב 2: עיצוב האריח</h3>
                    <ul class="space-y-2 text-gray-700">
                        <li><strong>עיצוב:</strong> לחץ על תאים בגריד השמאלי (10×10) ליצירת צורת האריח - תאים נבחרים יהיו אפורים</li>
                        <li><strong>סיבוב:</strong> לחץ "סובב 90°" לסיבוב האריח בכיוון השעון</li>
                        <li><strong>היפוך:</strong> לחץ "הפוך" להיפוך האריח אופקית</li>
                        <li><strong>תצוגה:</strong> כל תצורות האריח (בסיס, סיבובים, היפוכים) מוצגות למטה עם תוויות</li>
                        <li><strong>בחירה:</strong> לחץ על אחת מהתצורות למטה לבחירת האריח הפעיל לריצוף</li>
                        <li><strong>ניקוי:</strong> לחץ "נקה אריח" למחיקת עיצוב האריח הנוכחי</li>
                    </ul>
                </div>
                
                <div class="bg-orange-50 p-4 rounded-lg">
                    <h3 class="text-lg font-bold text-orange-800 mb-3">🎨 שלב 3: ריצוף השטח</h3>
                    <ul class="space-y-2 text-gray-700">
                        <li><strong>התחלה:</strong> לחץ "התחל ריצוף" (רק אחרי לחיצה על "סיים יצירת שטח"!)</li>
                        <li><strong>תצוגה מקדימה:</strong> העבר עכבר על הגריד לראות איפה האריח יונח - ירוק = תקין, אדום = לא תקין</li>
                        <li><strong>הנחה:</strong> לחץ במיקום הרצוי להנחת האריח - האריח יקבל צבע אוטומטי</li>
                        <li><strong>הזזה:</strong> לחץ "🔄 הזזת אריחים", בחר אריח (יהבהב באדום) ולחץ על מיקום חדש</li>
                        <li><strong>סיבוב:</strong> במצב הזזת אריחים, בחר אריח ולחץ "🔄 סובב אריח" או מקש R</li>
                        <li><strong>היפוך:</strong> במצב הזזת אריחים, בחר אריח ולחץ "🔃 הפוך אריח" או מקש F</li>
                        <li><strong>מחיקה:</strong> במצב הזזת אריחים, בחר אריח ולחץ "🗑️ מחק אריח" או Delete/Backspace</li>
                        <li><strong>ניקוי:</strong> "נקה ריצוף" מסיר את כל האריחים אבל שומר על השטחים</li>
                        <li><strong>ביטול ריצוף:</strong> "בטל ריצוף" חוזר למצב עיצוב רגיל</li>
                        <li><strong>השלמה:</strong> כשכל השטח הצבעוני מכוסה באריחים תקבל הודעת הצלחה!</li>
                        <li><strong>חשוב:</strong> אריחים מונחים רק על שטחים צבעוניים ולא יכולים לחפוף</li>
                    </ul>
                </div>
                
                <div class="bg-gray-50 p-4 rounded-lg">
                    <h3 class="text-lg font-bold text-gray-800 mb-3">⚙️ כלים נוספים</h3>
                    <ul class="space-y-2 text-gray-700">
                        <li><strong>ביטול/חזרה:</strong> כפתורי ↶ ו-↷ לביטול וחזרה על פעולות (עד 50 פעולות)</li>
                        <li><strong>ניקוי שטח:</strong> "נקה שטח" מוחק את כל השטחים והאריחים</li>
                        <li><strong>ניקוי אריח:</strong> "נקה אריח" מוחק רק את עיצוב האריח בגריד השמאלי</li>
                        <li><strong>ניקוי ריצוף:</strong> "נקה ריצוף" מוחק רק את האריחים המונחים, שומר על השטחים</li>
                        <li><strong>צבעים:</strong> 7 צבעים זמינים לשטחים - כל שטח נוצר בצבע הנבחר</li>
                        <li><strong>צבעי אריחים:</strong> אריחים מקבלים צבעים אוטומטיים מגוונים לפי סדר ההנחה</li>
                    </ul>
                </div>
                
                <div class="bg-red-50 p-4 rounded-lg">
                    <h3 class="text-lg font-bold text-red-800 mb-3">⚠️ הערות חשובות</h3>
                    <ul class="space-y-2 text-gray-700">
                        <li><strong>סדר פעולות:</strong> יצירת שטח → סיום יצירת שטח → עיצוב אריח → התחלת ריצוף</li>
                        <li><strong>מגבלות מיקום:</strong> אריחים מונחים רק על שטחים צבעוניים (לא על רקע לבן)</li>
                        <li><strong>אי-חפיפה:</strong> אריחים לא יכולים לחפוף זה את זה או לצאת מגבולות הגריד</li>
                        <li><strong>שמירת נתונים:</strong> השטחים נשמרים גם אחרי ניקוי הריצוף</li>
                        <li><strong>אופן הנחה:</strong> אריחים מונחים בלחיצה פשוטה - אין צורך בגרירה</li>
                        <li><strong>גרירת שטחים:</strong> ניתן לגרור שטחים רק במצב יצירת שטח</li>
                        <li><strong>עריכת אריחים:</strong> ניתן לגרור, לסובב ולהפוך אריחים רק במצב הזזת אריחים</li>
                        <li><strong>מקשי קיצור:</strong> R לסיבוב, F להיפוך, Delete/Backspace למחיקה (רק כשאריח נבחר)</li>
                    </ul>
                </div>
            </div>
            
            <div class="text-center mt-6">
                <button onclick="hideInstructions()" class="control-btn bg-blue-600 hover:bg-blue-700">הבנתי - בואו נתחיל!</button>
            </div>
        </div>
    </div>

    <!-- שורת זכויות יוצרים -->
    <div class="text-center mt-6 py-2 text-xs text-gray-400 border-t border-gray-200">
        כל הזכויות שמורות לאושרת וים רון
    </div>

    <script>
        let selectedColor = '#ef4444';
        let targetGridData = [];
        let tileGridData = [];
        let currentTile = [];
        let tilingMode = false;
        let placedTiles = [];
        let previewPosition = null;
        let shapeCreationMode = false;
        let isDragging = false;
        let dragStartPos = null;
        let createdShapes = [];
        let draggedShape = null;
        let removeMode = false;
        let actionHistory = [];
        let historyIndex = -1;
        let tileMoveMode = false;
        let selectedTileForMove = null;
        let draggedTile = null;
        
        // מצבי גרירת אריחים (Pointer Events)
        let isTileDragging = false;
        let usingPointerDrag = false;
        let tileDragPointerId = null;
        let tileDragStartCell = null;
        let lastTileDragTarget = null;
        let tileDragMoved = false;
        let suppressClick = false;
        let tileDragStartPoint = null;
        let tileGrabOffset = null; // שמירת מיקום האחיזה ביחס לפינת האריח

        // מאזיני Pointer מאוחדים לגרירת אריחים (נוספים פעם אחת בלבד)
        if (!window._tilePointerListenersAdded) {
            window._tilePointerListenersAdded = true;
            document.addEventListener('pointermove', onTilePointerMove, { passive: false });
            document.addEventListener('pointerup', onTilePointerUp, { passive: false });
            document.addEventListener('pointercancel', onTilePointerUp, { passive: false });
        }


        // אתחול הגרידים
        function initGrids() {
            // גריד היעד 30x60
            const targetGrid = document.getElementById('targetGrid');
            targetGridData = Array(30).fill().map(() => Array(60).fill('#ffffff'));
            
            for (let i = 0; i < 30; i++) {
                for (let j = 0; j < 60; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.style.backgroundColor = '#ffffff';
                    cell.onclick = () => { if (suppressClick) return; paintTargetCell(i, j); };
                    cell.onmousedown = (e) => handleMouseDown(i, j, e);
                    cell.ontouchstart = (e) => {
                        e.preventDefault();
                        handleMouseDown(i, j, e);
                    };
                    // התחלת גרירת אריחים באופן מאוחד (מחשב ומובייל)
                    cell.onpointerdown = (e) => startTilePointerDrag(i, j, e);
                    cell.onmouseenter = () => {
                        if (tilingMode && currentTile.length > 0) {
                            showTilePreview(i, j);
                        } else if (isDragging && shapeCreationMode) {
                            handleDrag(i, j);
                        } else if (tileMoveMode && selectedTileForMove) {
                            // תצוגה מקדימה חלקה בזמן גרירת אריח
                            showSmoothTileDragPreview(i, j);
                        }
                    };
                    cell.onmouseleave = () => {
                        if (tilingMode) {
                            clearTilePreview();
                        }
                    };
                    
                    // מאזיני מגע משופרים לגרירה חלקה
                    let cellTouchStartTime = 0;
                    let cellTouchMoved = false;
                    let cellTouchStartPos = null;
                    
                    cell.ontouchstart = (e) => {
                        if (tileMoveMode) return; // בגרירת אריחים נטפל ב-Pointer Events
                        e.preventDefault();
                        cellTouchStartTime = Date.now();
                        cellTouchMoved = false;
                        cellTouchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                        handleMouseDown(i, j, e);
                    };
                    
                    cell.ontouchmove = (e) => {
                        if (tileMoveMode) return; // בגרירת אריחים נטפל ב-Pointer Events
                        e.preventDefault();
                        const touch = e.touches[0];
                        
                        // בדיקת מרחק גרירה
                        if (cellTouchStartPos) {
                            const deltaX = Math.abs(touch.clientX - cellTouchStartPos.x);
                            const deltaY = Math.abs(touch.clientY - cellTouchStartPos.y);
                            if (deltaX > dragThreshold || deltaY > dragThreshold) {
                                cellTouchMoved = true;
                            }
                        }
                        
                        const element = document.elementFromPoint(touch.clientX, touch.clientY);
                        if (element && element.classList.contains('grid-cell')) {
                            const cellIndex = Array.from(element.parentNode.children).indexOf(element);
                            const touchRow = Math.floor(cellIndex / 60);
                            const touchCol = cellIndex % 60;
                            
                            if (tilingMode && currentTile.length > 0) {
                                showTilePreview(touchRow, touchCol);
                            } else if (isDragging && shapeCreationMode) {
                                handleDrag(touchRow, touchCol);
                            } else if (tileMoveMode && selectedTileForMove) {
                                // גרירה אוטומטית של אריח במובייל
                                if (cellTouchMoved) {
                                    moveTileToPositionAuto(touchRow, touchCol);
                                } else {
                                    showSmoothTileDragPreview(touchRow, touchCol);
                                }
                            }
                        }
                    };
                    
                    cell.ontouchend = (e) => {
                        if (tileMoveMode || usingPointerDrag) return; // מניעת כפילות במצב גרירת אריחים
                        e.preventDefault();
                        const touchDuration = Date.now() - cellTouchStartTime;
                        
                        // אם זה היה טאפ קצר (לא גרירה), בצע את הפעולה המתאימה
                        if (!cellTouchMoved && touchDuration < 500) {
                            if (tilingMode) {
                                placeTileAt(i, j);
                            } else if (tileMoveMode) {
                                if (selectedTileForMove) {
                                    // במובייל - הזזה אוטומטית ללא צורך בלחיצה נוספת
                                    moveTileToPositionAuto(i, j);
                                } else {
                                    selectTileForMove(i, j);
                                }
                            } else if (shapeCreationMode) {
                                paintTargetCell(i, j);
                            }
                        } else if (cellTouchMoved) {
                            // אם היתה גרירה, הפעולה כבר בוצעה במהלך touchmove
                            if (tileMoveMode && selectedTileForMove) {
                                // שמירת המצב החדש אחרי הגרירה
                                saveState();
                                
                                // איפוס הבחירה אחרי הזזה מוצלחת
                                selectedTileForMove = null;
                                const deleteBtn = document.getElementById('deleteTileBtn');
                                deleteBtn.style.display = 'none';
                                clearTileDragPreview();
                                showStatus('האריח הוזז בהצלחה!', 'success');
                                checkTilingComplete();
                            } else if (shapeCreationMode && draggedShape) {
                                // שמירת מצב אחרי גרירת שטח
                                saveState();
                            }
                        }
                        
                        handleMouseUp();
                        clearTilePreview();
                        cellTouchStartPos = null;
                    };
                    targetGrid.appendChild(cell);
                }
            }
            
            // גריד עיצוב האריח 10x10
            const tileGrid = document.getElementById('tileGrid');
            tileGridData = Array(10).fill().map(() => Array(10).fill(false));
            
            for (let i = 0; i < 10; i++) {
                for (let j = 0; j < 10; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'tile-cell';
                    cell.style.backgroundColor = '#ffffff';
                    cell.onclick = () => toggleTileCell(i, j);
                    
                    // הוספת תמיכה במגע לגריד האריח
                    cell.ontouchstart = (e) => {
                        e.preventDefault();
                    };
                    
                    cell.ontouchend = (e) => {
                        e.preventDefault();
                        toggleTileCell(i, j);
                    };
                    
                    tileGrid.appendChild(cell);
                }
            }
            
            updateCurrentTile();
            
            // הוספת מאזיני עכבר ומגע גלובליים
            document.addEventListener('mouseup', handleMouseUp);
            document.addEventListener('touchend', handleMouseUp);
            document.addEventListener('touchcancel', handleMouseUp);
        }

        // בחירת צבע עם תמיכה במגע
        document.querySelectorAll('.color-btn').forEach(btn => {
            btn.onclick = () => {
                document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                selectedColor = btn.dataset.color;
            };
            
            // תמיכה במגע
            btn.ontouchend = (e) => {
                e.preventDefault();
                document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                selectedColor = btn.dataset.color;
            };
        });

        // פונקציות טיפול בעכבר ומגע
        let touchStartTime = 0;
        let touchMoved = false;
        let lastTouchPos = null;
        let dragThreshold = 5; // מינימום פיקסלים לזיהוי גרירה

        function handleMouseDown(row, col, e) {
            if (shapeCreationMode) {
                // בדיקה אם לוחצים על שטח קיים
                const clickedShape = findShapeAtPosition(row, col);
                if (clickedShape) {
                    // תמיד מאפשר גרירה של שטח קיים
                    isDragging = true;
                    draggedShape = clickedShape;
                    
                    // שמירת המיקום המדויק של הלחיצה בתוך השטח
                    dragStartPos = [row, col];
                    
                    // הזזת השטח לשכבה העליונה
                    const shapeIndex = createdShapes.indexOf(clickedShape);
                    if (shapeIndex > -1) {
                        createdShapes.splice(shapeIndex, 1);
                        createdShapes.push(clickedShape);
                    }
                } else {
                    // יצירת שטח חדש בגרירה
                    isDragging = true;
                    dragStartPos = [row, col];
                }
                
                // שמירת נתוני מגע
                if (e.touches && e.touches[0]) {
                    lastTouchPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    touchStartTime = Date.now();
                    touchMoved = false;
                }
                
                e.preventDefault();
            }
        }

        function handleMouseUp() {
            if (isDragging && draggedShape) {
                // סיום גרירה - עדכון סופי של המיקום
                updateGridDisplay();
                saveState(); // שמירת המצב החדש
            }
            isDragging = false;
            dragStartPos = null;
            draggedShape = null;
            lastTouchPos = null;
            touchMoved = false;
        }

        // התחלת גרירת אריחים (Pointer Events)
        function startTilePointerDrag(row, col, e) {
            if (!tileMoveMode) return;
            usingPointerDrag = true;
            tileDragPointerId = e.pointerId;
            e.preventDefault();
            if (e.stopPropagation) e.stopPropagation();
            if (e.target && e.target.setPointerCapture) {
                try { e.target.setPointerCapture(e.pointerId); } catch (_) {}
            }

            if (!selectedTileForMove) {
                selectTileForMove(row, col);
            }
            if (!selectedTileForMove) return;

            isTileDragging = true;
            tileDragStartCell = [row, col];
            tileDragStartPoint = { x: e.clientX, y: e.clientY };
            tileDragMoved = false;
            suppressClick = false;

            // חישוב היסט האחיזה ביחס לפינת האריח (minRow/minCol)
            try {
                const { tile } = selectedTileForMove;
                const currentBounds = getTileBounds(tile.positions.map(([r, c]) => [r, c]));
                tileGrabOffset = [row - currentBounds.minRow, col - currentBounds.minCol];
            } catch (_) {
                tileGrabOffset = [0, 0];
            }
        }

        function onTilePointerMove(e) {
            if (!tileMoveMode || !isTileDragging) return;
            if (tileDragPointerId !== null && e.pointerId !== tileDragPointerId) return;
            e.preventDefault();

            const element = document.elementFromPoint(e.clientX, e.clientY);
            if (!element || !element.classList || !element.classList.contains('grid-cell')) return;
            const cellIndex = Array.from(element.parentNode.children).indexOf(element);
            const hoverRow = Math.floor(cellIndex / 60);
            const hoverCol = cellIndex % 60;

            // התאמת היעד כך שהאריח יעקוב אחרי נקודת האחיזה
            const grabRowOffset = tileGrabOffset ? tileGrabOffset[0] : 0;
            const grabColOffset = tileGrabOffset ? tileGrabOffset[1] : 0;
            const targetRow = hoverRow - grabRowOffset;
            const targetCol = hoverCol - grabColOffset;

            if (!tileDragStartPoint) {
                tileDragStartPoint = { x: e.clientX, y: e.clientY };
            }
            const dx = Math.abs(e.clientX - tileDragStartPoint.x);
            const dy = Math.abs(e.clientY - tileDragStartPoint.y);
            const movedEnough = dx > 3 || dy > 3;

            if (movedEnough) {
                tileDragMoved = true;
                suppressClick = true;
                moveTileToPositionAuto(targetRow, targetCol);
            } else {
                showSmoothTileDragPreview(targetRow, targetCol);
            }
        }

        function onTilePointerUp(e) {
            if (!tileMoveMode) return;
            if (tileDragPointerId !== null && e.pointerId !== tileDragPointerId) return;
            e.preventDefault();

            if (isTileDragging) {
                if (tileDragMoved && selectedTileForMove) {
                    saveState();
                    selectedTileForMove = null;
                    clearTileDragPreview();
                    showStatus('האריח הוזז בהצלחה!', 'success');
                    checkTilingComplete();
                }
            }
            isTileDragging = false;
            usingPointerDrag = false;
            tileDragPointerId = null;
            tileDragStartCell = null;
            tileDragStartPoint = null;
            tileGrabOffset = null;
            setTimeout(() => { suppressClick = false; }, 0);
        }

        function handleDrag(row, col) {
            if (!isDragging || !dragStartPos) return;
            
            if (draggedShape) {
                // גרירת שטח קיים - השטח יזוז כך שהתא שלחצנו עליו יישאר תחת הסמן
                const deltaRow = row - dragStartPos[0];
                const deltaCol = col - dragStartPos[1];
                
                // חישוב המיקום החדש של כל תא בשטח
                const newCells = draggedShape.cells.map(([r, c]) => [r + deltaRow, c + deltaCol]);
                
                // בדיקה שכל התאים החדשים בתוך הגבולות
                const isValidMove = newCells.every(([r, c]) => 
                    r >= 0 && r < 30 && c >= 0 && c < 60
                );
                
                if (isValidMove) {
                    // עדכון המיקום החדש מיידית
                    draggedShape.cells = newCells;
                    
                    // עדכון מיידי של התצוגה עם אפקט ויזואלי חלק
                    updateGridDisplaySmooth();
                    
                    // עדכון dragStartPos למיקום הנוכחי כדי שהגרירה תהיה חלקה
                    dragStartPos = [row, col];
                }
            } else {
                // יצירת שטח חדש
                const startRow = Math.min(dragStartPos[0], row);
                const endRow = Math.max(dragStartPos[0], row);
                const startCol = Math.min(dragStartPos[1], col);
                const endCol = Math.max(dragStartPos[1], col);
                
                // צביעת האזור הנגרר עם אפקט חלק
                for (let i = startRow; i <= endRow; i++) {
                    for (let j = startCol; j <= endCol; j++) {
                        targetGridData[i][j] = selectedColor;
                        const cellIndex = i * 60 + j;
                        const cell = document.getElementById('targetGrid').children[cellIndex];
                        cell.style.backgroundColor = selectedColor;
                        cell.style.border = '2px solid #374151';
                        cell.style.transition = 'all 0.1s ease'; // אפקט מעבר חלק
                    }
                }
            }
        }

        // עדכון תצוגה חלק לגרירה
        function updateGridDisplaySmooth() {
            // עדכון targetGridData תחילה לפי השטחים הקיימים
            for (let i = 0; i < 30; i++) {
                for (let j = 0; j < 60; j++) {
                    targetGridData[i][j] = '#ffffff'; // איפוס לרקע לבן
                }
            }
            
            // עדכון targetGridData לפי השטחים הקיימים (לפי סדר יצירה)
            createdShapes.forEach(shape => {
                shape.cells.forEach(([row, col]) => {
                    targetGridData[row][col] = shape.color;
                });
            });
            
            // עכשיו עדכון התצוגה הויזואלית עם אפקטים חלקים
            for (let i = 0; i < 30; i++) {
                for (let j = 0; j < 60; j++) {
                    const cellIndex = i * 60 + j;
                    const cell = document.getElementById('targetGrid').children[cellIndex];
                    
                    // איפוס כל הסטיילים
                    cell.style.backgroundColor = targetGridData[i][j];
                    cell.style.border = '1px solid #e5e7eb';
                    cell.style.transition = 'all 0.05s ease'; // מעבר מהיר וחלק
                    
                    // בורדר מיוחד במצב יצירת שטח
                    if (shapeCreationMode && targetGridData[i][j] !== '#ffffff') {
                        cell.style.border = '2px solid #374151';
                    }
                }
            }
            
            // עדכון אריחים מונחים (תמיד בשכבה העליונה)
            placedTiles.forEach(tile => {
                tile.positions.forEach(([row, col]) => {
                    const cellIndex = row * 60 + col;
                    const cell = document.getElementById('targetGrid').children[cellIndex];
                    cell.style.backgroundColor = tile.color || '#7dd3fc';
                    cell.style.transition = 'all 0.05s ease';
                    
                    // קביעת הבורדר
                    const isEdge = isEdgeOfTile(row, col, tile.positions);
                    const borderColor = tile.borderColor || '#1e40af';
                    
                    cell.style.borderTop = isEdge.top ? `2px solid ${borderColor}` : '1px solid #ffffff';
                    cell.style.borderRight = isEdge.right ? `2px solid ${borderColor}` : '1px solid #ffffff';
                    cell.style.borderBottom = isEdge.bottom ? `2px solid ${borderColor}` : '1px solid #ffffff';
                    cell.style.borderLeft = isEdge.left ? `2px solid ${borderColor}` : '1px solid #ffffff';
                });
            });
            
            // הדגשה במצב הזזת אריחים
            if (tileMoveMode) {
                highlightMovableTiles();
            }
        }

        // מציאת שטח במיקום - השטח העליון ביותר
        function findShapeAtPosition(row, col) {
            // חיפוש מהשטח האחרון (העליון) לראשון
            for (let i = createdShapes.length - 1; i >= 0; i--) {
                const shape = createdShapes[i];
                if (shape.cells.some(([r, c]) => r === row && c === col)) {
                    return shape;
                }
            }
            return null;
        }



        // בדיקה אם נקודה נמצאת בתוך האריח או בסביבתו הקרובה (1 מ"מ)
        function isWithinTileDragArea(row, col, tile) {
            if (!tile || tile.length === 0) return false;
            
            const bounds = getTileBounds(tile);
            const margin = 1; // 1 מ"מ סביב האריח
            
            return row >= bounds.minRow - margin && 
                   row <= bounds.maxRow + margin && 
                   col >= bounds.minCol - margin && 
                   col <= bounds.maxCol + margin;
        }
        
        // קבלת הצבע הנכון לתא לפי שכבות
        function getTopLayerColor(row, col) {
            // חיפוש מהשטח האחרון (העליון) לראשון
            for (let i = createdShapes.length - 1; i >= 0; i--) {
                const shape = createdShapes[i];
                if (shape.cells.some(([r, c]) => r === row && c === col)) {
                    return shape.color;
                }
            }
            return '#ffffff'; // צבע רקע אם אין שטח
        }

        // קבלת הצבע הנכון לתא לפי שכבות, למעט שטח מסוים
        function getTopLayerColorExcluding(row, col, excludeShape) {
            // חיפוש מהשטח האחרון (העליון) לראשון, למעט השטח שמוחרג
            for (let i = createdShapes.length - 1; i >= 0; i--) {
                const shape = createdShapes[i];
                if (shape !== excludeShape && shape.cells.some(([r, c]) => r === row && c === col)) {
                    return shape.color;
                }
            }
            return '#ffffff'; // צבע רקע אם אין שטח
        }

        // הזזת שטח
        function moveShape(shape, newRow, newCol) {
            // השטח יזוז כך שהתא שלחצנו עליו יהיה בדיוק במיקום הסמן
            const clickedCellInShape = dragStartPos;
            
            // חישוב ההפרש בין התא שלחצנו עליו לכל תא אחר בשטח
            const shapeOffsets = shape.cells.map(([r, c]) => [r - clickedCellInShape[0], c - clickedCellInShape[1]]);
            
            // חישוב המיקום החדש של כל תא בשטח - התא שלחצנו עליו יהיה בדיוק במיקום הסמן
            const newCells = shapeOffsets.map(([offsetR, offsetC]) => [newRow + offsetR, newCol + offsetC]);
            
            // בדיקה שכל התאים החדשים בתוך הגבולות
            const isValidMove = newCells.every(([r, c]) => 
                r >= 0 && r < 30 && c >= 0 && c < 60
            );
            
            if (!isValidMove) return;
            
            // שמירת המיקום הישן לניקוי
            const oldCells = [...shape.cells];
            
            // עדכון המיקום החדש
            shape.cells = newCells;
            
            // ניקוי המיקום הישן - עדכון targetGridData לפי השכבות
            oldCells.forEach(([row, col]) => {
                const correctColor = getTopLayerColor(row, col);
                targetGridData[row][col] = correctColor;
                const cellIndex = row * 60 + col;
                const cell = document.getElementById('targetGrid').children[cellIndex];
                cell.style.backgroundColor = correctColor;
                
                if (correctColor === '#ffffff') {
                    cell.style.border = '1px solid #e5e7eb';
                } else {
                    cell.style.border = '2px solid #374151';
                }
            });
            
            // צביעת המיקום החדש - השטח הנגרר יהיה בשכבה עליונה
            shape.cells.forEach(([row, col]) => {
                targetGridData[row][col] = shape.color;
                const cellIndex = row * 60 + col;
                const cell = document.getElementById('targetGrid').children[cellIndex];
                cell.style.backgroundColor = shape.color;
                cell.style.border = '2px solid #374151';
            });
        }

        // צביעת תא בגריד היעד
        function paintTargetCell(row, col) {
            if (tileMoveMode) {
                // מצב הזזת אריחים
                if (selectedTileForMove) {
                    // אריח נבחר - נסה להזיז אותו
                    moveTileToPosition(row, col);
                } else {
                    // אין אריח נבחר - נסה לבחור אריח
                    selectTileForMove(row, col);
                }
                return;
            }
            
            if (tilingMode) {
                placeTileAt(row, col);
                return;
            }
            
            if (shapeCreationMode) {
                targetGridData[row][col] = selectedColor;
                const cellIndex = row * 60 + col;
                const cell = document.getElementById('targetGrid').children[cellIndex];
                if (cell) {
                    cell.style.backgroundColor = selectedColor;
                    cell.style.border = '2px solid #374151';
                }
                return;
            }
            
            // מצב רגיל - צביעה פשוטה
            targetGridData[row][col] = selectedColor;
            const cellIndex = row * 60 + col;
            const cell = document.getElementById('targetGrid').children[cellIndex];
            if (cell) {
                cell.style.backgroundColor = selectedColor;
            }
        }

        // יצירת שטח אוטומטי
        function createAutoShape() {
            const widthInput = document.getElementById('shapeWidth');
            const heightInput = document.getElementById('shapeHeight');
            
            if (!widthInput || !heightInput) {
                showStatus('שגיאה בקריאת נתוני הגודל', 'error');
                return;
            }
            
            const width = parseInt(widthInput.value) || 10;
            const height = parseInt(heightInput.value) || 10;
            
            if (width < 1 || width > 30 || height < 1 || height > 30) {
                showStatus('גודל השטח חייב להיות בין 1 ל-30', 'error');
                return;
            }
            
            // שמירת המצב לפני השינוי
            saveState();
            
            shapeCreationMode = true;
            updateGridTitle();
            
            // מציאת מיקום פנוי - התחלה מהמרכז
            let startRow = Math.max(0, Math.floor((30 - height) / 2));
            let startCol = Math.max(0, Math.floor((60 - width) / 2));
            
            // אם המיקום תפוס, מצא מיקום פנוי
            let attempts = 0;
            while (isAreaOccupied(startRow, startCol, width, height) && attempts < 100) {
                startRow = Math.floor(Math.random() * Math.max(1, 30 - height));
                startCol = Math.floor(Math.random() * Math.max(1, 60 - width));
                attempts++;
            }
            
            // יצירת השטח החדש
            const newShape = {
                id: Date.now(),
                startRow: startRow,
                startCol: startCol,
                width: width,
                height: height,
                color: selectedColor,
                cells: []
            };
            
            // צביעת המלבן והוספת התאים לשטח
            for (let i = startRow; i < startRow + height && i < 30; i++) {
                for (let j = startCol; j < startCol + width && j < 60; j++) {
                    targetGridData[i][j] = selectedColor;
                    const cellIndex = i * 60 + j;
                    const cell = document.getElementById('targetGrid').children[cellIndex];
                    if (cell) {
                        cell.style.backgroundColor = selectedColor;
                        cell.style.border = '2px solid #374151';
                    }
                    newShape.cells.push([i, j]);
                }
            }
            
            createdShapes.push(newShape);
            showStatus(`נוצר שטח ${width}×${height} - ניתן לגרור ולהוסיף שטחים נוספים`, 'success');
        }

        // בדיקה אם אזור תפוס
        function isAreaOccupied(startRow, startCol, width, height) {
            for (let i = startRow; i < startRow + height && i < 30; i++) {
                for (let j = startCol; j < startCol + width && j < 30; j++) {
                    if (targetGridData[i][j] !== '#ffffff') {
                        return true;
                    }
                }
            }
            return false;
        }

        // עדכון כותרת הגריד
        function updateGridTitle() {
            const title = document.getElementById('gridTitle');
            if (shapeCreationMode) {
                title.textContent = '🎨 מצב יצירת שטחי ריצוף (30×60) - ניתן לגרור ולהוסיף';
                title.className = 'text-lg font-bold mb-3 text-blue-700 text-center';
            } else if (tileMoveMode) {
                title.textContent = '🔄 מצב הזזת אריחים (30×60) - לחץ על אריח ואז על מיקום חדש';
                title.className = 'text-lg font-bold mb-3 text-yellow-700 text-center';
            } else if (tilingMode) {
                title.textContent = '🧩 מצב ריצוף פעיל (30×60) - השטח מקובע';
                title.className = 'text-lg font-bold mb-3 text-green-700 text-center';
            } else {
                title.textContent = 'שטח הריצוף (30×60)';
                title.className = 'text-lg font-bold mb-3 text-gray-700 text-center';
            }
        }





        // סיום יצירת שטח
        function finishShapeCreation() {
            shapeCreationMode = false;
            isDragging = false;
            dragStartPos = null;
            draggedShape = null;
            
            // הסרת הבורדר המיוחד מכל השטחים
            createdShapes.forEach(shape => {
                shape.cells.forEach(([row, col]) => {
                    const cellIndex = row * 60 + col;
                    const cell = document.getElementById('targetGrid').children[cellIndex];
                    cell.style.border = '1px solid #e5e7eb';
                });
            });
            
            updateGridTitle();
            showStatus('יצירת שטח הושלמה - השטח מוכן לריצוף', 'info');
        }

        // החלפת מצב תא באריח
        function toggleTileCell(row, col) {
            tileGridData[row][col] = !tileGridData[row][col];
            const cellIndex = row * 10 + col;
            const cell = document.getElementById('tileGrid').children[cellIndex];
            cell.style.backgroundColor = tileGridData[row][col] ? '#374151' : '#ffffff';
            updateCurrentTile();
        }

        // עדכון האריח הנוכחי
        function updateCurrentTile() {
            const newTile = [];
            for (let i = 0; i < 10; i++) {
                for (let j = 0; j < 10; j++) {
                    if (tileGridData[i][j]) {
                        newTile.push([i, j]);
                    }
                }
            }
            currentTile = newTile;
            generateAllTileVariations();
        }

        // יצירת כל תצורות האריח
        function generateAllTileVariations() {
            const container = document.getElementById('allTileVariations');
            container.innerHTML = '';
            
            if (currentTile.length === 0) {
                container.innerHTML = '<div class="text-gray-500 text-sm">אין אריח</div>';
                return;
            }
            
            const variations = [];
            let baseTile = normalizeTile(currentTile);
            
            // תצורה בסיסית
            variations.push({ tile: baseTile, label: 'בסיס' });
            
            // סיבוב 90 מעלות
            let rotated90 = normalizeTile(rotateTileArray(baseTile, 1));
            if (!isTileEqual(baseTile, rotated90)) {
                variations.push({ tile: rotated90, label: '90°' });
            }
            
            // סיבוב 180 מעלות
            let rotated180 = normalizeTile(rotateTileArray(baseTile, 2));
            if (!variations.some(v => isTileEqual(v.tile, rotated180))) {
                variations.push({ tile: rotated180, label: '180°' });
            }
            
            // סיבוב 270 מעלות
            let rotated270 = normalizeTile(rotateTileArray(baseTile, 3));
            if (!variations.some(v => isTileEqual(v.tile, rotated270))) {
                variations.push({ tile: rotated270, label: '270°' });
            }
            
            // היפוך אופקי
            let flippedH = normalizeTile(flipTileArray(baseTile, 'horizontal'));
            if (!variations.some(v => isTileEqual(v.tile, flippedH))) {
                variations.push({ tile: flippedH, label: 'היפוך' });
            }
            
            // היפוך אנכי
            let flippedV = normalizeTile(flipTileArray(baseTile, 'vertical'));
            if (!variations.some(v => isTileEqual(v.tile, flippedV))) {
                variations.push({ tile: flippedV, label: 'היפוך ↕' });
            }
            
            // שילובים של היפוך וסיבוב
            [flippedH, flippedV].forEach((flipped, idx) => {
                for (let rot = 1; rot <= 3; rot++) {
                    let combined = normalizeTile(rotateTileArray(flipped, rot));
                    if (!variations.some(v => isTileEqual(v.tile, combined))) {
                        variations.push({ 
                            tile: combined, 
                            label: `${idx === 0 ? 'היפוך' : 'היפוך↕'}+${rot * 90}°` 
                        });
                    }
                }
            });
            
            // הצגת כל התצורות
            variations.forEach((variation, index) => {
                const tileDiv = createTilePreview(variation.tile, variation.label, index);
                container.appendChild(tileDiv);
            });
        }

        // יצירת תצוגה מקדימה של אריח
        function createTilePreview(tile, label, index) {
            const container = document.createElement('div');
            container.className = 'flex flex-col items-center p-1 border border-gray-300 rounded cursor-pointer hover:bg-blue-50 transition-colors';
            container.onclick = () => selectTileVariation(tile, index);
            
            const bounds = getTileBounds(tile);
            const rows = bounds.maxRow - bounds.minRow + 1;
            const cols = bounds.maxCol - bounds.minCol + 1;
            
            const grid = document.createElement('div');
            grid.className = 'grid gap-0 mb-1';
            grid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
            
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'w-1.5 h-1.5 border-0';
                    const isPartOfTile = tile.some(pos => 
                        pos[0] === bounds.minRow + i && pos[1] === bounds.minCol + j
                    );
                    cell.style.backgroundColor = isPartOfTile ? '#374151' : 'transparent';
                    grid.appendChild(cell);
                }
            }
            
            const labelDiv = document.createElement('div');
            labelDiv.className = 'text-xs text-gray-600 text-center';
            labelDiv.textContent = label;
            
            container.appendChild(grid);
            container.appendChild(labelDiv);
            
            return container;
        }

        // בחירת תצורת אריח
        function selectTileVariation(tile, index) {
            currentTile = [...tile];
            
            // סימון הבחירה
            document.querySelectorAll('#allTileVariations > div').forEach((div, i) => {
                if (i === index) {
                    div.classList.add('bg-blue-100', 'border-blue-500');
                } else {
                    div.classList.remove('bg-blue-100', 'border-blue-500');
                }
            });
        }

        // פונקציות עזר לעיבוד אריחים
        function normalizeTile(tile) {
            if (tile.length === 0) return [];
            const bounds = getTileBounds(tile);
            return tile.map(([row, col]) => [row - bounds.minRow, col - bounds.minCol]);
        }

        function getTileBounds(tile) {
            if (tile.length === 0) return { minRow: 0, maxRow: 0, minCol: 0, maxCol: 0 };
            return {
                minRow: Math.min(...tile.map(pos => pos[0])),
                maxRow: Math.max(...tile.map(pos => pos[0])),
                minCol: Math.min(...tile.map(pos => pos[1])),
                maxCol: Math.max(...tile.map(pos => pos[1]))
            };
        }

        function rotateTileArray(tile, times) {
            let result = [...tile];
            for (let t = 0; t < times; t++) {
                const bounds = getTileBounds(result);
                const centerRow = (bounds.maxRow + bounds.minRow) / 2;
                const centerCol = (bounds.maxCol + bounds.minCol) / 2;
                
                result = result.map(([row, col]) => [
                    Math.round(centerRow + (col - centerCol)),
                    Math.round(centerCol - (row - centerRow))
                ]);
            }
            return result;
        }

        function flipTileArray(tile, direction) {
            const bounds = getTileBounds(tile);
            if (direction === 'horizontal') {
                return tile.map(([row, col]) => [row, bounds.maxCol - col + bounds.minCol]);
            } else {
                return tile.map(([row, col]) => [bounds.maxRow - row + bounds.minRow, col]);
            }
        }

        function isTileEqual(tile1, tile2) {
            if (tile1.length !== tile2.length) return false;
            const sorted1 = tile1.map(p => p.join(',')).sort();
            const sorted2 = tile2.map(p => p.join(',')).sort();
            return sorted1.every((p, i) => p === sorted2[i]);
        }

        // ניקוי שטח היעד
        function clearTarget() {
            targetGridData = Array(30).fill().map(() => Array(60).fill('#ffffff'));
            document.querySelectorAll('#targetGrid .grid-cell').forEach(cell => {
                cell.style.backgroundColor = '#ffffff';
                cell.style.border = '1px solid #e5e7eb';
            });
            clearTiling();
            shapeCreationMode = false;
            createdShapes = [];
            updateGridTitle();
        }

        // ניקוי האריח
        function clearTile() {
            tileGridData = Array(10).fill().map(() => Array(10).fill(false));
            document.querySelectorAll('#tileGrid .tile-cell').forEach(cell => {
                cell.style.backgroundColor = '#ffffff';
            });
            updateCurrentTile();
            
            // הוספת מאזיני עכבר ומגע גלובליים
            document.addEventListener('mouseup', handleMouseUp);
            document.addEventListener('touchend', handleMouseUp);
            document.addEventListener('touchcancel', handleMouseUp);
        }

        // ניקוי גריד האריח בלבד
        function clearTileGrid() {
            tileGridData = Array(10).fill().map(() => Array(10).fill(false));
            document.querySelectorAll('#tileGrid .tile-cell').forEach(cell => {
                cell.style.backgroundColor = '#ffffff';
            });
        }

        // סיבוב האריח
        function rotateTile() {
            if (currentTile.length === 0) return;
            
            // מציאת מרכז הסיבוב
            const centerRow = Math.max(...currentTile.map(pos => pos[0])) / 2 + Math.min(...currentTile.map(pos => pos[0])) / 2;
            const centerCol = Math.max(...currentTile.map(pos => pos[1])) / 2 + Math.min(...currentTile.map(pos => pos[1])) / 2;
            
            // סיבוב 90 מעלות
            const rotatedTile = currentTile.map(([row, col]) => {
                const newRow = Math.round(centerRow + (col - centerCol));
                const newCol = Math.round(centerCol - (row - centerRow));
                return [newRow, newCol];
            });
            
            // נרמול המיקום
            const minRow = Math.min(...rotatedTile.map(pos => pos[0]));
            const minCol = Math.min(...rotatedTile.map(pos => pos[1]));
            
            const normalizedTile = rotatedTile.map(([row, col]) => [row - minRow, col - minCol]);
            
            // עדכון הגריד
            clearTileGrid();
            normalizedTile.forEach(([row, col]) => {
                if (row >= 0 && row < 10 && col >= 0 && col < 10) {
                    tileGridData[row][col] = true;
                    const cellIndex = row * 10 + col;
                    const cell = document.getElementById('tileGrid').children[cellIndex];
                    cell.style.backgroundColor = '#374151';
                }
            });
            
            // עדכון currentTile ישירות עם הערכים החדשים
            currentTile = normalizedTile;
            generateAllTileVariations();
        }

        // היפוך האריח
        function flipTile() {
            if (currentTile.length === 0) return;
            
            const maxCol = Math.max(...currentTile.map(pos => pos[1]));
            const flippedTile = currentTile.map(([row, col]) => [row, maxCol - col]);
            
            // נרמול המיקום
            const minRow = Math.min(...flippedTile.map(pos => pos[0]));
            const minCol = Math.min(...flippedTile.map(pos => pos[1]));
            
            const normalizedTile = flippedTile.map(([row, col]) => [row - minRow, col - minCol]);
            
            // עדכון הגריד
            clearTileGrid();
            normalizedTile.forEach(([row, col]) => {
                if (row >= 0 && row < 10 && col >= 0 && col < 10) {
                    tileGridData[row][col] = true;
                    const cellIndex = row * 10 + col;
                    const cell = document.getElementById('tileGrid').children[cellIndex];
                    cell.style.backgroundColor = '#374151';
                }
            });
            
            // עדכון currentTile ישירות עם הערכים החדשים
            currentTile = normalizedTile;
            generateAllTileVariations();
        }

        // שמירת מצב לביטול/חזרה
        function saveState() {
            // הסרת כל המצבים שאחרי המצב הנוכחי (אם עשינו ביטול ועכשיו עושים פעולה חדשה)
            actionHistory = actionHistory.slice(0, historyIndex + 1);
            
            // שמירת המצב הנוכחי
            const state = {
                placedTiles: JSON.parse(JSON.stringify(placedTiles)),
                targetGridData: JSON.parse(JSON.stringify(targetGridData)),
                createdShapes: JSON.parse(JSON.stringify(createdShapes)),
                tilingMode: tilingMode,
                shapeCreationMode: shapeCreationMode
            };
            
            actionHistory.push(state);
            historyIndex++;
            
            // שמירה על מקסימום 50 פעולות
            if (actionHistory.length > 50) {
                actionHistory.shift();
                historyIndex--;
            }
            
            updateUndoRedoButtons();
        }

        // ביטול פעולה אחרונה
        function undo() {
            if (historyIndex <= 0) {
                showStatus('אין פעולות לביטול', 'error');
                return;
            }
            
            historyIndex--;
            const state = actionHistory[historyIndex];
            
            // שחזור המצב
            placedTiles = JSON.parse(JSON.stringify(state.placedTiles));
            targetGridData = JSON.parse(JSON.stringify(state.targetGridData));
            createdShapes = JSON.parse(JSON.stringify(state.createdShapes));
            
            // שחזור מצבי המערכת
            if (state.tilingMode !== undefined) tilingMode = state.tilingMode;
            if (state.shapeCreationMode !== undefined) shapeCreationMode = state.shapeCreationMode;
            
            // עדכון התצוגה
            updateGridDisplay();
            updateGridTitle();
            updateUndoRedoButtons();
            showStatus('פעולה בוטלה', 'info');
        }

        // חזרה על פעולה
        function redo() {
            if (historyIndex >= actionHistory.length - 1) {
                showStatus('אין פעולות לחזרה', 'error');
                return;
            }
            
            historyIndex++;
            const state = actionHistory[historyIndex];
            
            // שחזור המצב
            placedTiles = JSON.parse(JSON.stringify(state.placedTiles));
            targetGridData = JSON.parse(JSON.stringify(state.targetGridData));
            createdShapes = JSON.parse(JSON.stringify(state.createdShapes));
            
            // שחזור מצבי המערכת
            if (state.tilingMode !== undefined) tilingMode = state.tilingMode;
            if (state.shapeCreationMode !== undefined) shapeCreationMode = state.shapeCreationMode;
            
            // עדכון התצוגה
            updateGridDisplay();
            updateGridTitle();
            updateUndoRedoButtons();
            showStatus('פעולה שוחזרה', 'info');
        }

        // עדכון כפתורי ביטול וחזרה
        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            
            undoBtn.disabled = historyIndex <= 0;
            redoBtn.disabled = historyIndex >= actionHistory.length - 1;
        }

        // עדכון תצוגת הגריד עם מערכת שכבות
        function updateGridDisplay() {
            // עדכון targetGridData תחילה לפי השטחים הקיימים
            for (let i = 0; i < 30; i++) {
                for (let j = 0; j < 60; j++) {
                    targetGridData[i][j] = '#ffffff'; // איפוס לרקע לבן
                }
            }
            
            // עדכון targetGridData לפי השטחים הקיימים (לפי סדר יצירה)
            createdShapes.forEach(shape => {
                shape.cells.forEach(([row, col]) => {
                    targetGridData[row][col] = shape.color;
                });
            });
            
            // עכשיו עדכון התצוגה הויזואלית
            for (let i = 0; i < 30; i++) {
                for (let j = 0; j < 60; j++) {
                    const cellIndex = i * 60 + j;
                    const cell = document.getElementById('targetGrid').children[cellIndex];
                    
                    // איפוס כל הסטיילים
                    cell.style.backgroundColor = targetGridData[i][j];
                    cell.style.border = '1px solid #e5e7eb';
                    cell.style.borderTop = '';
                    cell.style.borderRight = '';
                    cell.style.borderBottom = '';
                    cell.style.borderLeft = '';
                    cell.style.boxShadow = 'none';
                    cell.style.cursor = 'pointer';
                    cell.style.transform = '';
                    cell.style.transition = '';
                    cell.style.animation = '';
                    cell.style.zIndex = '';
                    cell.style.opacity = '1';
                    
                    // בורדר מיוחד במצב יצירת שטח
                    if (shapeCreationMode && targetGridData[i][j] !== '#ffffff') {
                        cell.style.border = '2px solid #374151';
                    }
                }
            }
            
            // עדכון אריחים מונחים (תמיד בשכבה העליונה)
            placedTiles.forEach(tile => {
                tile.positions.forEach(([row, col]) => {
                    const cellIndex = row * 60 + col;
                    const cell = document.getElementById('targetGrid').children[cellIndex];
                    cell.style.backgroundColor = tile.color || '#7dd3fc';
                    
                    // קביעת הבורדר - צבע הבורדר של האריח לקווי המתאר החיצוניים, לבן לקווים הפנימיים
                    const isEdge = isEdgeOfTile(row, col, tile.positions);
                    const borderColor = tile.borderColor || '#1e40af';
                    
                    // בניית הבורדר המותאם אישית
                    cell.style.borderTop = isEdge.top ? `2px solid ${borderColor}` : '1px solid #ffffff';
                    cell.style.borderRight = isEdge.right ? `2px solid ${borderColor}` : '1px solid #ffffff';
                    cell.style.borderBottom = isEdge.bottom ? `2px solid ${borderColor}` : '1px solid #ffffff';
                    cell.style.borderLeft = isEdge.left ? `2px solid ${borderColor}` : '1px solid #ffffff';
                });
            });
            
            // הדגשה במצב הזזת אריחים
            if (tileMoveMode) {
                highlightMovableTiles();
            }
        }

        // הצגת הוראות שימוש
        function showInstructions() {
            document.getElementById('instructionsModal').classList.remove('hidden');
        }

        // הסתרת הוראות שימוש
        function hideInstructions() {
            document.getElementById('instructionsModal').classList.add('hidden');
        }

        // התחלת מצב ריצוף
        function startTiling() {
            if (currentTile.length === 0) {
                showStatus('עליך לעצב אריח תחילה!', 'error');
                return;
            }
            
            // בדיקה אם עדיין במצב יצירת שטח
            if (shapeCreationMode) {
                showStatus('יש לסיים תחילה את מצב יצירת שטחי הריצוף על ידי לחיצה על כפתור "סיים יצירת שטח"', 'error');
                return;
            }
            
            // שמירת המצב הנוכחי
            saveState();
            
            // סיום מצב יצירת שטח אוטומטית
            shapeCreationMode = false;
            isDragging = false;
            dragStartPos = null;
            draggedShape = null;
            removeMode = false;
            
            // הסרת הבורדר המיוחד מכל השטחים
            createdShapes.forEach(shape => {
                shape.cells.forEach(([row, col]) => {
                    const cellIndex = row * 60 + col;
                    const cell = document.getElementById('targetGrid').children[cellIndex];
                    cell.style.border = '1px solid #e5e7eb';
                });
            });
            
            tilingMode = true;
            updateGridTitle();
            showStatus('מצב ריצוף פעיל - השטח מקובע, לחץ על הגריד להנחת אריחים', 'success');
        }

        // ביטול מצב ריצוף
        function stopTiling() {
            tilingMode = false;
            tileMoveMode = false;
            selectedTileForMove = null;
            clearTilePreview();
            updateGridTitle();
            showStatus('מצב ריצוף בוטל - חזרה למצב עיצוב', 'info');
        }

        // החלפת מצב הזזת אריחים
        function toggleTileMoveMode() {
            if (placedTiles.length === 0) {
                showStatus('אין אריחים להזזה - הנח אריחים תחילה', 'error');
                return;
            }
            
            tileMoveMode = !tileMoveMode;
            selectedTileForMove = null;
            clearTilePreview();
            clearTileDragPreview();
            
            // הסתרת כפתורי עריכת האריח עם אנימציה
            const deleteBtn = document.getElementById('deleteTileBtn');
            const rotateBtn = document.getElementById('rotateTileBtn');
            const flipBtn = document.getElementById('flipTileBtn');
            
            // אנימציה חלקה להסתרת הכפתורים
            [deleteBtn, rotateBtn, flipBtn].forEach((btn, index) => {
                btn.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
                btn.style.opacity = '0';
                btn.style.transform = 'translateY(-10px)';
                
                setTimeout(() => {
                    btn.style.display = 'none';
                }, 300);
            });
            
            if (tileMoveMode) {
                tilingMode = false; // כיבוי מצב ריצוף רגיל
                updateGridTitle();
                
                // אנימציה חלקה להדגשת אריחים
                setTimeout(() => {
                    showStatus('🔄 מצב הזזת אריחים פעיל - לחץ על אריח להזזה', 'success');
                    highlightMovableTiles();
                }, 100);
                
                // אפקט קול עדין להפעלת המצב
                if (typeof Audio !== 'undefined') {
                    try {
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        
                        oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(800, audioContext.currentTime + 0.15);
                        
                        gainNode.gain.setValueAtTime(0.08, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                        
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.15);
                    } catch (e) {
                        // אם אין תמיכה ב-Audio API, פשוט נמשיך
                    }
                }
            } else {
                updateGridTitle();
                
                // אנימציה חלקה לכיבוי המצב
                setTimeout(() => {
                    showStatus('מצב הזזת אריחים בוטל', 'info');
                    updateGridDisplay();
                }, 100);
            }
        }

        // הדגשת אריחים הניתנים להזזה
        function highlightMovableTiles() {
            placedTiles.forEach((tile, tileIndex) => {
                tile.positions.forEach(([row, col], posIndex) => {
                    const cellIndex = row * 60 + col;
                    const cell = document.getElementById('targetGrid').children[cellIndex];
                    
                    // אנימציה מדורגת לכל אריח
                    setTimeout(() => {
                        cell.style.boxShadow = '0 0 0 3px #fbbf24 inset, 0 0 8px rgba(251, 191, 36, 0.4)';
                        cell.style.cursor = 'pointer';
                        cell.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
                        cell.style.borderRadius = '2px';
                        cell.style.zIndex = '5';
                        
                        // אנימציה עדינה של הבהוב
                        setTimeout(() => {
                            cell.style.animation = 'pulse 3s infinite ease-in-out';
                        }, 100);
                    }, (tileIndex * 100) + (posIndex * 20));
                });
            });
        }

        // מציאת אריח לפי מיקום תא
        function findTileByPosition(row, col) {
            for (let i = 0; i < placedTiles.length; i++) {
                const tile = placedTiles[i];
                if (tile.positions.some(([tRow, tCol]) => tRow === row && tCol === col)) {
                    return { tile, index: i };
                }
            }
            return null;
        }

        // בחירת אריח להזזה
        function selectTileForMove(row, col) {
            const tileData = findTileByPosition(row, col);
            if (!tileData) return false;
            
            selectedTileForMove = tileData;
            
            // הצגת כפתורי עריכת האריח עם אנימציה
            const deleteBtn = document.getElementById('deleteTileBtn');
            const rotateBtn = document.getElementById('rotateTileBtn');
            const flipBtn = document.getElementById('flipTileBtn');
            
            // אנימציה חלקה להצגת הכפתורים
            [deleteBtn, rotateBtn, flipBtn].forEach((btn, index) => {
                btn.style.display = 'inline-block';
                btn.style.opacity = '0';
                btn.style.transform = 'translateY(-10px)';
                btn.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
                
                setTimeout(() => {
                    btn.style.opacity = '1';
                    btn.style.transform = 'translateY(0)';
                }, index * 100);
            });
            
            // הדגשת האריח הנבחר עם אנימציה משופרת
            updateGridDisplay();
            tileData.tile.positions.forEach(([tRow, tCol], index) => {
                const cellIndex = tRow * 60 + tCol;
                const cell = document.getElementById('targetGrid').children[cellIndex];
                
                // אנימציה מדורגת לכל תא
                setTimeout(() => {
                    cell.style.boxShadow = '0 0 0 4px #ef4444 inset, 0 0 15px rgba(239, 68, 68, 0.6), 0 0 30px rgba(239, 68, 68, 0.3)';
                    cell.style.cursor = 'grab';
                    cell.style.transform = 'scale(1.08)';
                    cell.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
                    cell.style.zIndex = '15';
                    cell.style.borderRadius = '3px';
                    
                    // אנימציה פועמת משופרת
                    cell.style.animation = 'pulse 2s infinite ease-in-out';
                }, index * 30); // עיכוב מדורג לכל תא
            });
            
            // הודעה מותאמת למכשיר עם אפקט
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const message = isMobile ? 
                '🔄 אריח נבחר - גרור להזזה או השתמש בכפתורים לסיבוב/היפוך/מחיקה' :
                '🔄 אריח נבחר - גרור להזזה, R לסיבוב, F להיפוך, Delete למחיקה';
            
            showStatus(message, 'info');
            
            // הוספת אפקט קול ויזואלי (אם אפשר)
            if (typeof Audio !== 'undefined') {
                try {
                    // יצירת צליל עדין לבחירה
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(1200, audioContext.currentTime + 0.1);
                    
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.1);
                } catch (e) {
                    // אם אין תמיכה ב-Audio API, פשוט נמשיך
                }
            }
            
            return true;
        }

        // הזזת אריח למיקום חדש עם גרירה
        function moveTileToPosition(targetRow, targetCol) {
            if (!selectedTileForMove) return false;
            
            const { tile, index } = selectedTileForMove;
            
            // חישוב ההפרש בין המיקום הנוכחי למיקום החדש
            const currentBounds = getTileBounds(tile.positions.map(([r, c]) => [r, c]));
            const deltaRow = targetRow - currentBounds.minRow;
            const deltaCol = targetCol - currentBounds.minCol;
            
            // חישוב המיקומים החדשים
            const newPositions = tile.positions.map(([row, col]) => [
                row + deltaRow,
                col + deltaCol
            ]);
            
            // בדיקה שהמיקום החדש תקין
            const isValidMove = newPositions.every(([row, col]) => {
                // בדיקת גבולות
                if (row < 0 || row >= 30 || col < 0 || col >= 60) return false;
                
                // בדיקה שהמיקום הוא חלק מהשטח המיועד
                if (targetGridData[row][col] === '#ffffff') return false;
                
                // בדיקה שאין אריח אחר במיקום (למעט האריח הנוכחי)
                const otherTileAtPosition = placedTiles.find((otherTile, otherIndex) => 
                    otherIndex !== index && 
                    otherTile.positions.some(([oRow, oCol]) => oRow === row && oCol === col)
                );
                
                return !otherTileAtPosition;
            });
            
            if (!isValidMove) {
                showTileDragPreview(targetRow, targetCol, false); // תצוגה מקדימה אדומה
                return false;
            }
            
            // שמירת המצב לפני השינוי
            saveState();
            
            // עדכון מיקום האריח
            tile.positions = newPositions;
            
            // אנימציה חלקה להזזה
            newPositions.forEach(([row, col], index) => {
                if (row >= 0 && row < 30 && col >= 0 && col < 60) {
                    const cellIndex = row * 60 + col;
                    const cell = document.getElementById('targetGrid').children[cellIndex];
                    
                    // אנימציה חלקה להנחה
                    setTimeout(() => {
                        cell.style.animation = 'smoothMove 0.4s cubic-bezier(0.4, 0, 0.2, 1)';
                        cell.style.transform = 'scale(1)';
                        cell.style.opacity = '1';
                    }, index * 50);
                }
            });
            
            // עדכון התצוגה עם עיכוב לאנימציה
            setTimeout(() => {
                updateGridDisplay();
                clearTileDragPreview();
                
                // איפוס הבחירה
                selectedTileForMove = null;
                
                // הסתרת כפתורי העריכה עם אנימציה
                const deleteBtn = document.getElementById('deleteTileBtn');
                const rotateBtn = document.getElementById('rotateTileBtn');
                const flipBtn = document.getElementById('flipTileBtn');
                
                [deleteBtn, rotateBtn, flipBtn].forEach((btn, index) => {
                    setTimeout(() => {
                        btn.style.opacity = '0';
                        btn.style.transform = 'translateY(-10px)';
                        setTimeout(() => {
                            btn.style.display = 'none';
                        }, 300);
                    }, index * 50);
                });
                
                showStatus('האריח הוזז בהצלחה! 🎉', 'success');
                
                // בדיקת השלמת ריצוף
                checkTilingComplete();
            }, newPositions.length * 50 + 200);
            
            return true;
        }

        // הזזה אוטומטית במובייל - ללא צורך בלחיצה נוספת
        function moveTileToPositionAuto(targetRow, targetCol) {
            if (!selectedTileForMove) return false;
            
            const { tile, index } = selectedTileForMove;
            
            // חישוב ההפרש בין המיקום הנוכחי למיקום החדש
            const currentBounds = getTileBounds(tile.positions.map(([r, c]) => [r, c]));
            const deltaRow = targetRow - currentBounds.minRow;
            const deltaCol = targetCol - currentBounds.minCol;
            
            // חישוב המיקומים החדשים
            const newPositions = tile.positions.map(([row, col]) => [
                row + deltaRow,
                col + deltaCol
            ]);
            
            // בדיקה שהמיקום החדש תקין
            const isValidMove = newPositions.every(([row, col]) => {
                // בדיקת גבולות
                if (row < 0 || row >= 30 || col < 0 || col >= 60) return false;
                
                // בדיקה שהמיקום הוא חלק מהשטח המיועד
                if (targetGridData[row][col] === '#ffffff') return false;
                
                // בדיקה שאין אריח אחר במיקום (למעט האריח הנוכחי)
                const otherTileAtPosition = placedTiles.find((otherTile, otherIndex) => 
                    otherIndex !== index && 
                    otherTile.positions.some(([oRow, oCol]) => oRow === row && oCol === col)
                );
                
                return !otherTileAtPosition;
            });
            
            if (!isValidMove) {
                // רק הצגת תצוגה מקדימה אדומה, ללא הזזה
                showSmoothTileDragPreview(targetRow, targetCol);
                return false;
            }
            
            // עדכון מיקום האריח מיידית ללא שמירת מצב (יישמר בסוף הגרירה)
            tile.positions = newPositions;
            
            // עדכון התצוגה מיידית
            updateGridDisplay();
            
            return true;
        }

        // תצוגה מקדימה חלקה ומדויקת בזמן גרירת אריח
        function showSmoothTileDragPreview(targetRow, targetCol) {
            if (!selectedTileForMove) return;
            
            clearTileDragPreview();
            
            const { tile, index } = selectedTileForMove;
            const currentBounds = getTileBounds(tile.positions.map(([r, c]) => [r, c]));
            const deltaRow = targetRow - currentBounds.minRow;
            const deltaCol = targetCol - currentBounds.minCol;
            
            const newPositions = tile.positions.map(([row, col]) => [
                row + deltaRow,
                col + deltaCol
            ]);
            
            // בדיקת תקינות המיקום החדש
            const isValidMove = newPositions.every(([row, col]) => {
                if (row < 0 || row >= 30 || col < 0 || col >= 60) return false;
                if (targetGridData[row][col] === '#ffffff') return false;
                
                const otherTileAtPosition = placedTiles.find((otherTile, otherIndex) => 
                    otherIndex !== index && 
                    otherTile.positions.some(([oRow, oCol]) => oRow === row && oCol === col)
                );
                
                return !otherTileAtPosition;
            });
            
            // הצגת התצוגה המקדימה עם אנימציות משופרות
            newPositions.forEach(([row, col]) => {
                if (row >= 0 && row < 30 && col >= 0 && col < 60) {
                    const cellIndex = row * 60 + col;
                    const cell = document.getElementById('targetGrid').children[cellIndex];
                    
                    if (isValidMove) {
                        // ירוק בהיר עם אנימציה חלקה - מיקום תקין
                        cell.style.backgroundColor = '#bbf7d0';
                        cell.style.border = '3px solid #16a34a';
                        cell.style.opacity = '0.85';
                        cell.style.transform = 'scale(1.05)';
                        cell.style.transition = 'all 0.15s cubic-bezier(0.4, 0, 0.2, 1)';
                        cell.style.boxShadow = '0 4px 12px rgba(34, 197, 94, 0.3)';
                        cell.style.zIndex = '20';
                        cell.style.animation = 'none'; // ביטול אנימציה קודמת
                        
                        // אנימציה עדינה של פולס
                        setTimeout(() => {
                            cell.style.animation = 'pulse 2s infinite ease-in-out';
                        }, 50);
                    } else {
                        // אדום בהיר עם אנימציה חלקה - מיקום לא תקין
                        cell.style.backgroundColor = '#fecaca';
                        cell.style.border = '3px solid #dc2626';
                        cell.style.opacity = '0.8';
                        cell.style.transform = 'scale(0.95)';
                        cell.style.transition = 'all 0.15s cubic-bezier(0.4, 0, 0.2, 1)';
                        cell.style.boxShadow = '0 4px 12px rgba(239, 68, 68, 0.3)';
                        cell.style.zIndex = '20';
                        cell.style.animation = 'none';
                        
                        // אנימציה עדינה של רטט
                        setTimeout(() => {
                            cell.style.animation = 'shake 0.5s infinite ease-in-out';
                        }, 50);
                    }
                }
            });
            
            // עדכון הודעת הסטטוס עם אפקטים
            if (isValidMove) {
                showStatus('✅ מיקום תקין - שחרר להנחה', 'success');
            } else {
                showStatus('❌ מיקום לא תקין - בחר מיקום אחר', 'error');
            }
        }

        // תצוגה מקדימה בזמן גרירת אריח (גרסה ישנה - לתאימות)
        function showTileDragPreview(targetRow, targetCol, isValid = true) {
            showSmoothTileDragPreview(targetRow, targetCol);
        }

        // ניקוי תצוגה מקדימה של גרירת אריח
        function clearTileDragPreview() {
            document.querySelectorAll('#targetGrid .grid-cell').forEach(cell => {
                // ניקוי כל האפקטים של התצוגה המקדימה
                if (cell.style.backgroundColor === 'rgb(187, 247, 208)' || // ירוק בהיר
                    cell.style.backgroundColor === 'rgb(254, 202, 202)' || // אדום בהיר
                    cell.style.boxShadow.includes('#10b981') || 
                    cell.style.boxShadow.includes('#ef4444') ||
                    cell.style.boxShadow.includes('#16a34a') ||
                    cell.style.boxShadow.includes('#dc2626')) {
                    
                    // מעבר חלק לניקוי
                    cell.style.transition = 'all 0.2s cubic-bezier(0.4, 0, 0.2, 1)';
                    
                    // איפוס לערכי ברירת מחדל
                    setTimeout(() => {
                        cell.style.boxShadow = '';
                        cell.style.opacity = '1';
                        cell.style.transform = '';
                        cell.style.borderRadius = '';
                        cell.style.animation = '';
                        cell.style.zIndex = '';
                        
                        // שחזור הצבע המקורי
                        const row = Math.floor(Array.from(cell.parentNode.children).indexOf(cell) / 60);
                        const col = Array.from(cell.parentNode.children).indexOf(cell) % 60;
                        
                        // בדיקה אם יש אריח במיקום זה
                        const tileAtPosition = placedTiles.find(tile => 
                            tile.positions.some(([tRow, tCol]) => tRow === row && tCol === col)
                        );
                        
                        if (tileAtPosition) {
                            // שחזור צבע האריח
                            cell.style.backgroundColor = tileAtPosition.color;
                            const isEdge = isEdgeOfTile(row, col, tileAtPosition.positions);
                            const borderColor = tileAtPosition.borderColor;
                            
                            const borderParts = [];
                            borderParts.push(isEdge.top ? `2px solid ${borderColor}` : '1px solid #ffffff');
                            borderParts.push(isEdge.right ? `2px solid ${borderColor}` : '1px solid #ffffff');
                            borderParts.push(isEdge.bottom ? `2px solid ${borderColor}` : '1px solid #ffffff');
                            borderParts.push(isEdge.left ? `2px solid ${borderColor}` : '1px solid #ffffff');
                            
                            cell.style.borderTop = borderParts[0];
                            cell.style.borderRight = borderParts[1];
                            cell.style.borderBottom = borderParts[2];
                            cell.style.borderLeft = borderParts[3];
                        } else {
                            // שחזור צבע הרקע המקורי
                            cell.style.backgroundColor = targetGridData[row][col];
                            cell.style.border = '1px solid #e5e7eb';
                        }
                        
                        // ניקוי מעבר אחרי השלמת הניקוי
                        setTimeout(() => {
                            cell.style.transition = '';
                        }, 200);
                    }, 100);
                }
            });
        }

        // הצגת תצוגה מקדימה של האריח
        function showTilePreview(hoverRow, hoverCol) {
            clearTilePreview();
            
            // האריח יוצב כך שהתא הראשון שלו יהיה בדיוק במיקום הסמן
            previewPosition = [hoverRow, hoverCol];
            
            // מציאת התא הראשון באריח (הקרוב ביותר לפינה השמאלית העליונה)
            if (currentTile.length === 0) return;
            
            const minRow = Math.min(...currentTile.map(pos => pos[0]));
            const minCol = Math.min(...currentTile.map(pos => pos[1]));
            
            currentTile.forEach(([tileRow, tileCol]) => {
                const targetRow = hoverRow + (tileRow - minRow);
                const targetCol = hoverCol + (tileCol - minCol);
                
                if (targetRow >= 0 && targetRow < 30 && targetCol >= 0 && targetCol < 60) {
                    const cellIndex = targetRow * 60 + targetCol;
                    const cell = document.getElementById('targetGrid').children[cellIndex];
                    
                    const canPlace = canPlaceTileAt(hoverRow, hoverCol);
                    
                    if (canPlace) {
                        cell.style.border = '2px solid #10b981';
                        cell.style.opacity = '0.7';
                    } else {
                        cell.style.border = '2px solid #ef4444';
                        cell.style.opacity = '0.7';
                    }
                }
            });
        }

        // ניקוי תצוגה מקדימה
        function clearTilePreview() {
            document.querySelectorAll('#targetGrid .grid-cell').forEach(cell => {
                cell.style.border = '1px solid #e5e7eb';
                cell.style.opacity = '1';
            });
            previewPosition = null;
        }

        // בדיקה אם ניתן להניח אריח במיקום
        function canPlaceTileAt(clickRow, clickCol) {
            if (currentTile.length === 0) {
                console.log('canPlaceTileAt: no current tile');
                return false;
            }
            
            // מציאת התא הראשון באריח
            const minRow = Math.min(...currentTile.map(pos => pos[0]));
            const minCol = Math.min(...currentTile.map(pos => pos[1]));
            
            console.log('canPlaceTileAt: checking positions for tile at', clickRow, clickCol);
            
            const result = currentTile.every(([tileRow, tileCol]) => {
                const targetRow = clickRow + (tileRow - minRow);
                const targetCol = clickCol + (tileCol - minCol);
                
                console.log('Checking position:', targetRow, targetCol);
                
                if (targetRow < 0 || targetRow >= 30 || targetCol < 0 || targetCol >= 60) {
                    console.log('Position out of bounds');
                    return false;
                }
                
                // בדיקה שהמיקום הוא חלק מהשטח המיועד ולא תפוס
                const targetColor = targetGridData[targetRow][targetCol];
                const isOccupied = isCellOccupied(targetRow, targetCol);
                
                console.log('Target color:', targetColor, 'Is occupied:', isOccupied);
                
                const isValid = targetColor !== '#ffffff' && !isOccupied;
                if (!isValid) {
                    console.log('Position invalid - color:', targetColor, 'occupied:', isOccupied);
                }
                
                return isValid;
            });
            
            console.log('canPlaceTileAt result:', result);
            return result;
        }



        // בדיקה אם תא תפוס על ידי אריח אחר
        function isCellOccupied(row, col) {
            return placedTiles.some(tile => 
                tile.positions.some(pos => pos[0] === row && pos[1] === col)
            );
        }

        // בדיקה אם תא הוא קצה של האריח
        function isEdgeOfTile(row, col, tilePositions) {
            const isPartOfTile = (r, c) => tilePositions.some(([tr, tc]) => tr === r && tc === c);
            
            return {
                top: !isPartOfTile(row - 1, col),
                right: !isPartOfTile(row, col + 1),
                bottom: !isPartOfTile(row + 1, col),
                left: !isPartOfTile(row, col - 1)
            };
        }

        // מערך צבעי אריחים מגוונים
        const tileColors = [
            { bg: '#fef3c7', border: '#f59e0b' }, // צהוב זהב
            { bg: '#ddd6fe', border: '#8b5cf6' }, // סגול
            { bg: '#fce7f3', border: '#ec4899' }, // ורוד
            { bg: '#d1fae5', border: '#10b981' }, // ירוק
            { bg: '#fed7d7', border: '#ef4444' }, // אדום
            { bg: '#e0f2fe', border: '#0ea5e9' }, // תכלת
            { bg: '#fef2e2', border: '#f97316' }, // כתום
            { bg: '#f3e8ff', border: '#a855f7' }, // סגול בהיר
            { bg: '#ecfdf5', border: '#22c55e' }, // ירוק בהיר
            { bg: '#fdf2f8', border: '#f472b6' }  // ורוד בהיר
        ];

        // הנחת אריח במיקום
        function placeTileAt(clickRow, clickCol) {
            console.log('placeTileAt called:', clickRow, clickCol, 'tilingMode:', tilingMode, 'currentTile length:', currentTile.length);
            
            if (!tilingMode) {
                console.log('Not in tiling mode');
                return;
            }
            
            // בדיקה אם עדיין במצב יצירת שטח
            if (shapeCreationMode) {
                showStatus('יש לסיים תחילה את מצב יצירת שטחי הריצוף על ידי לחיצה על כפתור "סיים יצירת שטח"', 'error');
                return;
            }
            
            // הנחת אריח חדש
            if (currentTile.length === 0) {
                console.log('No current tile defined');
                showStatus('עליך לעצב אריח תחילה!', 'error');
                return;
            }
            
            // האריח יונח כך שהתא הראשון שלו יהיה בדיוק במיקום הלחיצה
            const canPlace = canPlaceTileAt(clickRow, clickCol);
            console.log('Can place tile:', canPlace);
            
            if (!canPlace) {
                showStatus('לא ניתן להניח אריח במיקום זה - ודא שהמיקום על שטח צבעוני ולא תפוס', 'error');
                return;
            }
            
            // שמירת המצב לפני השינוי
            saveState();
            
            // מציאת התא הראשון באריח
            const minRow = Math.min(...currentTile.map(pos => pos[0]));
            const minCol = Math.min(...currentTile.map(pos => pos[1]));
            
            const tilePositions = currentTile.map(([tileRow, tileCol]) => [
                clickRow + (tileRow - minRow),
                clickCol + (tileCol - minCol)
            ]);
            
            console.log('Tile positions:', tilePositions);
            
            // בחירת צבע אריח (מחזורי לפי מספר האריחים)
            const colorIndex = placedTiles.length % tileColors.length;
            const tileColor = tileColors[colorIndex];
            
            // הוספת האריח לרשימת האריחים המונחים
            placedTiles.push({
                positions: tilePositions,
                color: tileColor.bg,
                borderColor: tileColor.border
            });
            
            console.log('Tile placed successfully, total tiles:', placedTiles.length);
            
            clearTilePreview();
            showStatus(`אריח הונח! סה"כ ${placedTiles.length} אריחים`, 'success');
            
            // בדיקה אם הריצוף הושלם
            checkTilingComplete();
            updateGridDisplay();
        }

        // הסרת אריח אחרון
        function removeTile() {
            if (placedTiles.length === 0) {
                showStatus('אין אריחים להסרה', 'error');
                return;
            }
            
            const lastTile = placedTiles.pop();
            
            lastTile.positions.forEach(([row, col]) => {
                const cellIndex = row * 60 + col;
                const cell = document.getElementById('targetGrid').children[cellIndex];
                cell.style.backgroundColor = targetGridData[row][col];
                cell.style.border = '1px solid #e5e7eb';
            });
            
            showStatus(`אריח הוסר! נותרו ${placedTiles.length} אריחים`, 'info');
        }

        // ניקוי כל הריצוף
        function clearTiling() {
            if (placedTiles.length === 0) {
                showStatus('אין אריחים לניקוי', 'info');
                return;
            }
            
            // שמירת המצב לפני השינוי
            saveState();
            
            placedTiles = [];
            
            // איפוס מצב הזזת אריחים
            tileMoveMode = false;
            selectedTileForMove = null;
            
            // ניקוי מלא של כל האפקטים הויזואליים
            for (let i = 0; i < 30; i++) {
                for (let j = 0; j < 60; j++) {
                    const cellIndex = i * 60 + j;
                    const cell = document.getElementById('targetGrid').children[cellIndex];
                    
                    // איפוס מלא של כל הסטיילים
                    cell.style.backgroundColor = targetGridData[i][j];
                    cell.style.border = '1px solid #e5e7eb';
                    cell.style.borderTop = '';
                    cell.style.borderRight = '';
                    cell.style.borderBottom = '';
                    cell.style.borderLeft = '';
                    cell.style.boxShadow = 'none';
                    cell.style.cursor = 'pointer';
                    cell.style.transform = '';
                    cell.style.transition = '';
                    cell.style.animation = '';
                    cell.style.zIndex = '';
                    cell.style.opacity = '1';
                }
            }
            
            clearTilePreview();
            clearTileDragPreview();
            updateGridTitle();
            showStatus('כל האריחים הוסרו - שטח הריצוף נשמר', 'info');
        }

        // בדיקת השלמת ריצוף
        function checkTilingComplete() {
            const targetCells = [];
            for (let i = 0; i < 30; i++) {
                for (let j = 0; j < 60; j++) {
                    if (targetGridData[i][j] !== '#ffffff') {
                        targetCells.push([i, j]);
                    }
                }
            }
            
            const tiledCells = [];
            placedTiles.forEach(tile => {
                tile.positions.forEach(pos => tiledCells.push(pos));
            });
            
            const allCovered = targetCells.every(([row, col]) => 
                tiledCells.some(([tRow, tCol]) => tRow === row && tCol === col)
            );
            
            if (allCovered && targetCells.length > 0) {
                showStatus('🎉 מזל טוב! הריצוף הושלם בהצלחה!', 'complete');
            }
        }

        // הצגת הודעת סטטוס
        function showStatus(message, type) {
            const statusDiv = document.getElementById('tilingStatus');
            
            // אנימציה חלקה להודעה חדשה
            statusDiv.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
            statusDiv.style.opacity = '0';
            statusDiv.style.transform = 'translateY(-10px)';
            
            setTimeout(() => {
                statusDiv.textContent = message;
                
                const colors = {
                    success: 'bg-green-100 text-green-800 border border-green-200',
                    error: 'bg-red-100 text-red-800 border border-red-200',
                    info: 'bg-blue-100 text-blue-800 border border-blue-200',
                    complete: 'bg-purple-100 text-purple-800 border border-purple-200'
                };
                
                statusDiv.className = `mt-4 p-3 rounded-lg text-center text-sm font-medium shadow-sm ${colors[type] || colors.info}`;
                
                // אנימציה חלקה להצגה
                statusDiv.style.opacity = '1';
                statusDiv.style.transform = 'translateY(0)';
                
                // אנימציה עדינה לפולס
                if (type === 'success' || type === 'complete') {
                    setTimeout(() => {
                        statusDiv.style.animation = 'pulse 1s ease-in-out';
                    }, 200);
                }
                
                // אוטו-הסתרה להודעות רגילות
                if (type === 'info' && !message.includes('נבחר')) {
                    setTimeout(() => {
                        statusDiv.style.opacity = '0.7';
                    }, 3000);
                }
            }, 150);
        }

        // סיבוב אריח נבחר
        function rotateSelectedTile() {
            if (!selectedTileForMove) {
                showStatus('אין אריח נבחר לסיבוב', 'error');
                return;
            }
            
            // שמירת המצב לפני השינוי
            saveState();
            
            const { tile } = selectedTileForMove;
            
            // מציאת מרכז האריח
            const bounds = getTileBounds(tile.positions);
            const centerRow = (bounds.minRow + bounds.maxRow) / 2;
            const centerCol = (bounds.minCol + bounds.maxCol) / 2;
            
            // סיבוב כל תא באריח 90 מעלות סביב המרכז
            const rotatedPositions = tile.positions.map(([row, col]) => {
                const newRow = Math.round(centerRow + (col - centerCol));
                const newCol = Math.round(centerCol - (row - centerRow));
                return [newRow, newCol];
            });
            
            // בדיקה שהמיקום החדש תקין
            const isValidRotation = rotatedPositions.every(([row, col]) => {
                // בדיקת גבולות
                if (row < 0 || row >= 30 || col < 0 || col >= 60) return false;
                
                // בדיקה שהמיקום הוא חלק מהשטח המיועד
                if (targetGridData[row][col] === '#ffffff') return false;
                
                // בדיקה שאין אריח אחר במיקום (למעט האריח הנוכחי)
                const otherTileAtPosition = placedTiles.find((otherTile) => 
                    otherTile !== tile && 
                    otherTile.positions.some(([oRow, oCol]) => oRow === row && oCol === col)
                );
                
                return !otherTileAtPosition;
            });
            
            if (!isValidRotation) {
                showStatus('❌ לא ניתן לסובב את האריח במיקום הנוכחי', 'error');
                return;
            }
            
            // עדכון מיקום האריח
            tile.positions = rotatedPositions;
            
            // עדכון התצוגה
            updateGridDisplay();
            
            showStatus('🔄 האריח סובב בהצלחה!', 'success');
            
            // בדיקת השלמת ריצוף
            checkTilingComplete();
        }

        // היפוך אריח נבחר
        function flipSelectedTile() {
            if (!selectedTileForMove) {
                showStatus('אין אריח נבחר להיפוך', 'error');
                return;
            }
            
            // שמירת המצב לפני השינוי
            saveState();
            
            const { tile } = selectedTileForMove;
            
            // מציאת גבולות האריח
            const bounds = getTileBounds(tile.positions);
            const centerCol = (bounds.minCol + bounds.maxCol) / 2;
            
            // היפוך אופקי של כל תא באריח
            const flippedPositions = tile.positions.map(([row, col]) => {
                const newCol = Math.round(2 * centerCol - col);
                return [row, newCol];
            });
            
            // בדיקה שהמיקום החדש תקין
            const isValidFlip = flippedPositions.every(([row, col]) => {
                // בדיקת גבולות
                if (row < 0 || row >= 30 || col < 0 || col >= 60) return false;
                
                // בדיקה שהמיקום הוא חלק מהשטח המיועד
                if (targetGridData[row][col] === '#ffffff') return false;
                
                // בדיקה שאין אריח אחר במיקום (למעט האריח הנוכחי)
                const otherTileAtPosition = placedTiles.find((otherTile) => 
                    otherTile !== tile && 
                    otherTile.positions.some(([oRow, oCol]) => oRow === row && oCol === col)
                );
                
                return !otherTileAtPosition;
            });
            
            if (!isValidFlip) {
                showStatus('❌ לא ניתן להפוך את האריח במיקום הנוכחי', 'error');
                return;
            }
            
            // עדכון מיקום האריח
            tile.positions = flippedPositions;
            
            // עדכון התצוגה
            updateGridDisplay();
            
            showStatus('🔃 האריח הופך בהצלחה!', 'success');
            
            // בדיקת השלמת ריצוף
            checkTilingComplete();
        }

        // מחיקת אריח נבחר
        function deleteSelectedTile() {
            if (!selectedTileForMove) {
                showStatus('אין אריח נבחר למחיקה', 'error');
                return;
            }
            
            // שמירת המצב לפני השינוי
            saveState();
            
            const { index } = selectedTileForMove;
            const deletedTile = placedTiles[index];
            
            // הסרת האריח מהרשימה
            placedTiles.splice(index, 1);
            
            // איפוס הבחירה והסתרת כפתורי העריכה
            selectedTileForMove = null;
            const deleteBtn = document.getElementById('deleteTileBtn');
            const rotateBtn = document.getElementById('rotateTileBtn');
            const flipBtn = document.getElementById('flipTileBtn');
            deleteBtn.style.display = 'none';
            rotateBtn.style.display = 'none';
            flipBtn.style.display = 'none';
            
            // עדכון התצוגה
            updateGridDisplay();
            
            showStatus(`🗑️ אריח נמחק! נותרו ${placedTiles.length} אריחים`, 'success');
            
            // בדיקה אם עדיין במצב הזזת אריחים
            if (tileMoveMode && placedTiles.length === 0) {
                toggleTileMoveMode(); // יציאה ממצב הזזה אם אין אריחים
            } else if (tileMoveMode) {
                highlightMovableTiles(); // הדגשה מחדש של האריחים הנותרים
            }
        }

        // מאזין מקלדת לפעולות על אריח נבחר
        document.addEventListener('keydown', function(event) {
            // פעולות רק אם יש אריח נבחר ואנחנו במצב הזזת אריחים
            if (selectedTileForMove && tileMoveMode) {
                switch(event.key.toLowerCase()) {
                    case 'delete':
                    case 'backspace':
                        event.preventDefault();
                        deleteSelectedTile();
                        break;
                    case 'r':
                        event.preventDefault();
                        rotateSelectedTile();
                        break;
                    case 'f':
                        event.preventDefault();
                        flipSelectedTile();
                        break;
                }
            }
        });

        // אתחול היישומון
        initGrids();
        
        // שמירת המצב הראשוני
        saveState();
        
        showStatus('עצב את השטח והאריח שלך ולחץ "התחל ריצוף"', 'info');
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'980fab8057400bed',t:'MTc1ODE4NjIwNC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
