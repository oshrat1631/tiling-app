<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>×™×™×©×•××•×Ÿ ×¨×™×¦×•×£ ×¦×•×¨×•×ª</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --cell-size: 16px; /* base cell size; adjusted by zoom */
        }
        .grid-cell {
            width: var(--cell-size);
            height: var(--cell-size);
            border: 1px solid #e5e7eb;
            cursor: pointer;
            transition: all 0.1s;
        }
        .grid-cell:hover {
            border-color: #374151;
        }
        
        @keyframes pulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1.05);
            }
            50% {
                opacity: 0.8;
                transform: scale(1.02);
            }
        }
        .color-btn {
            width: 30px;
            height: 30px;
            border: 2px solid #374151;
            cursor: pointer;
            transition: all 0.2s;
        }
        .color-btn:hover {
            transform: scale(1.1);
        }
        .color-btn.selected {
            border-width: 3px;
            border-color: #000;
        }
        .tile-cell {
            width: var(--cell-size);
            height: var(--cell-size);
            border: 1px solid #d1d5db;
            cursor: pointer;
            transition: all 0.1s;
        }
        .tile-cell:hover {
            border-color: #374151;
        }
        .control-btn {
            background: #3b82f6;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        .control-btn:hover {
            background: #2563eb;
            transform: translateY(-1px);
        }
        .control-btn:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
        }
        
        /* ×¡×˜×™×™×œ×™× ×¨×¡×¤×•× ×¡×™×‘×™×™× ×œ××•×‘×™×™×œ */
        @media (max-width: 768px) {
            .max-w-7xl {
                max-width: 100%;
                padding: 0 5px;
            }
            
            .bg-white {
                margin: 0 2px 10px 2px;
                padding: 10px 8px;
            }
            
            .flex {
                flex-wrap: wrap;
                gap: 4px;
                justify-content: center;
            }
            
            .control-btn {
                padding: 4px 8px;
                font-size: 10px;
                min-width: auto;
                white-space: nowrap;
            }
            
            .color-btn {
                width: 20px;
                height: 20px;
            }
            
            input[type="number"] {
                width: 40px;
                padding: 2px;
                font-size: 10px;
            }
            
            .text-3xl {
                font-size: 1.2rem;
                margin-bottom: 10px;
            }
            
            :root {
                --cell-size: 8px; /* smaller default on tablets/phones */
            }
            .grid-cell, .tile-cell {
                border-width: 0.5px;
            }
            
            #targetGrid {
                max-height: 200px;
                overflow: auto;
                width: 100%;
                max-width: calc(100vw - 20px);
            }
            
            .flex-1 {
                width: 100%;
                margin-top: 10px;
            }
            
            .gap-6 {
                gap: 0;
                flex-direction: column;
            }
            
            /* ×”×ª×××” ××™×•×—×“×ª ×œ×’×¨×™×“ ×‘××•×‘×™×™×œ */
            #targetGrid .grid-cell {
                min-width: 4px;
                min-height: 4px;
            }
            
            /* ×”×ª×××ª ×›×¤×ª×•×¨×™× ×œ××•×‘×™×™×œ */
            .flex.items-center.gap-3 {
                gap: 2px;
                flex-wrap: wrap;
                justify-content: center;
            }
            
            .flex.items-center.gap-2 {
                gap: 1px;
                flex-wrap: wrap;
                justify-content: center;
            }
            
            .flex.gap-2 {
                gap: 2px;
                flex-wrap: wrap;
                justify-content: center;
            }
        }
        
        @media (max-width: 480px) {
            .max-w-7xl {
                padding: 0 2px;
            }
            
            :root {
                --cell-size: 6px; /* smallest default on narrow phones */
            }
            .grid-cell, .tile-cell {
                border-width: 0.5px;
            }
            
            .control-btn {
                padding: 3px 6px;
                font-size: 9px;
            }
            
            .color-btn {
                width: 18px;
                height: 18px;
            }
            
            #targetGrid {
                max-height: 150px;
                max-width: calc(100vw - 10px);
            }
            
            input[type="number"] {
                width: 35px;
                padding: 1px;
                font-size: 9px;
            }
        }
    </style>
</head>
<body class="bg-gray-50 p-6 font-sans">
    <div class="max-w-7xl mx-auto">
        <h1 class="text-3xl font-bold text-center mb-8 text-gray-800">×™×™×©×•××•×Ÿ ×¨×™×¦×•×£ ×¦×•×¨×•×ª ×××ª ×™× ×¨×•×Ÿ</h1>
        
        <!-- ×›×œ×™ ×‘×§×¨×” ×¢×œ×™×•× ×™× -->
        <div class="bg-white p-4 rounded-lg shadow-lg mb-6">
            <div class="flex flex-wrap items-center justify-center gap-6">
                <!-- ×¤×œ×˜×ª ×¦×‘×¢×™× -->
                <div class="flex items-center gap-3">
                    <span class="text-sm font-medium text-gray-700">×¦×‘×¢:</span>
                    <div class="flex gap-2">
                        <div class="color-btn selected" style="background-color: #fecaca" data-color="#fecaca"></div>
                        <div class="color-btn" style="background-color: #bfdbfe" data-color="#bfdbfe"></div>
                        <div class="color-btn" style="background-color: #bbf7d0" data-color="#bbf7d0"></div>
                        <div class="color-btn" style="background-color: #fde68a" data-color="#fde68a"></div>
                        <div class="color-btn" style="background-color: #ddd6fe" data-color="#ddd6fe"></div>
                        <div class="color-btn" style="background-color: #fbcfe8" data-color="#fbcfe8"></div>
                        <div class="color-btn" style="background-color: #ffffff; border-color: #374151" data-color="#ffffff"></div>
                    </div>
                </div>
                
                <!-- ×™×¦×™×¨×ª ×©×˜×— ××•×˜×•××˜×™ -->
                <div class="flex items-center gap-2">
                    <span class="text-sm font-medium text-gray-700">×™×¦×™×¨×ª ×©×˜×—:</span>
                    <input type="number" id="shapeWidth" value="10" min="1" max="30" class="w-16 px-2 py-1 border border-gray-300 rounded text-center">
                    <span class="text-xs text-gray-500">Ã—</span>
                    <input type="number" id="shapeHeight" value="10" min="1" max="30" class="w-16 px-2 py-1 border border-gray-300 rounded text-center">
                    <button class="control-btn bg-purple-600 hover:bg-purple-700" onclick="createAutoShape()">×¦×•×¨ ×©×˜×— ×¨×™×¦×•×£</button>
                    <button class="control-btn bg-orange-600 hover:bg-orange-700" onclick="finishShapeCreation()">×¡×™×™× ×™×¦×™×¨×ª ×©×˜×—</button>
                    <button class="control-btn bg-red-600 hover:bg-red-700" id="deleteShapeBtn" onclick="deleteSelectedShape()" style="display: none;">ğŸ—‘ï¸ ××—×§ ×©×˜×—</button>
                </div>
                
                <!-- ×›×¤×ª×•×¨×™ ×‘×§×¨×” -->
                <div class="flex gap-2">
                    <button class="control-btn" onclick="clearTarget()">× ×§×” ×©×˜×—</button>
                    <button class="control-btn" onclick="clearTile()">× ×§×” ××¨×™×—</button>
                    <button class="control-btn" onclick="rotateTile()">×¡×•×‘×‘ 90Â°</button>
                    <button class="control-btn" onclick="flipTile()">×”×¤×•×š</button>
                </div>
                
                <!-- ×›×¤×ª×•×¨×™ ×¨×™×¦×•×£ -->
                <div class="flex gap-2">
                    <button class="control-btn bg-green-600 hover:bg-green-700" onclick="startTiling()">×”×ª×—×œ ×¨×™×¦×•×£</button>
                    <button class="control-btn bg-red-600 hover:bg-red-700" onclick="stopTiling()">×‘×˜×œ ×¨×™×¦×•×£</button>
                    <button class="control-btn bg-yellow-600 hover:bg-yellow-700" onclick="toggleTileMoveMode()">ğŸ”„ ×”×–×–×ª ××¨×™×—×™×</button>
                    <button class="control-btn bg-red-500 hover:bg-red-600" onclick="deleteSelectedTile()" id="deleteTileBtn" style="display: none;">ğŸ—‘ï¸ ××—×§ ××¨×™×—</button>
                    <button class="control-btn bg-blue-500 hover:bg-blue-600" onclick="rotateSelectedTile()" id="rotateTileBtn" style="display: none;">ğŸ”„ ×¡×•×‘×‘ ××¨×™×—</button>
                    <button class="control-btn bg-green-500 hover:bg-green-600" onclick="flipSelectedTile()" id="flipTileBtn" style="display: none;">ğŸ”ƒ ×”×¤×•×š ××¨×™×—</button>
                    <button class="control-btn" onclick="clearTiling()">× ×§×” ×¨×™×¦×•×£</button>
                </div>
                
                <!-- ×›×¤×ª×•×¨×™ ×‘×™×˜×•×œ ×•×—×–×¨×” -->
                <div class="flex gap-2">
                    <button class="control-btn bg-gray-600 hover:bg-gray-700" onclick="undo()" id="undoBtn">â†¶ ×‘×™×˜×•×œ</button>
                    <button class="control-btn bg-gray-600 hover:bg-gray-700" onclick="redo()" id="redoBtn">â†· ×—×–×¨×”</button>
                    <button class="control-btn bg-indigo-600 hover:bg-indigo-700" onclick="showInstructions()">ğŸ“– ×”×•×¨××•×ª ×©×™××•×©</button>
                </div>
            </div>
            
            <!-- ×¡×˜×˜×•×¡ -->
            <div id="tilingStatus" class="mt-3 p-2 rounded text-center text-sm font-medium"></div>
        </div>
        
        <div class="flex gap-6">
            <!-- ×¢×™×¦×•×‘ ×”××¨×™×— -->
            <div class="bg-white p-4 rounded-lg shadow-lg">
                <h3 class="text-lg font-bold mb-3 text-gray-700 text-center">×¢×™×¦×•×‘ ×”××¨×™×—</h3>
                
                <!-- ×’×¨×™×“ ×¢×™×¦×•×‘ ×”××¨×™×— -->
                <div class="border-2 border-gray-300 p-2 bg-white inline-block mb-3">
                    <div id="tileGrid" class="grid gap-0" style="grid-template-columns: repeat(10, var(--cell-size));"></div>
                </div>
                
                <!-- ×ª×¦×•×’×ª ×›×œ ×ª×¦×•×¨×•×ª ×”××¨×™×— -->
                <div class="text-center">
                    <p class="text-sm text-gray-600 mb-2">×›×œ ×ª×¦×•×¨×•×ª ×”××¨×™×—:</p>
                    <div id="allTileVariations" class="flex flex-wrap gap-2 justify-center max-w-xs"></div>
                </div>
            </div>
            
            <!-- ×©×˜×— ×”×™×¢×“ -->
            <div class="bg-white p-4 rounded-lg shadow-lg flex-1">
                <h3 id="gridTitle" class="text-lg font-bold mb-3 text-gray-700 text-center">×©×˜×— ×”×¨×™×¦×•×£ (30Ã—60)</h3>
                
                <!-- ×’×¨×™×“ ×”×™×¢×“ -->
                <div class="border-2 border-gray-300 p-2 bg-white inline-block overflow-auto max-h-96">
                    <div id="targetGrid" class="grid gap-0" style="grid-template-columns: repeat(60, var(--cell-size));"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- ×—×œ×•×Ÿ ×”×•×¨××•×ª ×©×™××•×© -->
    <div id="instructionsModal" class="fixed inset-0 bg-black bg-opacity-50 z-50 hidden flex items-center justify-center p-4">
        <div class="bg-white rounded-lg max-w-4xl max-h-[90vh] overflow-y-auto p-6 relative">
            <button onclick="hideInstructions()" class="absolute top-4 left-4 text-gray-500 hover:text-gray-700 text-2xl font-bold">Ã—</button>
            
            <h2 class="text-2xl font-bold text-center mb-6 text-gray-800">ğŸ“– ×”×•×¨××•×ª ×©×™××•×© ×‘×™×™×©×•××•×Ÿ ×¨×™×¦×•×£ ×¦×•×¨×•×ª</h2>
            
            <div class="space-y-6 text-right">
                <div class="bg-blue-50 p-4 rounded-lg">
                    <h3 class="text-lg font-bold text-blue-800 mb-2">ğŸ¯ ××˜×¨×ª ×”×™×™×©×•××•×Ÿ</h3>
                    <p class="text-gray-700">×™×™×©×•××•×Ÿ ×–×” ×××¤×©×¨ ×œ×š ×œ×™×¦×•×¨ ×©×˜×—×™ ×¨×™×¦×•×£ ××•×ª×××™× ××™×©×™×ª ×•×œ×¨×¦×£ ××•×ª× ×‘×××¦×¢×•×ª ××¨×™×—×™× ×©×¢×™×¦×‘×ª ×‘×¢×¦××š.</p>
                </div>
                
                <div class="bg-green-50 p-4 rounded-lg">
                    <h3 class="text-lg font-bold text-green-800 mb-3">ğŸ—ï¸ ×©×œ×‘ 1: ×™×¦×™×¨×ª ×©×˜×— ×¨×™×¦×•×£</h3>
                    <ul class="space-y-2 text-gray-700">
                        <li><strong>×™×¦×™×¨×” ××•×˜×•××˜×™×ª:</strong> ×”×–×Ÿ ×¨×•×—×‘ ×•×’×•×‘×” (1-30) ×•×œ×—×¥ "×¦×•×¨ ×©×˜×— ×¨×™×¦×•×£" ×œ×™×¦×™×¨×ª ××œ×‘×Ÿ ×¦×‘×¢×•× ×™</li>
                        <li><strong>×™×¦×™×¨×” ×™×“× ×™×ª:</strong> ×‘×—×¨ ×¦×‘×¢ ×•×œ×—×¥ ×¢×œ ×ª××™× ×‘×’×¨×™×“ ×”×™×× ×™ ×œ×™×¦×™×¨×ª ×¦×•×¨×•×ª ×—×•×¤×©×™×•×ª (×¨×§ ×‘××¦×‘ ×™×¦×™×¨×ª ×©×˜×—)</li>
                        <li><strong>×’×¨×™×¨×”:</strong> × ×™×ª×Ÿ ×œ×’×¨×•×¨ ×©×˜×—×™× ×§×™×™××™× ×œ××™×§×•××™× ×—×“×©×™× ×¢×œ ×™×“×™ ×œ×—×™×¦×” ×•×’×¨×™×¨×” ×‘×ª×•×š ×”×©×˜×—</li>
                        <li><strong>×©×›×‘×•×ª:</strong> ×©×˜×—×™× ×™×›×•×œ×™× ×œ×—×¤×•×£ ×–×” ××ª ×–×” - ×”×©×˜×— ×”××—×¨×•×Ÿ ×©× ×•×¦×¨ ×™×”×™×” ×¢×œ×™×•×Ÿ</li>
                        <li><strong>×¦×‘×¢×™×:</strong> ×›×œ ×©×˜×— × ×•×¦×¨ ×‘×¦×‘×¢ ×©× ×‘×—×¨ ×‘×¤×œ×˜×ª ×”×¦×‘×¢×™×</li>
                        <li><strong>××—×™×§×ª ×©×˜×—:</strong> ×›×©×©×˜×— × ×‘×—×¨ ×‘××¦×‘ ×™×¦×™×¨×ª ×©×˜×— ×™×•×¤×™×¢ ×›×¤×ª×•×¨ "ğŸ—‘ï¸ ××—×§ ×©×˜×—" ×œ××—×™×§×ª×•</li>
                        <li><strong>×¦×™×•×¨ ×™×“× ×™ × ×©××¨:</strong> ×¨×™×‘×•×¢×™× ×‘×•×“×“×™× ×©×¦×™×™×¨×ª ×™×“× ×™×ª × ×©××¨×™× ×’× ×›×©××–×™×–×™× ××• ××•×—×§×™× ×©×˜×—×™× ××•×˜×•××˜×™×™×</li>
                        <li><strong>×—×©×•×‘:</strong> ×—×•×‘×” ×œ×œ×—×•×¥ "×¡×™×™× ×™×¦×™×¨×ª ×©×˜×—" ×œ×¤× ×™ ××¢×‘×¨ ×œ×¨×™×¦×•×£!</li>
                    </ul>
                </div>
                
                <div class="bg-purple-50 p-4 rounded-lg">
                    <h3 class="text-lg font-bold text-purple-800 mb-3">ğŸ§© ×©×œ×‘ 2: ×¢×™×¦×•×‘ ×”××¨×™×—</h3>
                    <ul class="space-y-2 text-gray-700">
                        <li><strong>×¢×™×¦×•×‘:</strong> ×œ×—×¥ ×¢×œ ×ª××™× ×‘×’×¨×™×“ ×”×©×××œ×™ (10Ã—10) ×œ×™×¦×™×¨×ª ×¦×•×¨×ª ×”××¨×™×— - ×ª××™× × ×‘×—×¨×™× ×™×”×™×• ××¤×•×¨×™×</li>
                        <li><strong>×¡×™×‘×•×‘:</strong> ×œ×—×¥ "×¡×•×‘×‘ 90Â°" ×œ×¡×™×‘×•×‘ ×”××¨×™×— ×‘×›×™×•×•×Ÿ ×”×©×¢×•×Ÿ</li>
                        <li><strong>×”×™×¤×•×š:</strong> ×œ×—×¥ "×”×¤×•×š" ×œ×”×™×¤×•×š ×”××¨×™×— ××•×¤×§×™×ª</li>
                        <li><strong>×ª×¦×•×’×”:</strong> ×›×œ ×ª×¦×•×¨×•×ª ×”××¨×™×— (×‘×¡×™×¡, ×¡×™×‘×•×‘×™×, ×”×™×¤×•×›×™×) ××•×¦×’×•×ª ×œ××˜×” ×¢× ×ª×•×•×™×•×ª</li>
                        <li><strong>×‘×—×™×¨×”:</strong> ×œ×—×¥ ×¢×œ ××—×ª ××”×ª×¦×•×¨×•×ª ×œ××˜×” ×œ×‘×—×™×¨×ª ×”××¨×™×— ×”×¤×¢×™×œ ×œ×¨×™×¦×•×£</li>
                        <li><strong>× ×™×§×•×™:</strong> ×œ×—×¥ "× ×§×” ××¨×™×—" ×œ××—×™×§×ª ×¢×™×¦×•×‘ ×”××¨×™×— ×”× ×•×›×—×™</li>
                    </ul>
                </div>
                
                <div class="bg-orange-50 p-4 rounded-lg">
                    <h3 class="text-lg font-bold text-orange-800 mb-3">ğŸ¨ ×©×œ×‘ 3: ×¨×™×¦×•×£ ×”×©×˜×—</h3>
                    <ul class="space-y-2 text-gray-700">
                        <li><strong>×”×ª×—×œ×”:</strong> ×œ×—×¥ "×”×ª×—×œ ×¨×™×¦×•×£" (×¨×§ ××—×¨×™ ×œ×—×™×¦×” ×¢×œ "×¡×™×™× ×™×¦×™×¨×ª ×©×˜×—"!)</li>
                        <li><strong>×ª×¦×•×’×” ××§×“×™××”:</strong> ×”×¢×‘×¨ ×¢×›×‘×¨ ×¢×œ ×”×’×¨×™×“ ×œ×¨××•×ª ××™×¤×” ×”××¨×™×— ×™×•× ×— - ×™×¨×•×§ = ×ª×§×™×Ÿ, ××“×•× = ×œ× ×ª×§×™×Ÿ</li>
                        <li><strong>×”× ×—×”:</strong> ×œ×—×¥ ×‘××™×§×•× ×”×¨×¦×•×™ ×œ×”× ×—×ª ×”××¨×™×— - ×”××¨×™×— ×™×§×‘×œ ×¦×‘×¢ ××•×˜×•××˜×™</li>
                        <li><strong>×”×–×–×”:</strong> ×œ×—×¥ "ğŸ”„ ×”×–×–×ª ××¨×™×—×™×", ×‘×—×¨ ××¨×™×— (×™×”×‘×”×‘ ×‘××“×•×) ×•×’×¨×•×¨/×œ×—×¥ ×œ××™×§×•× ×—×“×©. ×”×¡××Ÿ ××™×•×©×¨ ×œ××¨×›×– ×”××¨×™×—</li>
                        <li><strong>×¡×™×‘×•×‘:</strong> ×‘××¦×‘ ×”×–×–×ª ××¨×™×—×™×, ×‘×—×¨ ××¨×™×— ×•×œ×—×¥ "ğŸ”„ ×¡×•×‘×‘ ××¨×™×—" ××• ××§×© R</li>
                        <li><strong>×”×™×¤×•×š:</strong> ×‘××¦×‘ ×”×–×–×ª ××¨×™×—×™×, ×‘×—×¨ ××¨×™×— ×•×œ×—×¥ "ğŸ”ƒ ×”×¤×•×š ××¨×™×—" ××• ××§×© F</li>
                        <li><strong>××—×™×§×”:</strong> ×‘××¦×‘ ×”×–×–×ª ××¨×™×—×™×, ×‘×—×¨ ××¨×™×— ×•×œ×—×¥ "ğŸ—‘ï¸ ××—×§ ××¨×™×—" ××• Delete/Backspace</li>
                        <li><strong>× ×™×§×•×™:</strong> "× ×§×” ×¨×™×¦×•×£" ××¡×™×¨ ××ª ×›×œ ×”××¨×™×—×™× ××‘×œ ×©×•××¨ ×¢×œ ×”×©×˜×—×™×</li>
                        <li><strong>×‘×™×˜×•×œ ×¨×™×¦×•×£:</strong> "×‘×˜×œ ×¨×™×¦×•×£" ×—×•×–×¨ ×œ××¦×‘ ×¢×™×¦×•×‘ ×¨×’×™×œ</li>
                        <li><strong>×”×©×œ××”:</strong> ×›×©×›×œ ×”×©×˜×— ×”×¦×‘×¢×•× ×™ ××›×•×¡×” ×‘××¨×™×—×™× ×ª×§×‘×œ ×”×•×“×¢×ª ×”×¦×œ×—×”!</li>
                        <li><strong>×—×©×•×‘:</strong> ××¨×™×—×™× ××•× ×—×™× ×¨×§ ×¢×œ ×©×˜×—×™× ×¦×‘×¢×•× ×™×™× ×•×œ× ×™×›×•×œ×™× ×œ×—×¤×•×£</li>
                        <li><strong>××•×‘×™×™×œ/×“×¡×§×˜×•×¤:</strong> ×’×¨×™×¨×ª ×”××¨×™×— × ×¢×¦×¨×ª ×‘×©×—×¨×•×¨, ××™×Ÿ ×¦×•×¨×š ×‘×”×§×©×” × ×•×¡×¤×ª</li>
                    </ul>
                </div>
                
                <div class="bg-gray-50 p-4 rounded-lg">
                    <h3 class="text-lg font-bold text-gray-800 mb-3">âš™ï¸ ×›×œ×™× × ×•×¡×¤×™×</h3>
                    <ul class="space-y-2 text-gray-700">
                        <li><strong>×‘×™×˜×•×œ/×—×–×¨×”:</strong> ×›×¤×ª×•×¨×™ â†¶ ×•-â†· ×œ×‘×™×˜×•×œ ×•×—×–×¨×” ×¢×œ ×¤×¢×•×œ×•×ª (×¢×“ 50 ×¤×¢×•×œ×•×ª)</li>
                        <li><strong>× ×™×§×•×™ ×©×˜×—:</strong> "× ×§×” ×©×˜×—" ××•×—×§ ××ª ×›×œ ×”×©×˜×—×™× ×•×”××¨×™×—×™×</li>
                        <li><strong>× ×™×§×•×™ ××¨×™×—:</strong> "× ×§×” ××¨×™×—" ××•×—×§ ×¨×§ ××ª ×¢×™×¦×•×‘ ×”××¨×™×— ×‘×’×¨×™×“ ×”×©×××œ×™</li>
                        <li><strong>× ×™×§×•×™ ×¨×™×¦×•×£:</strong> "× ×§×” ×¨×™×¦×•×£" ××•×—×§ ×¨×§ ××ª ×”××¨×™×—×™× ×”××•× ×—×™×, ×©×•××¨ ×¢×œ ×”×©×˜×—×™×</li>
                        <li><strong>×¦×‘×¢×™×:</strong> 7 ×¦×‘×¢×™× ×–××™× ×™× ×œ×©×˜×—×™× - ×›×œ ×©×˜×— × ×•×¦×¨ ×‘×¦×‘×¢ ×”× ×‘×—×¨</li>
                        <li><strong>×¦×‘×¢×™ ××¨×™×—×™×:</strong> ××¨×™×—×™× ××§×‘×œ×™× ×¦×‘×¢×™× ××•×˜×•××˜×™×™× ××’×•×•× ×™× ×œ×¤×™ ×¡×“×¨ ×”×”× ×—×”</li>
                    </ul>
                </div>
                
                <div class="bg-red-50 p-4 rounded-lg">
                    <h3 class="text-lg font-bold text-red-800 mb-3">âš ï¸ ×”×¢×¨×•×ª ×—×©×•×‘×•×ª</h3>
                    <ul class="space-y-2 text-gray-700">
                        <li><strong>×¡×“×¨ ×¤×¢×•×œ×•×ª:</strong> ×™×¦×™×¨×ª ×©×˜×— â†’ ×¡×™×•× ×™×¦×™×¨×ª ×©×˜×— â†’ ×¢×™×¦×•×‘ ××¨×™×— â†’ ×”×ª×—×œ×ª ×¨×™×¦×•×£</li>
                        <li><strong>××’×‘×œ×•×ª ××™×§×•×:</strong> ××¨×™×—×™× ××•× ×—×™× ×¨×§ ×¢×œ ×©×˜×—×™× ×¦×‘×¢×•× ×™×™× (×œ× ×¢×œ ×¨×§×¢ ×œ×‘×Ÿ)</li>
                        <li><strong>××™-×—×¤×™×¤×”:</strong> ××¨×™×—×™× ×œ× ×™×›×•×œ×™× ×œ×—×¤×•×£ ×–×” ××ª ×–×” ××• ×œ×¦××ª ××’×‘×•×œ×•×ª ×”×’×¨×™×“</li>
                        <li><strong>×©××™×¨×ª × ×ª×•× ×™×:</strong> ×”×©×˜×—×™× × ×©××¨×™× ×’× ××—×¨×™ × ×™×§×•×™ ×”×¨×™×¦×•×£, ×•×¦×™×•×¨ ×™×“× ×™ × ×©××¨ ×’× ××—×¨×™ ×”×–×–×ª ×©×˜×—×™×</li>
                        <li><strong>××•×¤×Ÿ ×”× ×—×”:</strong> ××¨×™×—×™× ××•× ×—×™× ×‘×œ×—×™×¦×” ×¤×©×•×˜×” - ××™×Ÿ ×¦×•×¨×š ×‘×’×¨×™×¨×”</li>
                        <li><strong>×’×¨×™×¨×ª ×©×˜×—×™×:</strong> × ×™×ª×Ÿ ×œ×’×¨×•×¨ ×©×˜×—×™× ×¨×§ ×‘××¦×‘ ×™×¦×™×¨×ª ×©×˜×—</li>
                        <li><strong>×¢×¨×™×›×ª ××¨×™×—×™×:</strong> × ×™×ª×Ÿ ×œ×’×¨×•×¨, ×œ×¡×•×‘×‘ ×•×œ×”×¤×•×š ××¨×™×—×™× ×¨×§ ×‘××¦×‘ ×”×–×–×ª ××¨×™×—×™×</li>
                        <li><strong>××§×©×™ ×§×™×¦×•×¨:</strong> R ×œ×¡×™×‘×•×‘, F ×œ×”×™×¤×•×š, Delete/Backspace ×œ××—×™×§×” (×¨×§ ×›×©××¨×™×— × ×‘×—×¨)</li>
                    </ul>
                </div>
            </div>
            
            <div class="text-center mt-6">
                <button onclick="hideInstructions()" class="control-btn bg-blue-600 hover:bg-blue-700">×”×‘× ×ª×™ - ×‘×•××• × ×ª×—×™×œ!</button>
            </div>
        </div>
    </div>

    <!-- ×©×•×¨×ª ×–×›×•×™×•×ª ×™×•×¦×¨×™× -->
    <div class="text-center mt-6 py-2 text-xs text-gray-400 border-t border-gray-200">
        ×›×œ ×”×–×›×•×™×•×ª ×©××•×¨×•×ª ×œ××•×©×¨×ª ×•×™× ×¨×•×Ÿ
    </div>

    <script>
        let selectedColor = '#fecaca';
        let targetGridData = [];
        let tileGridData = [];
        let currentTile = [];
        let tilingMode = false;
        let placedTiles = [];
        let previewPosition = null;
        let shapeCreationMode = false;
        let isDragging = false;
        let dragStartPos = null;
        let createdShapes = [];
        // ×©×›×‘×ª ×¦×™×•×¨ ×™×“× ×™ ×©×ª×™×©××¨ ×’× ×›×©××–×™×–×™× ×©×˜×—×™× ××•×˜×•××˜×™×™×
        let manualPaintLayer = [];
        let draggedShape = null;
        let selectedShape = null; // ×‘×—×™×¨×ª ×©×˜×— ××•×˜×•××˜×™ ×œ×¢×¨×™×›×”/××—×™×§×”
        let removeMode = false;
        let actionHistory = [];
        let historyIndex = -1;
        let tileMoveMode = false;
        let selectedTileForMove = null;
        let draggedTile = null;

        // Organized toolbar injection and mode helpers
        function buildOrganizedToolbar() {
            try {
                const app = document.querySelector('.max-w-7xl.mx-auto');
                if (!app) return;
                const oldToolbar = app.querySelector('.bg-white.p-4.rounded-lg.shadow-lg.mb-6');
                const c = document.createElement('div');
                c.innerHTML = '<div class="bg-white p-4 rounded-lg shadow-lg mb-6" id="organizedToolbar">\
<div class="flex flex-col gap-3">\
  <div class="flex flex-wrap items-center gap-3 justify-between">\
    <div class="flex items-center gap-2">\
      <span class="text-sm font-medium text-gray-700">×”×™×¡×˜×•×¨×™×”</span>\
      <button class="control-btn bg-gray-600 hover:bg-gray-700" onclick="undo()" id="undoBtn">â†¶ ×‘×™×˜×•×œ</button>\
      <button class="control-btn bg-gray-600 hover:bg-gray-700" onclick="redo()" id="redoBtn">â†· ×—×–×¨×”</button>\
    </div>\
    <div class="flex items-center gap-2">\
      <span class="text-sm font-medium text-gray-700">××¦×‘</span>\
      <div class="inline-flex gap-1" role="tablist">\
        <button id="mode-target" class="px-3 py-1 text-sm rounded border border-gray-300 bg-white hover:bg-gray-50" onclick="setMode(\'target\')">×¦×™×•×¨ ×™×¢×“</button>\
        <button id="mode-tile" class="px-3 py-1 text-sm rounded border border-gray-300 bg-white hover:bg-gray-50" onclick="setMode(\'tile\')">×¢×™×¦×•×‘ ××¨×™×—</button>\
        <button id="mode-tiling" class="px-3 py-1 text-sm rounded border border-gray-300 bg-white hover:bg-gray-50" onclick="setMode(\'tiling\')">×¨×™×¦×•×£</button>\
        <button id="mode-move" class="px-3 py-1 text-sm rounded border border-gray-300 bg-white hover:bg-gray-50" onclick="setMode(\'tiling\'); toggleTileMoveMode();">×”×–×–×ª ××¨×™×—×™×</button>\
      </div>\
    </div>\
    <div class="flex items-center gap-2">\
      <span class="text-sm font-medium text-gray-700">×¤×¢×•×œ×•×ª</span>\
      <button class="control-btn bg-green-600 hover:bg-green-700" onclick="startTiling()">×”×ª×—×œ ×¨×™×¦×•×£</button>\
      <button class="control-btn bg-red-600 hover:bg-red-700" onclick="stopTiling()">×‘×˜×œ ×¨×™×¦×•×£</button>\
      <button class="control-btn bg-slate-600 hover:bg-slate-700" onclick="clearTiling()">× ×§×” ×¨×™×¦×•×£</button>\
    </div>\
    <div class="flex items-center gap-2">\
      <span class="text-sm font-medium text-gray-700">×ª×¦×•×’×”</span>\
      <button id="zoomOutBtn" class="control-btn bg-gray-500 hover:bg-gray-600" title="Zoom Out">-</button>\
      <input id="zoomSlider" type="range" min="0.5" max="3" step="0.1" value="1" class="w-40 align-middle" />\
      <button id="zoomInBtn" class="control-btn bg-gray-500 hover:bg-gray-600" title="Zoom In">+</button>\
      <span id="zoomValue" class="text-sm text-gray-600">100%</span>\
    </div>\
    <div class="flex items-center gap-2">\
      <span class="text-sm font-medium text-gray-700">×¢×–×¨×”</span>\
      <button class="control-btn bg-indigo-600 hover:bg-indigo-700" onclick="showInstructions()">ğŸ“– ×”×•×¨××•×ª ×©×™××•×©</button>\
    </div>\
  </div>\
  <div id="moveBanner" class="hidden bg-yellow-50 border border-yellow-200 rounded p-2 text-sm text-yellow-900 flex items-center gap-2">\
    <span>ğŸ”„ ××¦×‘ ×”×–×–×ª ××¨×™×—×™× ×¤×¢×™×œ</span>\
    <span class="mx-1 text-yellow-700">â€¢</span>\
    <span>×‘×—×¨/×™ ××¨×™×— ×•××– ×”×©×ª××©/×™ ×‘×¤×¢×•×œ×•×ª. ×§×™×¦×•×¨×™×: R, F, Delete</span>\
  </div>\
  <div class="grid grid-cols-1 md:grid-cols-3 gap-3">\
    <section id="panel-target" class="md:col-span-2 bg-white border border-gray-200 rounded-lg p-3 shadow">\
      <div class="flex items-center justify-between mb-2">\
        <h2 class="text-sm font-medium text-gray-700">×¦×™×•×¨ ×™×¢×“</h2>\
        <div class="flex items-center gap-2">\
          <button class="px-2 py-1 rounded bg-gray-100 text-gray-700 text-xs border" onclick="clearTarget()">× ×§×” ×™×¢×“</button>\
        </div>\
      </div>\
      <div class="flex flex-wrap items-center gap-3">\
        <div class="flex items-center gap-2">\
          <span class="text-sm">×¦×‘×¢:</span>\
          <div class="flex gap-2">\
            <div class="color-btn selected" style="background-color: #fecaca" data-color="#fecaca"></div>\
            <div class="color-btn" style="background-color: #bfdbfe" data-color="#bfdbfe"></div>\
            <div class="color-btn" style="background-color: #bbf7d0" data-color="#bbf7d0"></div>\
            <div class="color-btn" style="background-color: #fde68a" data-color="#fde68a"></div>\
            <div class="color-btn" style="background-color: #ddd6fe" data-color="#ddd6fe"></div>\
            <div class="color-btn" style="background-color: #fbcfe8" data-color="#fbcfe8"></div>\
            <div class="color-btn" style="background-color: #ffffff; border-color: #374151" data-color="#ffffff"></div>\
          </div>\
        </div>\
        <div class="flex items-center gap-2">\
          <span class="text-sm">×’×•×“×œ ××–×•×¨:</span>\
          <input type="number" id="shapeWidth" value="10" min="1" max="30" class="w-16 px-2 py-1 border border-gray-300 rounded text-center">\
          <span class="text-xs text-gray-500">Ã—</span>\
          <input type="number" id="shapeHeight" value="10" min="1" max="30" class="w-16 px-2 py-1 border border-gray-300 rounded text-center">\
          <button class="control-btn bg-purple-600 hover:bg-purple-700" onclick="createAutoShape()">×¦×•×¨ ××–×•×¨ ××•×˜×•××˜×™</button>\
          <button class="control-btn bg-orange-600 hover:bg-orange-700" onclick="finishShapeCreation()">×¡×™×•× ×¦×™×•×¨</button>\
          <button class="control-btn bg-red-600 hover:bg-red-700" id="deleteShapeBtn" onclick="deleteSelectedShape()" style="display: none;">××—×§ ××–×•×¨</button>\
        </div>\
      </div>\
    </section>\
    <section id="panel-tile" class="bg-white border border-gray-200 rounded-lg p-3 shadow hidden">\
      <div class="flex items-center justify-between mb-2">\
        <h2 class="text-sm font-medium text-gray-700">×¢×™×¦×•×‘ ××¨×™×—</h2>\
        <div class="flex items-center gap-2">\
          <button class="px-2 py-1 rounded bg-gray-100 text-gray-700 text-xs border" onclick="clearTile()">× ×§×” ××¨×™×—</button>\
        </div>\
      </div>\
      <div class="flex flex-wrap items-center gap-2">\
        <button class="control-btn bg-blue-500 hover:bg-blue-600" onclick="rotateTile()">×¡×•×‘×‘ 90Â°</button>\
        <button class="control-btn bg-green-500 hover:bg-green-600" onclick="flipTile()">×”×™×¤×•×š</button>\
      </div>\
    </section>\
    <section id="panel-tiling" class="bg-white border border-gray-200 rounded-lg p-3 shadow hidden">\
      <div class="flex items-center justify-between mb-2">\
        <h2 class="text-sm font-medium text-gray-700">× ×™×”×•×œ ××¨×™×—×™×</h2>\
        <div class="flex items-center gap-2">\
          <button class="px-2 py-1 rounded bg-gray-100 text-gray-700 text-xs border" onclick="clearTiling()">× ×§×” ×¨×™×¦×•×£</button>\
        </div>\
      </div>\
      <div class="flex flex-wrap items-center gap-2 mb-2">\
        <button id="moveToggle" class="control-btn bg-yellow-600 hover:bg-yellow-700" onclick="toggleTileMoveMode()">×”×¤×¢×œ ×”×–×–×ª ××¨×™×—×™×</button>\
      </div>\
      <div class="flex flex-wrap items-center gap-2">\
        <button id="rotateTileBtn" class="control-btn bg-blue-500 hover:bg-blue-600" onclick="rotateSelectedTile()" style="display: none;">×¡×•×‘×‘ ××¨×™×—</button>\
        <button id="flipTileBtn" class="control-btn bg-green-500 hover:bg-green-600" onclick="flipSelectedTile()" style="display: none;">×”×™×¤×•×š ××¨×™×—</button>\
        <button id="deleteTileBtn" class="control-btn bg-red-500 hover:bg-red-600" onclick="deleteSelectedTile()" style="display: none;">××—×§ ××¨×™×—</button>\
      </div>\
      <p class="mt-2 text-sm text-gray-500">×‘××¦×‘ ×”×–×–×”: ×œ×—×¥ ×¢×œ ××¨×™×— ×›×“×™ ×œ×‘×—×•×¨ ××•×ª×•. ×œ××—×¨ ×”×‘×—×™×¨×” ×”×›×¤×ª×•×¨×™× ×™×•×¤×™×¢×•.</p>\
    </section>\
  </div>\
  <div id="tilingStatus" class="mt-1 p-2 rounded text-center text-sm font-medium"></div>\
</div>\
</div>';
                const newNode = c.firstElementChild;
                if (!newNode) return;
                if (oldToolbar) {
                    app.insertBefore(newNode, oldToolbar);
                    oldToolbar.style.display = 'none';
                } else {
                    app.prepend(newNode);
                }
            } catch (e) { console.warn('Failed to build organized toolbar', e); }
        }

        function setMode(name) {
            try {
                const modes = ['target','tile','tiling'];
                modes.forEach(m => {
                    const btn = document.getElementById('mode-' + m);
                    if (btn) {
                        btn.classList.toggle('bg-indigo-600', m === name);
                        btn.classList.toggle('text-white', m === name);
                        btn.classList.toggle('border-indigo-600', m === name);
                    }
                    const panel = document.getElementById('panel-' + m);
                    if (panel) panel.classList.toggle('hidden', m !== name);
                });
                if (name === 'target') {
                    if (typeof stopTiling === 'function') stopTiling();
                    shapeCreationMode = true;
                    updateGridTitle();
                } else if (name === 'tile') {
                    if (typeof stopTiling === 'function') stopTiling();
                    shapeCreationMode = false;
                    updateGridTitle();
                } else if (name === 'tiling') {
                    if (!tilingMode && typeof startTiling === 'function') startTiling();
                }
                updateMoveBanner();
            } catch (e) { console.warn('setMode failed', e); }
        }

        function updateMoveBanner() {
            try {
                const banner = document.getElementById('moveBanner');
                if (banner) banner.classList.toggle('hidden', !tileMoveMode);
                const toggle = document.getElementById('moveToggle');
                if (toggle) toggle.textContent = tileMoveMode ? '×›×‘×” ×”×–×–×ª ××¨×™×—×™×' : '×”×¤×¢×œ ×”×–×–×ª ××¨×™×—×™×';
            } catch (e) {}
        }

        // Build toolbar early so color buttons get listeners below
        buildOrganizedToolbar();
        // Initialize UI state
        setMode('target');
        updateMoveBanner();
        try { setInterval(updateMoveBanner, 500); } catch(e) {}

        // Zoom controls for grid and tiles
        let zoom = 1;
        const zoomMin = 0.5;
        const zoomMax = 3.0;
        const zoomStep = 0.1;
        let baseCellSize = null; // detected from CSS variable on load

        function initZoomControls() {
            const root = document.documentElement;
            const raw = getComputedStyle(root).getPropertyValue('--cell-size').trim();
            const numeric = parseFloat(raw || '16');
            baseCellSize = isNaN(numeric) ? 16 : numeric;

            // Ensure controls exist; if not, create them in the top toolbar
            let slider = document.getElementById('zoomSlider');
            let zoomOutBtn = document.getElementById('zoomOutBtn');
            let zoomInBtn = document.getElementById('zoomInBtn');
            let zoomValue = document.getElementById('zoomValue');

            if (!slider || !zoomOutBtn || !zoomInBtn || !zoomValue) {
                const toolbar = document.querySelector('.bg-white.p-4.rounded-lg.shadow-lg.mb-6 .flex.flex-wrap.items-center.justify-center.gap-6');
                if (toolbar) {
                    const wrap = document.createElement('div');
                    wrap.className = 'flex items-center gap-2';
                    wrap.innerHTML = `
                        <span class="text-sm font-medium text-gray-700">×–×•×:</span>
                        <button id="zoomOutBtn" class="control-btn" title="Zoom Out">-</button>
                        <input id="zoomSlider" type="range" min="0.5" max="3" step="0.1" value="1" class="w-40 align-middle" />
                        <button id="zoomInBtn" class="control-btn" title="Zoom In">+</button>
                        <span id="zoomValue" class="text-sm text-gray-600">100%</span>
                    `;
                    toolbar.appendChild(wrap);
                }
                // re-query after injection
                slider = document.getElementById('zoomSlider');
                zoomOutBtn = document.getElementById('zoomOutBtn');
                zoomInBtn = document.getElementById('zoomInBtn');
                zoomValue = document.getElementById('zoomValue');
            }

            function applyZoom() {
                const size = (baseCellSize * zoom).toFixed(2) + 'px';
                root.style.setProperty('--cell-size', size);
                if (slider) slider.value = String(zoom);
                if (zoomValue) zoomValue.textContent = Math.round(zoom * 100) + '%';
            }

            function setZoom(z) {
                zoom = Math.min(zoomMax, Math.max(zoomMin, z));
                applyZoom();
            }

            // expose setter for keyboard handler
            window.__setZoom = setZoom;

            // init UI with current zoom
            applyZoom();

            if (slider) slider.addEventListener('input', (e) => {
                const v = parseFloat(e.target.value);
                if (!isNaN(v)) setZoom(v);
            });
            if (zoomOutBtn) zoomOutBtn.addEventListener('click', () => {
                setZoom(Math.round((zoom - zoomStep) * 10) / 10);
            });
            if (zoomInBtn) zoomInBtn.addEventListener('click', () => {
                setZoom(Math.round((zoom + zoomStep) * 10) / 10);
            });

            const targetGridEl = document.getElementById('targetGrid');
            if (targetGridEl) {
                targetGridEl.addEventListener('wheel', (e) => {
                    if (e.ctrlKey || e.altKey) {
                        e.preventDefault();
                        const dir = e.deltaY > 0 ? -1 : 1;
                        setZoom(Math.round((zoom + dir * zoomStep) * 10) / 10);
                    }
                }, { passive: false });
            }
        }

        // keyboard +/- zoom (skip when typing in inputs)
        document.addEventListener('keydown', function(evt){
            const tag = (evt.target && evt.target.tagName || '').toLowerCase();
            if (tag === 'input' || tag === 'textarea' || evt.metaKey || evt.ctrlKey) return;
            if (evt.key === '+' || evt.key === '=') { evt.preventDefault(); if (window.__setZoom) window.__setZoom(zoom + zoomStep); }
            if (evt.key === '-' || evt.key === '_') { evt.preventDefault(); if (window.__setZoom) window.__setZoom(zoom - zoomStep); }
        });


        // ××ª×—×•×œ ×”×’×¨×™×“×™×
        function initGrids() {
            // ×’×¨×™×“ ×”×™×¢×“ 30x60
            const targetGrid = document.getElementById('targetGrid');
            targetGridData = Array(30).fill().map(() => Array(60).fill('#ffffff'));
            manualPaintLayer = Array(30).fill().map(() => Array(60).fill(null));
            
            for (let i = 0; i < 30; i++) {
                for (let j = 0; j < 60; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.style.backgroundColor = '#ffffff';
                    cell.onclick = () => paintTargetCell(i, j);
                    cell.onmousedown = (e) => handleMouseDown(i, j, e);
                    cell.ontouchstart = (e) => {
                        e.preventDefault();
                        handleMouseDown(i, j, e);
                    };
                    cell.onmouseenter = () => {
                        if (tilingMode && currentTile.length > 0) {
                            showTilePreview(i, j);
                        } else if (isDragging && shapeCreationMode) {
                            handleDrag(i, j);
                        } else if (tileMoveMode && selectedTileForMove) {
                            // ×ª×¦×•×’×” ××§×“×™××” ×—×œ×§×” ×‘×–××Ÿ ×’×¨×™×¨×ª ××¨×™×—
                            showSmoothTileDragPreview(i, j);
                        }
                    };
                    cell.onmouseleave = () => {
                        if (tilingMode) {
                            clearTilePreview();
                        }
                    };
                    
                    // ×××–×™× ×™ ××’×¢ ××©×•×¤×¨×™× ×œ×’×¨×™×¨×” ×—×œ×§×”
                    let cellTouchStartTime = 0;
                    let cellTouchMoved = false;
                    let cellTouchStartPos = null;
                    
                    cell.ontouchstart = (e) => {
                        e.preventDefault();
                        cellTouchStartTime = Date.now();
                        cellTouchMoved = false;
                        cellTouchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                        handleMouseDown(i, j, e);
                    };
                    
                    cell.ontouchmove = (e) => {
                        e.preventDefault();
                        const touch = e.touches[0];
                        
                        // ×‘×“×™×§×ª ××¨×—×§ ×’×¨×™×¨×”
                        if (cellTouchStartPos) {
                            const deltaX = Math.abs(touch.clientX - cellTouchStartPos.x);
                            const deltaY = Math.abs(touch.clientY - cellTouchStartPos.y);
                            if (deltaX > dragThreshold || deltaY > dragThreshold) {
                                cellTouchMoved = true;
                            }
                        }
                        
                        const element = document.elementFromPoint(touch.clientX, touch.clientY);
                        if (element && element.classList.contains('grid-cell')) {
                            const cellIndex = Array.from(element.parentNode.children).indexOf(element);
                            const touchRow = Math.floor(cellIndex / 60);
                            const touchCol = cellIndex % 60;
                            
                            if (tilingMode && currentTile.length > 0) {
                                showTilePreview(touchRow, touchCol);
                            } else if (isDragging && shapeCreationMode) {
                                handleDrag(touchRow, touchCol);
                            } else if (tileMoveMode && selectedTileForMove) {
                                // ×’×¨×™×¨×” ××•×˜×•××˜×™×ª ×©×œ ××¨×™×— ×‘××•×‘×™×™×œ
                                if (cellTouchMoved) {
                                    moveTileToPositionAuto(touchRow, touchCol);
                                } else {
                                    showSmoothTileDragPreview(touchRow, touchCol);
                                }
                            }
                        }
                    };
                    
                    cell.ontouchend = (e) => {
                        e.preventDefault();
                        const touchDuration = Date.now() - cellTouchStartTime;
                        
                        // ×× ×–×” ×”×™×” ×˜××¤ ×§×¦×¨ (×œ× ×’×¨×™×¨×”), ×‘×¦×¢ ××ª ×”×¤×¢×•×œ×” ×”××ª××™××”
                        if (!cellTouchMoved && touchDuration < 500) {
                            if (tilingMode) {
                                placeTileAt(i, j);
                            } else if (tileMoveMode) {
                                if (selectedTileForMove) {
                                    // ×‘××•×‘×™×™×œ - ×”×–×–×” ××•×˜×•××˜×™×ª ×œ×œ× ×¦×•×¨×š ×‘×œ×—×™×¦×” × ×•×¡×¤×ª
                                    moveTileToPositionAuto(i, j);
                                } else {
                                    selectTileForMove(i, j);
                                }
                            } else if (shapeCreationMode) {
                                paintTargetCell(i, j);
                            }
                        } else if (cellTouchMoved) {
                            // ×× ×”×™×ª×” ×’×¨×™×¨×”, ×”×¤×¢×•×œ×” ×›×‘×¨ ×‘×•×¦×¢×” ×‘××”×œ×š touchmove
                            if (tileMoveMode && selectedTileForMove) {
                                // ×©××™×¨×ª ×”××¦×‘ ×”×—×“×© ××—×¨×™ ×”×’×¨×™×¨×”
                                saveState();
                                
                                // ××™×¤×•×¡ ×”×‘×—×™×¨×” ××—×¨×™ ×”×–×–×” ××•×¦×œ×—×ª
                                selectedTileForMove = null;
                                const deleteBtn = document.getElementById('deleteTileBtn');
                                deleteBtn.style.display = 'none';
                                clearTileDragPreview();
                                showStatus('×”××¨×™×— ×”×•×–×– ×‘×”×¦×œ×—×”!', 'success');
                                checkTilingComplete();
                            } else if (shapeCreationMode && draggedShape) {
                                // ×©××™×¨×ª ××¦×‘ ××—×¨×™ ×’×¨×™×¨×ª ×©×˜×—
                                saveState();
                            }
                        }
                        
                        handleMouseUp();
                        clearTilePreview();
                        cellTouchStartPos = null;
                    };
                    targetGrid.appendChild(cell);
                }
            }
            
            // ×’×¨×™×“ ×¢×™×¦×•×‘ ×”××¨×™×— 10x10
            const tileGrid = document.getElementById('tileGrid');
            tileGridData = Array(10).fill().map(() => Array(10).fill(false));
            
            for (let i = 0; i < 10; i++) {
                for (let j = 0; j < 10; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'tile-cell';
                    cell.style.backgroundColor = '#ffffff';
                    cell.onclick = () => toggleTileCell(i, j);
                    
                    // ×”×•×¡×¤×ª ×ª××™×›×” ×‘××’×¢ ×œ×’×¨×™×“ ×”××¨×™×—
                    cell.ontouchstart = (e) => {
                        e.preventDefault();
                    };
                    
                    cell.ontouchend = (e) => {
                        e.preventDefault();
                        toggleTileCell(i, j);
                    };
                    
                    tileGrid.appendChild(cell);
                }
            }
            
            updateCurrentTile();
            
            // ×”×•×¡×¤×ª ×××–×™× ×™ ×¢×›×‘×¨ ×•××’×¢ ×’×œ×•×‘×œ×™×™×
            document.addEventListener('mouseup', handleMouseUp);
            document.addEventListener('touchend', handleMouseUp);
            document.addEventListener('touchcancel', handleMouseUp);
        }

        // ×‘×—×™×¨×ª ×¦×‘×¢ ×¢× ×ª××™×›×” ×‘××’×¢
        document.querySelectorAll('.color-btn').forEach(btn => {
            btn.onclick = () => {
                document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                selectedColor = btn.dataset.color;
            };
            
            // ×ª××™×›×” ×‘××’×¢
            btn.ontouchend = (e) => {
                e.preventDefault();
                document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                selectedColor = btn.dataset.color;
            };
        });

        // ×¤×•× ×§×¦×™×•×ª ×˜×™×¤×•×œ ×‘×¢×›×‘×¨ ×•××’×¢
        let touchStartTime = 0;
        let touchMoved = false;
        let lastTouchPos = null;
        let dragThreshold = 5; // ××™× ×™××•× ×¤×™×§×¡×œ×™× ×œ×–×™×”×•×™ ×’×¨×™×¨×”

        function handleMouseDown(row, col, e) {
            if (shapeCreationMode) {
                // ×‘×“×™×§×” ×× ×œ×•×—×¦×™× ×¢×œ ×©×˜×— ×§×™×™×
                const clickedShape = findShapeAtPosition(row, col);
                if (clickedShape) {
                    // ×ª××™×“ ×××¤×©×¨ ×’×¨×™×¨×” ×©×œ ×©×˜×— ×§×™×™×
                    isDragging = true;
                    draggedShape = clickedShape;
                    selectedShape = clickedShape;
                    const deleteShapeBtn = document.getElementById('deleteShapeBtn');
                    if (deleteShapeBtn) deleteShapeBtn.style.display = 'inline-block';
                    
                    // ×©××™×¨×ª ×”××™×§×•× ×”××“×•×™×§ ×©×œ ×”×œ×—×™×¦×” ×‘×ª×•×š ×”×©×˜×—
                    dragStartPos = [row, col];
                    
                    // ×”×–×–×ª ×”×©×˜×— ×œ×©×›×‘×” ×”×¢×œ×™×•× ×”
                    const shapeIndex = createdShapes.indexOf(clickedShape);
                    if (shapeIndex > -1) {
                        createdShapes.splice(shapeIndex, 1);
                        createdShapes.push(clickedShape);
                    }
                } else {
                    // ×™×¦×™×¨×ª ×©×˜×— ×—×“×© ×‘×’×¨×™×¨×”
                    isDragging = true;
                    dragStartPos = [row, col];
                    selectedShape = null;
                    const deleteShapeBtn = document.getElementById('deleteShapeBtn');
                    if (deleteShapeBtn) deleteShapeBtn.style.display = 'none';
                }
                
                // ×©××™×¨×ª × ×ª×•× ×™ ××’×¢
                if (e.touches && e.touches[0]) {
                    lastTouchPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    touchStartTime = Date.now();
                    touchMoved = false;
                }
                
                e.preventDefault();
            }
        }

        function handleMouseUp() {
            if (isDragging && draggedShape) {
                // ×¡×™×•× ×’×¨×™×¨×” - ×¢×“×›×•×Ÿ ×¡×•×¤×™ ×©×œ ×”××™×§×•×
                updateGridDisplay();
                saveState(); // ×©××™×¨×ª ×”××¦×‘ ×”×—×“×©
            }
            isDragging = false;
            dragStartPos = null;
            draggedShape = null;
            lastTouchPos = null;
            touchMoved = false;
            // ××—×¨×™ ×©×—×¨×•×¨, ×›×¤×ª×•×¨ ××—×™×§×ª ×©×˜×— × ×©××¨ ×× ×™×© ×‘×—×™×¨×”
            const deleteShapeBtn = document.getElementById('deleteShapeBtn');
            if (deleteShapeBtn) deleteShapeBtn.style.display = selectedShape ? 'inline-block' : 'none';
        }

        function handleDrag(row, col) {
            if (!isDragging || !dragStartPos) return;
            
            if (draggedShape) {
                // ×’×¨×™×¨×ª ×©×˜×— ×§×™×™× - ×”×©×˜×— ×™×–×•×– ×›×š ×©×”×ª× ×©×œ×—×¦× ×• ×¢×œ×™×• ×™×™×©××¨ ×ª×—×ª ×”×¡××Ÿ
                const deltaRow = row - dragStartPos[0];
                const deltaCol = col - dragStartPos[1];
                
                // ×—×™×©×•×‘ ×”××™×§×•× ×”×—×“×© ×©×œ ×›×œ ×ª× ×‘×©×˜×—
                const newCells = draggedShape.cells.map(([r, c]) => [r + deltaRow, c + deltaCol]);
                
                // ×‘×“×™×§×” ×©×›×œ ×”×ª××™× ×”×—×“×©×™× ×‘×ª×•×š ×”×’×‘×•×œ×•×ª
                const isValidMove = newCells.every(([r, c]) => 
                    r >= 0 && r < 30 && c >= 0 && c < 60
                );
                
                if (isValidMove) {
                    // ×¢×“×›×•×Ÿ ×”××™×§×•× ×”×—×“×© ××™×™×“×™×ª
                    draggedShape.cells = newCells;
                    
                    // ×¢×“×›×•×Ÿ ××™×™×“×™ ×©×œ ×”×ª×¦×•×’×” ×¢× ××¤×§×˜ ×•×™×–×•××œ×™ ×—×œ×§
                    updateGridDisplaySmooth();
                    
                    // ×¢×“×›×•×Ÿ dragStartPos ×œ××™×§×•× ×”× ×•×›×—×™ ×›×“×™ ×©×”×’×¨×™×¨×” ×ª×”×™×” ×—×œ×§×”
                    dragStartPos = [row, col];
                }
            } else {
                // ×™×¦×™×¨×ª ×©×˜×— ×—×“×©
                const startRow = Math.min(dragStartPos[0], row);
                const endRow = Math.max(dragStartPos[0], row);
                const startCol = Math.min(dragStartPos[1], col);
                const endCol = Math.max(dragStartPos[1], col);
                
                // ×¦×‘×™×¢×ª ×”××–×•×¨ ×”× ×’×¨×¨ ×¢× ××¤×§×˜ ×—×œ×§
                for (let i = startRow; i <= endRow; i++) {
                    for (let j = startCol; j <= endCol; j++) {
                        // ×¦×™×•×¨ ×™×“× ×™ ×‘×–××Ÿ ×’×¨×™×¨×” × ×©××¨ ×›×©×›×‘×” ×™×“× ×™×ª
                        manualPaintLayer[i][j] = selectedColor;
                        targetGridData[i][j] = selectedColor;
                        const cellIndex = i * 60 + j;
                        const cell = document.getElementById('targetGrid').children[cellIndex];
                        cell.style.backgroundColor = selectedColor;
                        cell.style.border = '2px solid #374151';
                        cell.style.transition = 'all 0.1s ease'; // ××¤×§×˜ ××¢×‘×¨ ×—×œ×§
                    }
                }
            }
        }

        // ×¢×“×›×•×Ÿ ×ª×¦×•×’×” ×—×œ×§ ×œ×’×¨×™×¨×”
        function updateGridDisplaySmooth() {
            // ×¢×“×›×•×Ÿ targetGridData ×ª×—×™×œ×” ×œ×¤×™ ×”×©×˜×—×™× ×”×§×™×™××™×
            for (let i = 0; i < 30; i++) {
                for (let j = 0; j < 60; j++) {
                    targetGridData[i][j] = '#ffffff'; // ××™×¤×•×¡ ×œ×¨×§×¢ ×œ×‘×Ÿ
                }
            }
            
            // ×¢×“×›×•×Ÿ targetGridData ×œ×¤×™ ×”×©×˜×—×™× ×”×§×™×™××™× (×œ×¤×™ ×¡×“×¨ ×™×¦×™×¨×”)
            createdShapes.forEach(shape => {
                shape.cells.forEach(([row, col]) => {
                    targetGridData[row][col] = shape.color;
                });
            });

            // ×”×—×œ×ª ×©×›×‘×ª ×¦×™×•×¨ ×™×“× ×™ ××¢×œ ×”×©×˜×—×™× (×›××• ×‘-updateGridDisplay)
            for (let i = 0; i < 30; i++) {
                for (let j = 0; j < 60; j++) {
                    if (manualPaintLayer[i][j]) {
                        targetGridData[i][j] = manualPaintLayer[i][j];
                    }
                }
            }

            // ×”×—×œ×ª ×©×›×‘×ª ×¦×™×•×¨ ×™×“× ×™ ××¢×œ ×”×©×˜×—×™× - ×œ× ×œ××—×•×§ ×™×“× ×™ ×‘×¢×ª ×”×–×–×ª ×©×˜×—×™×
            for (let i = 0; i < 30; i++) {
                for (let j = 0; j < 60; j++) {
                    if (manualPaintLayer[i][j]) {
                        targetGridData[i][j] = manualPaintLayer[i][j];
                    }
                }
            }
            
            // ×¢×›×©×™×• ×¢×“×›×•×Ÿ ×”×ª×¦×•×’×” ×”×•×™×–×•××œ×™×ª ×¢× ××¤×§×˜×™× ×—×œ×§×™×
            for (let i = 0; i < 30; i++) {
                for (let j = 0; j < 60; j++) {
                    const cellIndex = i * 60 + j;
                    const cell = document.getElementById('targetGrid').children[cellIndex];
                    
                    // ××™×¤×•×¡ ×›×œ ×”×¡×˜×™×™×œ×™×
                    cell.style.backgroundColor = targetGridData[i][j];
                    cell.style.border = '1px solid #e5e7eb';
                    cell.style.transition = 'all 0.05s ease'; // ××¢×‘×¨ ××”×™×¨ ×•×—×œ×§
                    
                    // ×‘×•×¨×“×¨ ××™×•×—×“ ×‘××¦×‘ ×™×¦×™×¨×ª ×©×˜×—
                    if (shapeCreationMode && targetGridData[i][j] !== '#ffffff') {
                        cell.style.border = '2px solid #374151';
                    }
                }
            }
            
            // ×¢×“×›×•×Ÿ ××¨×™×—×™× ××•× ×—×™× (×ª××™×“ ×‘×©×›×‘×” ×”×¢×œ×™×•× ×”)
            placedTiles.forEach(tile => {
                tile.positions.forEach(([row, col]) => {
                    const cellIndex = row * 60 + col;
                    const cell = document.getElementById('targetGrid').children[cellIndex];
                    cell.style.backgroundColor = tile.color || '#0ea5e9';
                    cell.style.transition = 'all 0.05s ease';
                    
                    // ×§×‘×™×¢×ª ×”×‘×•×¨×“×¨
                    const isEdge = isEdgeOfTile(row, col, tile.positions);
                    const borderColor = tile.borderColor || '#075985';
                    
                    cell.style.borderTop = isEdge.top ? `2px solid ${borderColor}` : '1px solid #ffffff';
                    cell.style.borderRight = isEdge.right ? `2px solid ${borderColor}` : '1px solid #ffffff';
                    cell.style.borderBottom = isEdge.bottom ? `2px solid ${borderColor}` : '1px solid #ffffff';
                    cell.style.borderLeft = isEdge.left ? `2px solid ${borderColor}` : '1px solid #ffffff';
                });
            });
            
            // ×”×“×’×©×” ×‘××¦×‘ ×”×–×–×ª ××¨×™×—×™×
            if (tileMoveMode) {
                highlightMovableTiles();
            }
        }

        // ××¦×™××ª ×©×˜×— ×‘××™×§×•× - ×”×©×˜×— ×”×¢×œ×™×•×Ÿ ×‘×™×•×ª×¨
        function findShapeAtPosition(row, col) {
            // ×—×™×¤×•×© ××”×©×˜×— ×”××—×¨×•×Ÿ (×”×¢×œ×™×•×Ÿ) ×œ×¨××©×•×Ÿ
            for (let i = createdShapes.length - 1; i >= 0; i--) {
                const shape = createdShapes[i];
                if (shape.cells.some(([r, c]) => r === row && c === col)) {
                    return shape;
                }
            }
            return null;
        }
        // ××—×™×§×ª ×©×˜×— ××•×˜×•××˜×™ × ×‘×—×¨
        function deleteSelectedShape() {
            if (!selectedShape) {
                showStatus('××™×Ÿ ×©×˜×— × ×‘×—×¨ ×œ××—×™×§×”', 'error');
                return;
            }
            // ×©××™×¨×ª ××¦×‘
            saveState();

            // ×”×¡×¨×ª ×”×©×˜×— ××”××¢×¨×š
            const idx = createdShapes.indexOf(selectedShape);
            if (idx >= 0) {
                createdShapes.splice(idx, 1);
            }

            // × ×™×§×•×™ ×”×‘×—×™×¨×” ×•×”×¡×ª×¨×ª ×›×¤×ª×•×¨ ××—×™×§×”
            selectedShape = null;
            const deleteShapeBtn = document.getElementById('deleteShapeBtn');
            if (deleteShapeBtn) deleteShapeBtn.style.display = 'none';

            // ×¨×¢× ×•×Ÿ ×”×ª×¦×•×’×” - ×©×›×‘×ª ×”×™×“× ×™ ×ª×™×©××¨
            updateGridDisplay();
            showStatus('ğŸ—‘ï¸ ×©×˜×— × ××—×§', 'success');
        }



        // ×‘×“×™×§×” ×× × ×§×•×“×” × ××¦××ª ×‘×ª×•×š ×”××¨×™×— ××• ×‘×¡×‘×™×‘×ª×• ×”×§×¨×•×‘×” (1 ×"×)
        function isWithinTileDragArea(row, col, tile) {
            if (!tile || tile.length === 0) return false;
            
            const bounds = getTileBounds(tile);
            const margin = 1; // 1 ×"× ×¡×‘×™×‘ ×”××¨×™×—
            
            return row >= bounds.minRow - margin && 
                   row <= bounds.maxRow + margin && 
                   col >= bounds.minCol - margin && 
                   col <= bounds.maxCol + margin;
        }
        
        // ×§×‘×œ×ª ×”×¦×‘×¢ ×”× ×›×•×Ÿ ×œ×ª× ×œ×¤×™ ×©×›×‘×•×ª
        function getTopLayerColor(row, col) {
            // ×—×™×¤×•×© ××”×©×˜×— ×”××—×¨×•×Ÿ (×”×¢×œ×™×•×Ÿ) ×œ×¨××©×•×Ÿ
            for (let i = createdShapes.length - 1; i >= 0; i--) {
                const shape = createdShapes[i];
                if (shape.cells.some(([r, c]) => r === row && c === col)) {
                    return shape.color;
                }
            }
            return '#ffffff'; // ×¦×‘×¢ ×¨×§×¢ ×× ××™×Ÿ ×©×˜×—
        }

        // ×§×‘×œ×ª ×”×¦×‘×¢ ×”× ×›×•×Ÿ ×œ×ª× ×œ×¤×™ ×©×›×‘×•×ª, ×œ××¢×˜ ×©×˜×— ××¡×•×™×
        function getTopLayerColorExcluding(row, col, excludeShape) {
            // ×—×™×¤×•×© ××”×©×˜×— ×”××—×¨×•×Ÿ (×”×¢×œ×™×•×Ÿ) ×œ×¨××©×•×Ÿ, ×œ××¢×˜ ×”×©×˜×— ×©××•×—×¨×’
            for (let i = createdShapes.length - 1; i >= 0; i--) {
                const shape = createdShapes[i];
                if (shape !== excludeShape && shape.cells.some(([r, c]) => r === row && c === col)) {
                    return shape.color;
                }
            }
            return '#ffffff'; // ×¦×‘×¢ ×¨×§×¢ ×× ××™×Ÿ ×©×˜×—
        }

        // ×”×–×–×ª ×©×˜×—
        function moveShape(shape, newRow, newCol) {
            // ×”×©×˜×— ×™×–×•×– ×›×š ×©×”×ª× ×©×œ×—×¦× ×• ×¢×œ×™×• ×™×”×™×” ×‘×“×™×•×§ ×‘××™×§×•× ×”×¡××Ÿ
            const clickedCellInShape = dragStartPos;
            
            // ×—×™×©×•×‘ ×”×”×¤×¨×© ×‘×™×Ÿ ×”×ª× ×©×œ×—×¦× ×• ×¢×œ×™×• ×œ×›×œ ×ª× ××—×¨ ×‘×©×˜×—
            const shapeOffsets = shape.cells.map(([r, c]) => [r - clickedCellInShape[0], c - clickedCellInShape[1]]);
            
            // ×—×™×©×•×‘ ×”××™×§×•× ×”×—×“×© ×©×œ ×›×œ ×ª× ×‘×©×˜×— - ×”×ª× ×©×œ×—×¦× ×• ×¢×œ×™×• ×™×”×™×” ×‘×“×™×•×§ ×‘××™×§×•× ×”×¡××Ÿ
            const newCells = shapeOffsets.map(([offsetR, offsetC]) => [newRow + offsetR, newCol + offsetC]);
            
            // ×‘×“×™×§×” ×©×›×œ ×”×ª××™× ×”×—×“×©×™× ×‘×ª×•×š ×”×’×‘×•×œ×•×ª
            const isValidMove = newCells.every(([r, c]) => 
                r >= 0 && r < 30 && c >= 0 && c < 60
            );
            
            if (!isValidMove) return;
            
            // ×¢×“×›×•×Ÿ ×”××™×§×•× ×”×—×“×© ×‘×œ×‘×“; ×”×¨×™× ×“×•×¨ ×”××œ× ×™×“××’ ×œ×©×›×‘×•×ª ×”×™×“× ×™/×©×˜×—×™×/××¨×™×—×™×
            shape.cells = newCells;

            // ×¨×¢× ×•×Ÿ ×ª×¦×•×’×” ×—×œ×§ ×©××›×‘×“ ×©×›×‘×•×ª ×™×“× ×™
            updateGridDisplaySmooth();
        }

        // ×¦×‘×™×¢×ª ×ª× ×‘×’×¨×™×“ ×”×™×¢×“
        function paintTargetCell(row, col) {
            if (tileMoveMode) {
                // ××¦×‘ ×”×–×–×ª ××¨×™×—×™×
                if (selectedTileForMove) {
                    // ××¨×™×— × ×‘×—×¨ - × ×¡×” ×œ×”×–×™×– ××•×ª×•
                    moveTileToPosition(row, col);
                } else {
                    // ××™×Ÿ ××¨×™×— × ×‘×—×¨ - × ×¡×” ×œ×‘×—×•×¨ ××¨×™×—
                    selectTileForMove(row, col);
                }
                return;
            }
            
            if (tilingMode) {
                placeTileAt(row, col);
                return;
            }
            
            if (shapeCreationMode) {
                // ×¦×™×•×¨ ×™×“× ×™ × ×©××¨ ×‘×©×›×‘×” × ×¤×¨×“×ª ×›×“×™ ×©×œ× ×™×™××—×§ ×‘×”×–×–×ª ×©×˜×—×™×
                manualPaintLayer[row][col] = selectedColor;
                targetGridData[row][col] = selectedColor;
                const cellIndex = row * 60 + col;
                const cell = document.getElementById('targetGrid').children[cellIndex];
                if (cell) {
                    cell.style.backgroundColor = selectedColor;
                    cell.style.border = '2px solid #374151';
                }
                return;
            }
            
            // ××¦×‘ ×¨×’×™×œ - ×¦×‘×™×¢×” ×¤×©×•×˜×” ×’× × ×©××¨×ª ×‘×©×›×‘×” ×”×™×“× ×™×ª
            manualPaintLayer[row][col] = selectedColor;
            targetGridData[row][col] = selectedColor;
            const cellIndex = row * 60 + col;
            const cell = document.getElementById('targetGrid').children[cellIndex];
            if (cell) {
                cell.style.backgroundColor = selectedColor;
            }
        }

        // ×™×¦×™×¨×ª ×©×˜×— ××•×˜×•××˜×™
        function createAutoShape() {
            const widthInput = document.getElementById('shapeWidth');
            const heightInput = document.getElementById('shapeHeight');
            
            if (!widthInput || !heightInput) {
                showStatus('×©×’×™××” ×‘×§×¨×™××ª × ×ª×•× ×™ ×”×’×•×“×œ', 'error');
                return;
            }
            
            const width = parseInt(widthInput.value) || 10;
            const height = parseInt(heightInput.value) || 10;
            
            if (width < 1 || width > 30 || height < 1 || height > 30) {
                showStatus('×’×•×“×œ ×”×©×˜×— ×—×™×™×‘ ×œ×”×™×•×ª ×‘×™×Ÿ 1 ×œ-30', 'error');
                return;
            }
            
            // ×©××™×¨×ª ×”××¦×‘ ×œ×¤× ×™ ×”×©×™× ×•×™
            saveState();
            
            shapeCreationMode = true;
            updateGridTitle();
            
            // ××¦×™××ª ××™×§×•× ×¤× ×•×™ - ×”×ª×—×œ×” ××”××¨×›×–
            let startRow = Math.max(0, Math.floor((30 - height) / 2));
            let startCol = Math.max(0, Math.floor((60 - width) / 2));
            
            // ×× ×”××™×§×•× ×ª×¤×•×¡, ××¦× ××™×§×•× ×¤× ×•×™
            let attempts = 0;
            while (isAreaOccupied(startRow, startCol, width, height) && attempts < 100) {
                startRow = Math.floor(Math.random() * Math.max(1, 30 - height));
                startCol = Math.floor(Math.random() * Math.max(1, 60 - width));
                attempts++;
            }
            
            // ×™×¦×™×¨×ª ×”×©×˜×— ×”×—×“×©
            const newShape = {
                id: Date.now(),
                startRow: startRow,
                startCol: startCol,
                width: width,
                height: height,
                color: selectedColor,
                cells: []
            };
            
            // ×¦×‘×™×¢×ª ×”××œ×‘×Ÿ ×•×”×•×¡×¤×ª ×”×ª××™× ×œ×©×˜×— (×œ× ×œ×“×¨×•×¡ ×™×“× ×™)
            for (let i = startRow; i < startRow + height && i < 30; i++) {
                for (let j = startCol; j < startCol + width && j < 60; j++) {
                    if (!manualPaintLayer[i][j]) {
                        targetGridData[i][j] = selectedColor;
                    }
                    const cellIndex = i * 60 + j;
                    const cell = document.getElementById('targetGrid').children[cellIndex];
                    if (cell) {
                        cell.style.backgroundColor = manualPaintLayer[i][j] ? manualPaintLayer[i][j] : selectedColor;
                        cell.style.border = '2px solid #374151';
                    }
                    newShape.cells.push([i, j]);
                }
            }
            
            createdShapes.push(newShape);
            showStatus(`× ×•×¦×¨ ×©×˜×— ${width}Ã—${height} - × ×™×ª×Ÿ ×œ×’×¨×•×¨ ×•×œ×”×•×¡×™×£ ×©×˜×—×™× × ×•×¡×¤×™×`, 'success');
        }

        // ×‘×“×™×§×” ×× ××–×•×¨ ×ª×¤×•×¡
        function isAreaOccupied(startRow, startCol, width, height) {
            for (let i = startRow; i < startRow + height && i < 30; i++) {
                for (let j = startCol; j < startCol + width && j < 30; j++) {
                    if (targetGridData[i][j] !== '#ffffff') {
                        return true;
                    }
                }
            }
            return false;
        }

        // ×¢×“×›×•×Ÿ ×›×•×ª×¨×ª ×”×’×¨×™×“
        function updateGridTitle() {
            const title = document.getElementById('gridTitle');
            if (shapeCreationMode) {
                title.textContent = 'ğŸ¨ ××¦×‘ ×™×¦×™×¨×ª ×©×˜×—×™ ×¨×™×¦×•×£ (30Ã—60) - × ×™×ª×Ÿ ×œ×’×¨×•×¨ ×•×œ×”×•×¡×™×£';
                title.className = 'text-lg font-bold mb-3 text-blue-700 text-center';
            } else if (tileMoveMode) {
                title.textContent = 'ğŸ”„ ××¦×‘ ×”×–×–×ª ××¨×™×—×™× (30Ã—60) - ×œ×—×¥ ×¢×œ ××¨×™×— ×•××– ×¢×œ ××™×§×•× ×—×“×©';
                title.className = 'text-lg font-bold mb-3 text-yellow-700 text-center';
            } else if (tilingMode) {
                title.textContent = 'ğŸ§© ××¦×‘ ×¨×™×¦×•×£ ×¤×¢×™×œ (30Ã—60) - ×”×©×˜×— ××§×•×‘×¢';
                title.className = 'text-lg font-bold mb-3 text-green-700 text-center';
            } else {
                title.textContent = '×©×˜×— ×”×¨×™×¦×•×£ (30Ã—60)';
                title.className = 'text-lg font-bold mb-3 text-gray-700 text-center';
            }
        }





        // ×¡×™×•× ×™×¦×™×¨×ª ×©×˜×—
        function finishShapeCreation() {
            shapeCreationMode = false;
            isDragging = false;
            dragStartPos = null;
            draggedShape = null;
            selectedShape = null;
            const deleteShapeBtn = document.getElementById('deleteShapeBtn');
            if (deleteShapeBtn) deleteShapeBtn.style.display = 'none';
            
            // ×”×¡×¨×ª ×”×‘×•×¨×“×¨ ×”××™×•×—×“ ××›×œ ×”×©×˜×—×™×
            createdShapes.forEach(shape => {
                shape.cells.forEach(([row, col]) => {
                    const cellIndex = row * 60 + col;
                    const cell = document.getElementById('targetGrid').children[cellIndex];
                    cell.style.border = '1px solid #e5e7eb';
                });
            });
            
            updateGridTitle();
            showStatus('×™×¦×™×¨×ª ×©×˜×— ×”×•×©×œ××” - ×”×©×˜×— ××•×›×Ÿ ×œ×¨×™×¦×•×£', 'info');
        }

        // ×”×—×œ×¤×ª ××¦×‘ ×ª× ×‘××¨×™×—
        function toggleTileCell(row, col) {
            tileGridData[row][col] = !tileGridData[row][col];
            const cellIndex = row * 10 + col;
            const cell = document.getElementById('tileGrid').children[cellIndex];
            cell.style.backgroundColor = tileGridData[row][col] ? '#374151' : '#ffffff';
            updateCurrentTile();
        }

        // ×¢×“×›×•×Ÿ ×”××¨×™×— ×”× ×•×›×—×™
        function updateCurrentTile() {
            const newTile = [];
            for (let i = 0; i < 10; i++) {
                for (let j = 0; j < 10; j++) {
                    if (tileGridData[i][j]) {
                        newTile.push([i, j]);
                    }
                }
            }
            currentTile = newTile;
            generateAllTileVariations();
        }

        // ×™×¦×™×¨×ª ×›×œ ×ª×¦×•×¨×•×ª ×”××¨×™×—
        function generateAllTileVariations() {
            const container = document.getElementById('allTileVariations');
            container.innerHTML = '';
            
            if (currentTile.length === 0) {
                container.innerHTML = '<div class="text-gray-500 text-sm">××™×Ÿ ××¨×™×—</div>';
                return;
            }
            
            const variations = [];
            let baseTile = normalizeTile(currentTile);
            
            // ×ª×¦×•×¨×” ×‘×¡×™×¡×™×ª
            variations.push({ tile: baseTile, label: '×‘×¡×™×¡' });
            
            // ×¡×™×‘×•×‘ 90 ××¢×œ×•×ª
            let rotated90 = normalizeTile(rotateTileArray(baseTile, 1));
            if (!isTileEqual(baseTile, rotated90)) {
                variations.push({ tile: rotated90, label: '90Â°' });
            }
            
            // ×¡×™×‘×•×‘ 180 ××¢×œ×•×ª
            let rotated180 = normalizeTile(rotateTileArray(baseTile, 2));
            if (!variations.some(v => isTileEqual(v.tile, rotated180))) {
                variations.push({ tile: rotated180, label: '180Â°' });
            }
            
            // ×¡×™×‘×•×‘ 270 ××¢×œ×•×ª
            let rotated270 = normalizeTile(rotateTileArray(baseTile, 3));
            if (!variations.some(v => isTileEqual(v.tile, rotated270))) {
                variations.push({ tile: rotated270, label: '270Â°' });
            }
            
            // ×”×™×¤×•×š ××•×¤×§×™
            let flippedH = normalizeTile(flipTileArray(baseTile, 'horizontal'));
            if (!variations.some(v => isTileEqual(v.tile, flippedH))) {
                variations.push({ tile: flippedH, label: '×”×™×¤×•×š' });
            }
            
            // ×”×™×¤×•×š ×× ×›×™
            let flippedV = normalizeTile(flipTileArray(baseTile, 'vertical'));
            if (!variations.some(v => isTileEqual(v.tile, flippedV))) {
                variations.push({ tile: flippedV, label: '×”×™×¤×•×š â†•' });
            }
            
            // ×©×™×œ×•×‘×™× ×©×œ ×”×™×¤×•×š ×•×¡×™×‘×•×‘
            [flippedH, flippedV].forEach((flipped, idx) => {
                for (let rot = 1; rot <= 3; rot++) {
                    let combined = normalizeTile(rotateTileArray(flipped, rot));
                    if (!variations.some(v => isTileEqual(v.tile, combined))) {
                        variations.push({ 
                            tile: combined, 
                            label: `${idx === 0 ? '×”×™×¤×•×š' : '×”×™×¤×•×šâ†•'}+${rot * 90}Â°` 
                        });
                    }
                }
            });
            
            // ×”×¦×’×ª ×›×œ ×”×ª×¦×•×¨×•×ª
            variations.forEach((variation, index) => {
                const tileDiv = createTilePreview(variation.tile, variation.label, index);
                container.appendChild(tileDiv);
            });
        }

        // ×™×¦×™×¨×ª ×ª×¦×•×’×” ××§×“×™××” ×©×œ ××¨×™×—
        function createTilePreview(tile, label, index) {
            const container = document.createElement('div');
            container.className = 'flex flex-col items-center p-1 border border-gray-300 rounded cursor-pointer hover:bg-blue-50 transition-colors';
            container.onclick = () => selectTileVariation(tile, index);
            
            const bounds = getTileBounds(tile);
            const rows = bounds.maxRow - bounds.minRow + 1;
            const cols = bounds.maxCol - bounds.minCol + 1;
            
            const grid = document.createElement('div');
            grid.className = 'grid gap-0 mb-1';
            grid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
            
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'w-1.5 h-1.5 border-0';
                    const isPartOfTile = tile.some(pos => 
                        pos[0] === bounds.minRow + i && pos[1] === bounds.minCol + j
                    );
                    cell.style.backgroundColor = isPartOfTile ? '#374151' : 'transparent';
                    grid.appendChild(cell);
                }
            }
            
            const labelDiv = document.createElement('div');
            labelDiv.className = 'text-xs text-gray-600 text-center';
            labelDiv.textContent = label;
            
            container.appendChild(grid);
            container.appendChild(labelDiv);
            
            return container;
        }

        // ×‘×—×™×¨×ª ×ª×¦×•×¨×ª ××¨×™×—
        function selectTileVariation(tile, index) {
            currentTile = [...tile];
            
            // ×¡×™××•×Ÿ ×”×‘×—×™×¨×”
            document.querySelectorAll('#allTileVariations > div').forEach((div, i) => {
                if (i === index) {
                    div.classList.add('bg-blue-100', 'border-blue-500');
                } else {
                    div.classList.remove('bg-blue-100', 'border-blue-500');
                }
            });
        }

        // ×¤×•× ×§×¦×™×•×ª ×¢×–×¨ ×œ×¢×™×‘×•×“ ××¨×™×—×™×
        function normalizeTile(tile) {
            if (tile.length === 0) return [];
            const bounds = getTileBounds(tile);
            return tile.map(([row, col]) => [row - bounds.minRow, col - bounds.minCol]);
        }

        function getTileBounds(tile) {
            if (tile.length === 0) return { minRow: 0, maxRow: 0, minCol: 0, maxCol: 0 };
            return {
                minRow: Math.min(...tile.map(pos => pos[0])),
                maxRow: Math.max(...tile.map(pos => pos[0])),
                minCol: Math.min(...tile.map(pos => pos[1])),
                maxCol: Math.max(...tile.map(pos => pos[1]))
            };
        }

        function rotateTileArray(tile, times) {
            let result = [...tile];
            for (let t = 0; t < times; t++) {
                const bounds = getTileBounds(result);
                const centerRow = (bounds.maxRow + bounds.minRow) / 2;
                const centerCol = (bounds.maxCol + bounds.minCol) / 2;
                
                result = result.map(([row, col]) => [
                    Math.round(centerRow + (col - centerCol)),
                    Math.round(centerCol - (row - centerRow))
                ]);
            }
            return result;
        }

        function flipTileArray(tile, direction) {
            const bounds = getTileBounds(tile);
            if (direction === 'horizontal') {
                return tile.map(([row, col]) => [row, bounds.maxCol - col + bounds.minCol]);
            } else {
                return tile.map(([row, col]) => [bounds.maxRow - row + bounds.minRow, col]);
            }
        }

        function isTileEqual(tile1, tile2) {
            if (tile1.length !== tile2.length) return false;
            const sorted1 = tile1.map(p => p.join(',')).sort();
            const sorted2 = tile2.map(p => p.join(',')).sort();
            return sorted1.every((p, i) => p === sorted2[i]);
        }

        // × ×™×§×•×™ ×©×˜×— ×”×™×¢×“
        function clearTarget() {
            targetGridData = Array(30).fill().map(() => Array(60).fill('#ffffff'));
            document.querySelectorAll('#targetGrid .grid-cell').forEach(cell => {
                cell.style.backgroundColor = '#ffffff';
                cell.style.border = '1px solid #e5e7eb';
            });
            clearTiling();
            shapeCreationMode = false;
            createdShapes = [];
            updateGridTitle();
        }

        // × ×™×§×•×™ ×”××¨×™×—
        function clearTile() {
            tileGridData = Array(10).fill().map(() => Array(10).fill(false));
            document.querySelectorAll('#tileGrid .tile-cell').forEach(cell => {
                cell.style.backgroundColor = '#ffffff';
            });
            updateCurrentTile();
            
            // ×”×•×¡×¤×ª ×××–×™× ×™ ×¢×›×‘×¨ ×•××’×¢ ×’×œ×•×‘×œ×™×™×
            document.addEventListener('mouseup', handleMouseUp);
            document.addEventListener('touchend', handleMouseUp);
            document.addEventListener('touchcancel', handleMouseUp);
        }

        // × ×™×§×•×™ ×’×¨×™×“ ×”××¨×™×— ×‘×œ×‘×“
        function clearTileGrid() {
            tileGridData = Array(10).fill().map(() => Array(10).fill(false));
            document.querySelectorAll('#tileGrid .tile-cell').forEach(cell => {
                cell.style.backgroundColor = '#ffffff';
            });
        }

        // ×¡×™×‘×•×‘ ×”××¨×™×—
        function rotateTile() {
            if (currentTile.length === 0) return;
            
            // ××¦×™××ª ××¨×›×– ×”×¡×™×‘×•×‘
            const centerRow = Math.max(...currentTile.map(pos => pos[0])) / 2 + Math.min(...currentTile.map(pos => pos[0])) / 2;
            const centerCol = Math.max(...currentTile.map(pos => pos[1])) / 2 + Math.min(...currentTile.map(pos => pos[1])) / 2;
            
            // ×¡×™×‘×•×‘ 90 ××¢×œ×•×ª
            const rotatedTile = currentTile.map(([row, col]) => {
                const newRow = Math.round(centerRow + (col - centerCol));
                const newCol = Math.round(centerCol - (row - centerRow));
                return [newRow, newCol];
            });
            
            // × ×¨××•×œ ×”××™×§×•×
            const minRow = Math.min(...rotatedTile.map(pos => pos[0]));
            const minCol = Math.min(...rotatedTile.map(pos => pos[1]));
            
            const normalizedTile = rotatedTile.map(([row, col]) => [row - minRow, col - minCol]);
            
            // ×¢×“×›×•×Ÿ ×”×’×¨×™×“
            clearTileGrid();
            normalizedTile.forEach(([row, col]) => {
                if (row >= 0 && row < 10 && col >= 0 && col < 10) {
                    tileGridData[row][col] = true;
                    const cellIndex = row * 10 + col;
                    const cell = document.getElementById('tileGrid').children[cellIndex];
                    cell.style.backgroundColor = '#374151';
                }
            });
            
            // ×¢×“×›×•×Ÿ currentTile ×™×©×™×¨×•×ª ×¢× ×”×¢×¨×›×™× ×”×—×“×©×™×
            currentTile = normalizedTile;
            generateAllTileVariations();
        }

        // ×”×™×¤×•×š ×”××¨×™×—
        function flipTile() {
            if (currentTile.length === 0) return;
            
            const maxCol = Math.max(...currentTile.map(pos => pos[1]));
            const flippedTile = currentTile.map(([row, col]) => [row, maxCol - col]);
            
            // × ×¨××•×œ ×”××™×§×•×
            const minRow = Math.min(...flippedTile.map(pos => pos[0]));
            const minCol = Math.min(...flippedTile.map(pos => pos[1]));
            
            const normalizedTile = flippedTile.map(([row, col]) => [row - minRow, col - minCol]);
            
            // ×¢×“×›×•×Ÿ ×”×’×¨×™×“
            clearTileGrid();
            normalizedTile.forEach(([row, col]) => {
                if (row >= 0 && row < 10 && col >= 0 && col < 10) {
                    tileGridData[row][col] = true;
                    const cellIndex = row * 10 + col;
                    const cell = document.getElementById('tileGrid').children[cellIndex];
                    cell.style.backgroundColor = '#374151';
                }
            });
            
            // ×¢×“×›×•×Ÿ currentTile ×™×©×™×¨×•×ª ×¢× ×”×¢×¨×›×™× ×”×—×“×©×™×
            currentTile = normalizedTile;
            generateAllTileVariations();
        }

        // ×©××™×¨×ª ××¦×‘ ×œ×‘×™×˜×•×œ/×—×–×¨×”
        function saveState() {
            // ×”×¡×¨×ª ×›×œ ×”××¦×‘×™× ×©××—×¨×™ ×”××¦×‘ ×”× ×•×›×—×™ (×× ×¢×©×™× ×• ×‘×™×˜×•×œ ×•×¢×›×©×™×• ×¢×•×©×™× ×¤×¢×•×œ×” ×—×“×©×”)
            actionHistory = actionHistory.slice(0, historyIndex + 1);
            
            // ×©××™×¨×ª ×”××¦×‘ ×”× ×•×›×—×™
            const state = {
                placedTiles: JSON.parse(JSON.stringify(placedTiles)),
                targetGridData: JSON.parse(JSON.stringify(targetGridData)),
                createdShapes: JSON.parse(JSON.stringify(createdShapes)),
                tilingMode: tilingMode,
                shapeCreationMode: shapeCreationMode
            };
            
            // Avoid pushing duplicate snapshots
            const last = actionHistory.length > 0 ? actionHistory[actionHistory.length - 1] : null;
            let isDuplicate = false;
            if (last) {
                try {
                    isDuplicate = JSON.stringify(last) === JSON.stringify(state);
                } catch (e) {
                    isDuplicate = false;
                }
            }
            if (!isDuplicate) {
                actionHistory.push(state);
                historyIndex++;
            }
            
            // ×©××™×¨×” ×¢×œ ××§×¡×™××•× 50 ×¤×¢×•×œ×•×ª
            if (actionHistory.length > 50) {
                actionHistory.shift();
                historyIndex--;
            }
            
            updateUndoRedoButtons();
        }

        // ×‘×™×˜×•×œ ×¤×¢×•×œ×” ××—×¨×•× ×”
        function undo() {
            if (historyIndex <= 0) {
                showStatus('××™×Ÿ ×¤×¢×•×œ×•×ª ×œ×‘×™×˜×•×œ', 'error');
                return;
            }
            
            historyIndex--;
            const state = actionHistory[historyIndex];
            
            // ×©×—×–×•×¨ ×”××¦×‘
            placedTiles = JSON.parse(JSON.stringify(state.placedTiles));
            targetGridData = JSON.parse(JSON.stringify(state.targetGridData));
            createdShapes = JSON.parse(JSON.stringify(state.createdShapes));
            
            // ×©×—×–×•×¨ ××¦×‘×™ ×”××¢×¨×›×ª
            if (state.tilingMode !== undefined) tilingMode = state.tilingMode;
            if (state.shapeCreationMode !== undefined) shapeCreationMode = state.shapeCreationMode;
            
            // ×¢×“×›×•×Ÿ ×”×ª×¦×•×’×”
            updateGridDisplay();
            updateGridTitle();
            updateUndoRedoButtons();
            showStatus('×¤×¢×•×œ×” ×‘×•×˜×œ×”', 'info');
        }

        // ×—×–×¨×” ×¢×œ ×¤×¢×•×œ×”
        function redo() {
            if (historyIndex >= actionHistory.length - 1) {
                showStatus('××™×Ÿ ×¤×¢×•×œ×•×ª ×œ×—×–×¨×”', 'error');
                return;
            }
            
            historyIndex++;
            const state = actionHistory[historyIndex];
            
            // ×©×—×–×•×¨ ×”××¦×‘
            placedTiles = JSON.parse(JSON.stringify(state.placedTiles));
            targetGridData = JSON.parse(JSON.stringify(state.targetGridData));
            createdShapes = JSON.parse(JSON.stringify(state.createdShapes));
            
            // ×©×—×–×•×¨ ××¦×‘×™ ×”××¢×¨×›×ª
            if (state.tilingMode !== undefined) tilingMode = state.tilingMode;
            if (state.shapeCreationMode !== undefined) shapeCreationMode = state.shapeCreationMode;
            
            // ×¢×“×›×•×Ÿ ×”×ª×¦×•×’×”
            updateGridDisplay();
            updateGridTitle();
            updateUndoRedoButtons();
            showStatus('×¤×¢×•×œ×” ×©×•×—×–×¨×”', 'info');
        }

        // ×¢×“×›×•×Ÿ ×›×¤×ª×•×¨×™ ×‘×™×˜×•×œ ×•×—×–×¨×”
        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            
            undoBtn.disabled = historyIndex <= 0;
            redoBtn.disabled = historyIndex >= actionHistory.length - 1;
        }

        // ×¢×“×›×•×Ÿ ×ª×¦×•×’×ª ×”×’×¨×™×“ ×¢× ××¢×¨×›×ª ×©×›×‘×•×ª
        function updateGridDisplay() {
            // ×¢×“×›×•×Ÿ targetGridData ×ª×—×™×œ×” ×œ×¤×™ ×”×©×˜×—×™× ×”×§×™×™××™×
            for (let i = 0; i < 30; i++) {
                for (let j = 0; j < 60; j++) {
                    targetGridData[i][j] = '#ffffff'; // ××™×¤×•×¡ ×œ×¨×§×¢ ×œ×‘×Ÿ
                }
            }
            
            // ×¢×“×›×•×Ÿ targetGridData ×œ×¤×™ ×”×©×˜×—×™× ×”×§×™×™××™× (×œ×¤×™ ×¡×“×¨ ×™×¦×™×¨×”)
            createdShapes.forEach(shape => {
                shape.cells.forEach(([row, col]) => {
                    targetGridData[row][col] = shape.color;
                });
            });

            // ×”×—×œ×ª ×©×›×‘×ª ×¦×™×•×¨ ×™×“× ×™ ××¢×œ ×”×©×˜×—×™×
            for (let i = 0; i < 30; i++) {
                for (let j = 0; j < 60; j++) {
                    if (manualPaintLayer[i][j]) {
                        targetGridData[i][j] = manualPaintLayer[i][j];
                    }
                }
            }
            
            // ×¢×›×©×™×• ×¢×“×›×•×Ÿ ×”×ª×¦×•×’×” ×”×•×™×–×•××œ×™×ª
            for (let i = 0; i < 30; i++) {
                for (let j = 0; j < 60; j++) {
                    const cellIndex = i * 60 + j;
                    const cell = document.getElementById('targetGrid').children[cellIndex];
                    
                    // ××™×¤×•×¡ ×›×œ ×”×¡×˜×™×™×œ×™×
                    cell.style.backgroundColor = targetGridData[i][j];
                    cell.style.border = '1px solid #e5e7eb';
                    cell.style.borderTop = '';
                    cell.style.borderRight = '';
                    cell.style.borderBottom = '';
                    cell.style.borderLeft = '';
                    cell.style.boxShadow = 'none';
                    cell.style.cursor = 'pointer';
                    cell.style.transform = '';
                    cell.style.transition = '';
                    cell.style.animation = '';
                    cell.style.zIndex = '';
                    cell.style.opacity = '1';
                    
                    // ×‘×•×¨×“×¨ ××™×•×—×“ ×‘××¦×‘ ×™×¦×™×¨×ª ×©×˜×—
                    if (shapeCreationMode && targetGridData[i][j] !== '#ffffff') {
                        cell.style.border = '2px solid #374151';
                    }
                }
            }
            
            // ×¢×“×›×•×Ÿ ××¨×™×—×™× ××•× ×—×™× (×ª××™×“ ×‘×©×›×‘×” ×”×¢×œ×™×•× ×”)
            placedTiles.forEach(tile => {
                tile.positions.forEach(([row, col]) => {
                    const cellIndex = row * 60 + col;
                    const cell = document.getElementById('targetGrid').children[cellIndex];
                    cell.style.backgroundColor = tile.color || '#0ea5e9';
                    
                    // ×§×‘×™×¢×ª ×”×‘×•×¨×“×¨ - ×¦×‘×¢ ×”×‘×•×¨×“×¨ ×©×œ ×”××¨×™×— ×œ×§×•×•×™ ×”××ª××¨ ×”×—×™×¦×•× ×™×™×, ×œ×‘×Ÿ ×œ×§×•×•×™× ×”×¤× ×™××™×™×
                    const isEdge = isEdgeOfTile(row, col, tile.positions);
                    const borderColor = tile.borderColor || '#075985';
                    
                    // ×‘× ×™×™×ª ×”×‘×•×¨×“×¨ ×”××•×ª×× ××™×©×™×ª
                    cell.style.borderTop = isEdge.top ? `2px solid ${borderColor}` : '1px solid #ffffff';
                    cell.style.borderRight = isEdge.right ? `2px solid ${borderColor}` : '1px solid #ffffff';
                    cell.style.borderBottom = isEdge.bottom ? `2px solid ${borderColor}` : '1px solid #ffffff';
                    cell.style.borderLeft = isEdge.left ? `2px solid ${borderColor}` : '1px solid #ffffff';
                });
            });
            
            // ×”×“×’×©×” ×‘××¦×‘ ×”×–×–×ª ××¨×™×—×™×
            if (tileMoveMode) {
                highlightMovableTiles();
            }
        }

        // ×”×¦×’×ª ×”×•×¨××•×ª ×©×™××•×©
        function showInstructions() {
            document.getElementById('instructionsModal').classList.remove('hidden');
        }

        // ×”×¡×ª×¨×ª ×”×•×¨××•×ª ×©×™××•×©
        function hideInstructions() {
            document.getElementById('instructionsModal').classList.add('hidden');
        }

        // ×”×ª×—×œ×ª ××¦×‘ ×¨×™×¦×•×£
        function startTiling() {
            if (currentTile.length === 0) {
                showStatus('×¢×œ×™×š ×œ×¢×¦×‘ ××¨×™×— ×ª×—×™×œ×”!', 'error');
                return;
            }
            
            // ×‘×“×™×§×” ×× ×¢×“×™×™×Ÿ ×‘××¦×‘ ×™×¦×™×¨×ª ×©×˜×—
            if (shapeCreationMode) {
                showStatus('×™×© ×œ×¡×™×™× ×ª×—×™×œ×” ××ª ××¦×‘ ×™×¦×™×¨×ª ×©×˜×—×™ ×”×¨×™×¦×•×£ ×¢×œ ×™×“×™ ×œ×—×™×¦×” ×¢×œ ×›×¤×ª×•×¨ "×¡×™×™× ×™×¦×™×¨×ª ×©×˜×—"', 'error');
                return;
            }
            
            // ×©××™×¨×ª ×”××¦×‘ ×”× ×•×›×—×™
            saveState();
            
            // ×¡×™×•× ××¦×‘ ×™×¦×™×¨×ª ×©×˜×— ××•×˜×•××˜×™×ª
            shapeCreationMode = false;
            isDragging = false;
            dragStartPos = null;
            draggedShape = null;
            removeMode = false;
            
            // ×”×¡×¨×ª ×”×‘×•×¨×“×¨ ×”××™×•×—×“ ××›×œ ×”×©×˜×—×™×
            createdShapes.forEach(shape => {
                shape.cells.forEach(([row, col]) => {
                    const cellIndex = row * 60 + col;
                    const cell = document.getElementById('targetGrid').children[cellIndex];
                    cell.style.border = '1px solid #e5e7eb';
                });
            });
            
            tilingMode = true;
            updateGridTitle();
            showStatus('××¦×‘ ×¨×™×¦×•×£ ×¤×¢×™×œ - ×”×©×˜×— ××§×•×‘×¢, ×œ×—×¥ ×¢×œ ×”×’×¨×™×“ ×œ×”× ×—×ª ××¨×™×—×™×', 'success');
        }

        // ×‘×™×˜×•×œ ××¦×‘ ×¨×™×¦×•×£
        function stopTiling() {
            tilingMode = false;
            tileMoveMode = false;
            selectedTileForMove = null;
            clearTilePreview();
            updateGridTitle();
            showStatus('××¦×‘ ×¨×™×¦×•×£ ×‘×•×˜×œ - ×—×–×¨×” ×œ××¦×‘ ×¢×™×¦×•×‘', 'info');
        }

        // ×”×—×œ×¤×ª ××¦×‘ ×”×–×–×ª ××¨×™×—×™×
        function toggleTileMoveMode() {
            if (placedTiles.length === 0) {
                showStatus('××™×Ÿ ××¨×™×—×™× ×œ×”×–×–×” - ×”× ×— ××¨×™×—×™× ×ª×—×™×œ×”', 'error');
                return;
            }
            
            tileMoveMode = !tileMoveMode;
            selectedTileForMove = null;
            clearTilePreview();
            
            // ×”×¡×ª×¨×ª ×›×¤×ª×•×¨×™ ×¢×¨×™×›×ª ×”××¨×™×—
            const deleteBtn = document.getElementById('deleteTileBtn');
            const rotateBtn = document.getElementById('rotateTileBtn');
            const flipBtn = document.getElementById('flipTileBtn');
            deleteBtn.style.display = 'none';
            rotateBtn.style.display = 'none';
            flipBtn.style.display = 'none';
            
            if (tileMoveMode) {
                tilingMode = false; // ×›×™×‘×•×™ ××¦×‘ ×¨×™×¦×•×£ ×¨×’×™×œ
                updateGridTitle();
                showStatus('××¦×‘ ×”×–×–×ª ××¨×™×—×™× ×¤×¢×™×œ - ×œ×—×¥ ×¢×œ ××¨×™×— ×œ×”×–×–×”', 'success');
                highlightMovableTiles();
            } else {
                updateGridTitle();
                showStatus('××¦×‘ ×”×–×–×ª ××¨×™×—×™× ×‘×•×˜×œ', 'info');
                updateGridDisplay();
            }
        }

        // ×”×“×’×©×ª ××¨×™×—×™× ×”× ×™×ª× ×™× ×œ×”×–×–×”
        function highlightMovableTiles() {
            placedTiles.forEach((tile, index) => {
                tile.positions.forEach(([row, col]) => {
                    const cellIndex = row * 60 + col;
                    const cell = document.getElementById('targetGrid').children[cellIndex];
                    cell.style.boxShadow = '0 0 0 2px #fbbf24 inset'; // ×”×“×’×©×” ×‘×¦×”×•×‘
                    cell.style.cursor = 'pointer';
                });
            });
        }

        // ××¦×™××ª ××¨×™×— ×œ×¤×™ ××™×§×•× ×ª×
        function findTileByPosition(row, col) {
            for (let i = 0; i < placedTiles.length; i++) {
                const tile = placedTiles[i];
                if (tile.positions.some(([tRow, tCol]) => tRow === row && tCol === col)) {
                    return { tile, index: i };
                }
            }
            return null;
        }

        // ×‘×—×™×¨×ª ××¨×™×— ×œ×”×–×–×”
        function selectTileForMove(row, col) {
            const tileData = findTileByPosition(row, col);
            if (!tileData) return false;
            
            selectedTileForMove = tileData;
            
            // ×”×¦×’×ª ×›×¤×ª×•×¨×™ ×¢×¨×™×›×ª ×”××¨×™×—
            const deleteBtn = document.getElementById('deleteTileBtn');
            const rotateBtn = document.getElementById('rotateTileBtn');
            const flipBtn = document.getElementById('flipTileBtn');
            deleteBtn.style.display = 'inline-block';
            rotateBtn.style.display = 'inline-block';
            flipBtn.style.display = 'inline-block';
            
            // ×”×“×’×©×ª ×”××¨×™×— ×”× ×‘×—×¨ ×¢× ×× ×™××¦×™×”
            updateGridDisplay();
            tileData.tile.positions.forEach(([tRow, tCol]) => {
                const cellIndex = tRow * 60 + tCol;
                const cell = document.getElementById('targetGrid').children[cellIndex];
                
                // ×”×“×’×©×” ×—×–×§×” ×¢× ×× ×™××¦×™×” ×¤×•×¢××ª
                cell.style.boxShadow = '0 0 0 4px #ef4444 inset, 0 0 10px rgba(239, 68, 68, 0.5)';
                cell.style.cursor = 'grab';
                cell.style.transform = 'scale(1.05)';
                cell.style.transition = 'all 0.2s ease';
                cell.style.zIndex = '10';
                
                // ×× ×™××¦×™×” ×¤×•×¢××ª
                cell.style.animation = 'pulse 1.5s infinite';
            });
            
            // ×”×•×“×¢×” ××•×ª×××ª ×œ××›×©×™×¨
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            if (isMobile) {
                showStatus(`ğŸ”„ ××¨×™×— × ×‘×—×¨ - ×’×¨×•×¨ ×œ×”×–×–×” ××• ×”×©×ª××© ×‘×›×¤×ª×•×¨×™× ×œ×¡×™×‘×•×‘/×”×™×¤×•×š/××—×™×§×”`, 'info');
            } else {
                showStatus(`ğŸ”„ ××¨×™×— × ×‘×—×¨ - ×’×¨×•×¨ ×œ×”×–×–×”, R ×œ×¡×™×‘×•×‘, F ×œ×”×™×¤×•×š, Delete ×œ××—×™×§×”`, 'info');
            }
            return true;
        }

        // ×”×–×–×ª ××¨×™×— ×œ××™×§×•× ×—×“×© ×¢× ×’×¨×™×¨×”
        function moveTileToPosition(targetRow, targetCol) {
            if (!selectedTileForMove) return false;
            
            const { tile, index } = selectedTileForMove;
            
            // ×—×™×©×•×‘ ×”×”×¤×¨×© ×›×š ×©××¨×›×– ×”××¨×™×— ×™×ª×™×™×©×¨ ×¢× ×”×¡××Ÿ
            const currentBounds = getTileBounds(tile.positions.map(([r, c]) => [r, c]));
            const currentCenterRow = Math.floor((currentBounds.minRow + currentBounds.maxRow) / 2);
            const currentCenterCol = Math.floor((currentBounds.minCol + currentBounds.maxCol) / 2);
            const deltaRow = targetRow - currentCenterRow;
            const deltaCol = targetCol - currentCenterCol;
            
            // ×—×™×©×•×‘ ×”××™×§×•××™× ×”×—×“×©×™×
            const newPositions = tile.positions.map(([row, col]) => [
                row + deltaRow,
                col + deltaCol
            ]);
            
            // ×‘×“×™×§×” ×©×”××™×§×•× ×”×—×“×© ×ª×§×™×Ÿ
            const isValidMove = newPositions.every(([row, col]) => {
                // ×‘×“×™×§×ª ×’×‘×•×œ×•×ª
                if (row < 0 || row >= 30 || col < 0 || col >= 60) return false;
                
                // ×‘×“×™×§×” ×©×”××™×§×•× ×”×•× ×—×œ×§ ××”×©×˜×— ×”××™×•×¢×“
                if (targetGridData[row][col] === '#ffffff') return false;
                
                // ×‘×“×™×§×” ×©××™×Ÿ ××¨×™×— ××—×¨ ×‘××™×§×•× (×œ××¢×˜ ×”××¨×™×— ×”× ×•×›×—×™)
                const otherTileAtPosition = placedTiles.find((otherTile, otherIndex) => 
                    otherIndex !== index && 
                    otherTile.positions.some(([oRow, oCol]) => oRow === row && oCol === col)
                );
                
                return !otherTileAtPosition;
            });
            
            if (!isValidMove) {
                showTileDragPreview(targetRow, targetCol, false); // ×ª×¦×•×’×” ××§×“×™××” ××“×•××”
                return false;
            }
            
            // ×©××™×¨×ª ×”××¦×‘ ×œ×¤× ×™ ×”×©×™× ×•×™
            saveState();
            
            // ×¢×“×›×•×Ÿ ××™×§×•× ×”××¨×™×—
            tile.positions = newPositions;
            
            // ×¢×“×›×•×Ÿ ×”×ª×¦×•×’×”
            updateGridDisplay();
            clearTileDragPreview();
            
            // ××™×¤×•×¡ ×”×‘×—×™×¨×”
            selectedTileForMove = null;
            
            showStatus('×”××¨×™×— ×”×•×–×– ×‘×”×¦×œ×—×”!', 'success');
            
            // ×‘×“×™×§×ª ×”×©×œ××ª ×¨×™×¦×•×£
            checkTilingComplete();
            
            return true;
        }

        // ×”×–×–×” ××•×˜×•××˜×™×ª ×‘××•×‘×™×™×œ - ×œ×œ× ×¦×•×¨×š ×‘×œ×—×™×¦×” × ×•×¡×¤×ª
        function moveTileToPositionAuto(targetRow, targetCol) {
            if (!selectedTileForMove) return false;
            
            const { tile, index } = selectedTileForMove;
            
            // ×—×™×©×•×‘ ×”×”×¤×¨×© ×›×š ×©××¨×›×– ×”××¨×™×— ×™×ª×™×™×©×¨ ×¢× ×”×¡××Ÿ
            const currentBounds = getTileBounds(tile.positions.map(([r, c]) => [r, c]));
            const currentCenterRow = Math.floor((currentBounds.minRow + currentBounds.maxRow) / 2);
            const currentCenterCol = Math.floor((currentBounds.minCol + currentBounds.maxCol) / 2);
            const deltaRow = targetRow - currentCenterRow;
            const deltaCol = targetCol - currentCenterCol;
            
            // ×—×™×©×•×‘ ×”××™×§×•××™× ×”×—×“×©×™×
            const newPositions = tile.positions.map(([row, col]) => [
                row + deltaRow,
                col + deltaCol
            ]);
            
            // ×‘×“×™×§×” ×©×”××™×§×•× ×”×—×“×© ×ª×§×™×Ÿ
            const isValidMove = newPositions.every(([row, col]) => {
                // ×‘×“×™×§×ª ×’×‘×•×œ×•×ª
                if (row < 0 || row >= 30 || col < 0 || col >= 60) return false;
                
                // ×‘×“×™×§×” ×©×”××™×§×•× ×”×•× ×—×œ×§ ××”×©×˜×— ×”××™×•×¢×“
                if (targetGridData[row][col] === '#ffffff') return false;
                
                // ×‘×“×™×§×” ×©××™×Ÿ ××¨×™×— ××—×¨ ×‘××™×§×•× (×œ××¢×˜ ×”××¨×™×— ×”× ×•×›×—×™)
                const otherTileAtPosition = placedTiles.find((otherTile, otherIndex) => 
                    otherIndex !== index && 
                    otherTile.positions.some(([oRow, oCol]) => oRow === row && oCol === col)
                );
                
                return !otherTileAtPosition;
            });
            
            if (!isValidMove) {
                // ×¨×§ ×”×¦×’×ª ×ª×¦×•×’×” ××§×“×™××” ××“×•××”, ×œ×œ× ×”×–×–×”
                showSmoothTileDragPreview(targetRow, targetCol);
                return false;
            }
            
            // ×¢×“×›×•×Ÿ ××™×§×•× ×”××¨×™×— ××™×™×“×™×ª ×œ×œ× ×©××™×¨×ª ××¦×‘ (×™×™×©××¨ ×‘×¡×•×£ ×”×’×¨×™×¨×”)
            tile.positions = newPositions;
            
            // ×¢×“×›×•×Ÿ ×”×ª×¦×•×’×” ××™×™×“×™×ª
            updateGridDisplay();
            
            return true;
        }

        // ×ª×¦×•×’×” ××§×“×™××” ×—×œ×§×” ×•××“×•×™×§×ª ×‘×–××Ÿ ×’×¨×™×¨×ª ××¨×™×—
        function showSmoothTileDragPreview(targetRow, targetCol) {
            if (!selectedTileForMove) return;
            
            clearTileDragPreview();
            
            const { tile, index } = selectedTileForMove;
            const currentBounds = getTileBounds(tile.positions.map(([r, c]) => [r, c]));
            const currentCenterRow = Math.floor((currentBounds.minRow + currentBounds.maxRow) / 2);
            const currentCenterCol = Math.floor((currentBounds.minCol + currentBounds.maxCol) / 2);
            const deltaRow = targetRow - currentCenterRow;
            const deltaCol = targetCol - currentCenterCol;
            
            const newPositions = tile.positions.map(([row, col]) => [
                row + deltaRow,
                col + deltaCol
            ]);
            
            // ×‘×“×™×§×ª ×ª×§×™× ×•×ª ×”××™×§×•× ×”×—×“×©
            const isValidMove = newPositions.every(([row, col]) => {
                if (row < 0 || row >= 30 || col < 0 || col >= 60) return false;
                if (targetGridData[row][col] === '#ffffff') return false;
                
                const otherTileAtPosition = placedTiles.find((otherTile, otherIndex) => 
                    otherIndex !== index && 
                    otherTile.positions.some(([oRow, oCol]) => oRow === row && oCol === col)
                );
                
                return !otherTileAtPosition;
            });
            
            // ×”×¦×’×ª ×”×ª×¦×•×’×” ×”××§×“×™××” ×¢× ×¦×‘×¢×™× ×‘×¨×•×¨×™×
            newPositions.forEach(([row, col]) => {
                if (row >= 0 && row < 30 && col >= 0 && col < 60) {
                    const cellIndex = row * 60 + col;
                    const cell = document.getElementById('targetGrid').children[cellIndex];
                    
                    if (isValidMove) {
                        // ×™×¨×•×§ ×‘×”×™×¨ ×¢× ×‘×•×¨×“×¨ ×™×¨×•×§ ×›×”×” - ××™×§×•× ×ª×§×™×Ÿ
                        cell.style.backgroundColor = '#bbf7d0';
                        cell.style.border = '3px solid #16a34a';
                        cell.style.opacity = '0.9';
                        cell.style.transform = 'scale(0.95)';
                        cell.style.transition = 'all 0.1s ease';
                    } else {
                        // ××“×•× ×‘×”×™×¨ ×¢× ×‘×•×¨×“×¨ ××“×•× ×›×”×” - ××™×§×•× ×œ× ×ª×§×™×Ÿ
                        cell.style.backgroundColor = '#fecaca';
                        cell.style.border = '3px solid #dc2626';
                        cell.style.opacity = '0.8';
                        cell.style.transform = 'scale(0.9)';
                        cell.style.transition = 'all 0.1s ease';
                    }
                }
            });
            
            // ×¢×“×›×•×Ÿ ×”×•×“×¢×ª ×”×¡×˜×˜×•×¡
            if (isValidMove) {
                showStatus('âœ… ××™×§×•× ×ª×§×™×Ÿ - ×œ×—×¥ ×œ×”× ×—×”', 'success');
            } else {
                showStatus('âŒ ××™×§×•× ×œ× ×ª×§×™×Ÿ - ×‘×—×¨ ××™×§×•× ××—×¨', 'error');
            }
        }

        // ×ª×¦×•×’×” ××§×“×™××” ×‘×–××Ÿ ×’×¨×™×¨×ª ××¨×™×— (×’×¨×¡×” ×™×©× ×” - ×œ×ª××™××•×ª)
        function showTileDragPreview(targetRow, targetCol, isValid = true) {
            showSmoothTileDragPreview(targetRow, targetCol);
        }

        // × ×™×§×•×™ ×ª×¦×•×’×” ××§×“×™××” ×©×œ ×’×¨×™×¨×ª ××¨×™×—
        function clearTileDragPreview() {
            document.querySelectorAll('#targetGrid .grid-cell').forEach(cell => {
                // × ×™×§×•×™ ×›×œ ×”××¤×§×˜×™× ×©×œ ×”×ª×¦×•×’×” ×”××§×“×™××”
                if (cell.style.backgroundColor === 'rgb(187, 247, 208)' || // ×™×¨×•×§ ×‘×”×™×¨
                    cell.style.backgroundColor === 'rgb(254, 202, 202)' || // ××“×•× ×‘×”×™×¨
                    cell.style.boxShadow.includes('#10b981') || 
                    cell.style.boxShadow.includes('#ef4444') ||
                    cell.style.boxShadow.includes('#16a34a') ||
                    cell.style.boxShadow.includes('#dc2626')) {
                    
                    // ××™×¤×•×¡ ×œ×¢×¨×›×™ ×‘×¨×™×¨×ª ××—×“×œ
                    cell.style.boxShadow = '';
                    cell.style.opacity = '1';
                    cell.style.transform = '';
                    cell.style.transition = '';
                    
                    // ×©×—×–×•×¨ ×”×¦×‘×¢ ×”××§×•×¨×™
                    const row = Math.floor(Array.from(cell.parentNode.children).indexOf(cell) / 60);
                    const col = Array.from(cell.parentNode.children).indexOf(cell) % 60;
                    
                    // ×‘×“×™×§×” ×× ×™×© ××¨×™×— ×‘××™×§×•× ×–×”
                    const tileAtPosition = placedTiles.find(tile => 
                        tile.positions.some(([tRow, tCol]) => tRow === row && tCol === col)
                    );
                    
                    if (tileAtPosition) {
                        // ×©×—×–×•×¨ ×¦×‘×¢ ×”××¨×™×—
                        cell.style.backgroundColor = tileAtPosition.color;
                        const isEdge = isEdgeOfTile(row, col, tileAtPosition.positions);
                        const borderColor = tileAtPosition.borderColor;
                        
                        const borderParts = [];
                        borderParts.push(isEdge.top ? `2px solid ${borderColor}` : '1px solid #ffffff');
                        borderParts.push(isEdge.right ? `2px solid ${borderColor}` : '1px solid #ffffff');
                        borderParts.push(isEdge.bottom ? `2px solid ${borderColor}` : '1px solid #ffffff');
                        borderParts.push(isEdge.left ? `2px solid ${borderColor}` : '1px solid #ffffff');
                        
                        cell.style.borderTop = borderParts[0];
                        cell.style.borderRight = borderParts[1];
                        cell.style.borderBottom = borderParts[2];
                        cell.style.borderLeft = borderParts[3];
                    } else {
                        // ×©×—×–×•×¨ ×¦×‘×¢ ×”×¨×§×¢ ×”××§×•×¨×™, ×ª×•×š ×”×¢×“×¤×ª ×©×›×‘×ª ×¦×™×•×¨ ×™×“× ×™ ×× ×§×™×™××ª
                        const manualColor = manualPaintLayer[row][col];
                        const baseColor = manualColor ? manualColor : targetGridData[row][col];
                        cell.style.backgroundColor = baseColor;
                        cell.style.border = '1px solid #e5e7eb';
                    }
                }
            });
        }

        // ×”×¦×’×ª ×ª×¦×•×’×” ××§×“×™××” ×©×œ ×”××¨×™×—
        function showTilePreview(hoverRow, hoverCol) {
            clearTilePreview();
            
            // ×”××¨×™×— ×™×•×¦×‘ ×›×š ×©×”×ª× ×”×¨××©×•×Ÿ ×©×œ×• ×™×”×™×” ×‘×“×™×•×§ ×‘××™×§×•× ×”×¡××Ÿ
            previewPosition = [hoverRow, hoverCol];
            
            // ××¦×™××ª ×”×ª× ×”×¨××©×•×Ÿ ×‘××¨×™×— (×”×§×¨×•×‘ ×‘×™×•×ª×¨ ×œ×¤×™× ×” ×”×©×××œ×™×ª ×”×¢×œ×™×•× ×”)
            if (currentTile.length === 0) return;
            
            const minRow = Math.min(...currentTile.map(pos => pos[0]));
            const minCol = Math.min(...currentTile.map(pos => pos[1]));
            
            currentTile.forEach(([tileRow, tileCol]) => {
                const targetRow = hoverRow + (tileRow - minRow);
                const targetCol = hoverCol + (tileCol - minCol);
                
                if (targetRow >= 0 && targetRow < 30 && targetCol >= 0 && targetCol < 60) {
                    const cellIndex = targetRow * 60 + targetCol;
                    const cell = document.getElementById('targetGrid').children[cellIndex];
                    
                    const canPlace = canPlaceTileAt(hoverRow, hoverCol);
                    
                    if (canPlace) {
                        cell.style.border = '2px solid #10b981';
                        cell.style.opacity = '0.7';
                    } else {
                        cell.style.border = '2px solid #ef4444';
                        cell.style.opacity = '0.7';
                    }
                }
            });
        }

        // × ×™×§×•×™ ×ª×¦×•×’×” ××§×“×™××”
        function clearTilePreview() {
            document.querySelectorAll('#targetGrid .grid-cell').forEach(cell => {
                cell.style.border = '1px solid #e5e7eb';
                cell.style.opacity = '1';
            });
            previewPosition = null;
        }

        // ×‘×“×™×§×” ×× × ×™×ª×Ÿ ×œ×”× ×™×— ××¨×™×— ×‘××™×§×•×
        function canPlaceTileAt(clickRow, clickCol) {
            if (currentTile.length === 0) {
                console.log('canPlaceTileAt: no current tile');
                return false;
            }
            
            // ××¦×™××ª ×”×ª× ×”×¨××©×•×Ÿ ×‘××¨×™×—
            const minRow = Math.min(...currentTile.map(pos => pos[0]));
            const minCol = Math.min(...currentTile.map(pos => pos[1]));
            
            console.log('canPlaceTileAt: checking positions for tile at', clickRow, clickCol);
            
            const result = currentTile.every(([tileRow, tileCol]) => {
                const targetRow = clickRow + (tileRow - minRow);
                const targetCol = clickCol + (tileCol - minCol);
                
                console.log('Checking position:', targetRow, targetCol);
                
                if (targetRow < 0 || targetRow >= 30 || targetCol < 0 || targetCol >= 60) {
                    console.log('Position out of bounds');
                    return false;
                }
                
                // ×‘×“×™×§×” ×©×”××™×§×•× ×”×•× ×—×œ×§ ××”×©×˜×— ×”××™×•×¢×“ ×•×œ× ×ª×¤×•×¡
                const targetColor = targetGridData[targetRow][targetCol];
                const isOccupied = isCellOccupied(targetRow, targetCol);
                
                console.log('Target color:', targetColor, 'Is occupied:', isOccupied);
                
                const isValid = targetColor !== '#ffffff' && !isOccupied;
                if (!isValid) {
                    console.log('Position invalid - color:', targetColor, 'occupied:', isOccupied);
                }
                
                return isValid;
            });
            
            console.log('canPlaceTileAt result:', result);
            return result;
        }



        // ×‘×“×™×§×” ×× ×ª× ×ª×¤×•×¡ ×¢×œ ×™×“×™ ××¨×™×— ××—×¨
        function isCellOccupied(row, col) {
            return placedTiles.some(tile => 
                tile.positions.some(pos => pos[0] === row && pos[1] === col)
            );
        }

        // ×‘×“×™×§×” ×× ×ª× ×”×•× ×§×¦×” ×©×œ ×”××¨×™×—
        function isEdgeOfTile(row, col, tilePositions) {
            const isPartOfTile = (r, c) => tilePositions.some(([tr, tc]) => tr === r && tc === c);
            
            return {
                top: !isPartOfTile(row - 1, col),
                right: !isPartOfTile(row, col + 1),
                bottom: !isPartOfTile(row + 1, col),
                left: !isPartOfTile(row, col - 1)
            };
        }

        // ××¢×¨×š ×¦×‘×¢×™ ××¨×™×—×™× ××’×•×•× ×™×
        const tileColors = [
            { bg: '#fef3c7', border: '#f59e0b' }, // ×¦×”×•×‘ ×–×”×‘
            { bg: '#ddd6fe', border: '#8b5cf6' }, // ×¡×’×•×œ
            { bg: '#fce7f3', border: '#ec4899' }, // ×•×¨×•×“
            { bg: '#d1fae5', border: '#10b981' }, // ×™×¨×•×§
            { bg: '#fed7d7', border: '#ef4444' }, // ××“×•×
            { bg: '#e0f2fe', border: '#0ea5e9' }, // ×ª×›×œ×ª
            { bg: '#fef2e2', border: '#f97316' }, // ×›×ª×•×
            { bg: '#f3e8ff', border: '#a855f7' }, // ×¡×’×•×œ ×‘×”×™×¨
            { bg: '#ecfdf5', border: '#22c55e' }, // ×™×¨×•×§ ×‘×”×™×¨
            { bg: '#fdf2f8', border: '#f472b6' }  // ×•×¨×•×“ ×‘×”×™×¨
        ];

        // Override tileColors to use darker tones for placed tiles
        try {
            if (Array.isArray(tileColors)) {
                tileColors.splice(0, tileColors.length,
                    { bg: '#f59e0b', border: '#92400e' },
                    { bg: '#8b5cf6', border: '#5b21b6' },
                    { bg: '#ec4899', border: '#9d174d' },
                    { bg: '#10b981', border: '#065f46' },
                    { bg: '#ef4444', border: '#7f1d1d' },
                    { bg: '#0ea5e9', border: '#075985' },
                    { bg: '#f97316', border: '#7c2d12' },
                    { bg: '#a855f7', border: '#581c87' },
                    { bg: '#22c55e', border: '#14532d' },
                    { bg: '#f43f5e', border: '#9f1239' }
                );
            }
        } catch (e) {
            console.warn('Failed to override tileColors', e);
        }

        // ×”× ×—×ª ××¨×™×— ×‘××™×§×•×
        function placeTileAt(clickRow, clickCol) {
            console.log('placeTileAt called:', clickRow, clickCol, 'tilingMode:', tilingMode, 'currentTile length:', currentTile.length);
            
            if (!tilingMode) {
                console.log('Not in tiling mode');
                return;
            }
            
            // ×‘×“×™×§×” ×× ×¢×“×™×™×Ÿ ×‘××¦×‘ ×™×¦×™×¨×ª ×©×˜×—
            if (shapeCreationMode) {
                showStatus('×™×© ×œ×¡×™×™× ×ª×—×™×œ×” ××ª ××¦×‘ ×™×¦×™×¨×ª ×©×˜×—×™ ×”×¨×™×¦×•×£ ×¢×œ ×™×“×™ ×œ×—×™×¦×” ×¢×œ ×›×¤×ª×•×¨ "×¡×™×™× ×™×¦×™×¨×ª ×©×˜×—"', 'error');
                return;
            }
            
            // ×”× ×—×ª ××¨×™×— ×—×“×©
            if (currentTile.length === 0) {
                console.log('No current tile defined');
                showStatus('×¢×œ×™×š ×œ×¢×¦×‘ ××¨×™×— ×ª×—×™×œ×”!', 'error');
                return;
            }
            
            // ×”××¨×™×— ×™×•× ×— ×›×š ×©×”×ª× ×”×¨××©×•×Ÿ ×©×œ×• ×™×”×™×” ×‘×“×™×•×§ ×‘××™×§×•× ×”×œ×—×™×¦×”
            const canPlace = canPlaceTileAt(clickRow, clickCol);
            console.log('Can place tile:', canPlace);
            
            if (!canPlace) {
                showStatus('×œ× × ×™×ª×Ÿ ×œ×”× ×™×— ××¨×™×— ×‘××™×§×•× ×–×” - ×•×“× ×©×”××™×§×•× ×¢×œ ×©×˜×— ×¦×‘×¢×•× ×™ ×•×œ× ×ª×¤×•×¡', 'error');
                return;
            }
            
            // ×©××™×¨×ª ×”××¦×‘ ×œ×¤× ×™ ×”×©×™× ×•×™
            saveState();
            
            // ××¦×™××ª ×”×ª× ×”×¨××©×•×Ÿ ×‘××¨×™×—
            const minRow = Math.min(...currentTile.map(pos => pos[0]));
            const minCol = Math.min(...currentTile.map(pos => pos[1]));
            
            const tilePositions = currentTile.map(([tileRow, tileCol]) => [
                clickRow + (tileRow - minRow),
                clickCol + (tileCol - minCol)
            ]);
            
            console.log('Tile positions:', tilePositions);
            
            // ×‘×—×™×¨×ª ×¦×‘×¢ ××¨×™×— (××—×–×•×¨×™ ×œ×¤×™ ××¡×¤×¨ ×”××¨×™×—×™×)
            const colorIndex = placedTiles.length % tileColors.length;
            const tileColor = tileColors[colorIndex];
            
            // ×”×•×¡×¤×ª ×”××¨×™×— ×œ×¨×©×™××ª ×”××¨×™×—×™× ×”××•× ×—×™×
            placedTiles.push({
                positions: tilePositions,
                color: tileColor.bg,
                borderColor: tileColor.border
            });

            saveState();
            
            console.log('Tile placed successfully, total tiles:', placedTiles.length);
            
            clearTilePreview();
            showStatus(`××¨×™×— ×”×•× ×—! ×¡×”"×› ${placedTiles.length} ××¨×™×—×™×`, 'success');
            
            // ×‘×“×™×§×” ×× ×”×¨×™×¦×•×£ ×”×•×©×œ×
            checkTilingComplete();
            updateGridDisplay();
        }

        // ×”×¡×¨×ª ××¨×™×— ××—×¨×•×Ÿ
        function removeTile() {
            if (placedTiles.length === 0) {
                showStatus('××™×Ÿ ××¨×™×—×™× ×œ×”×¡×¨×”', 'error');
                return;
            }
            
            const lastTile = placedTiles.pop();
            
            lastTile.positions.forEach(([row, col]) => {
                const cellIndex = row * 60 + col;
                const cell = document.getElementById('targetGrid').children[cellIndex];
                cell.style.backgroundColor = targetGridData[row][col];
                cell.style.border = '1px solid #e5e7eb';
            });
            
            showStatus(`××¨×™×— ×”×•×¡×¨! × ×•×ª×¨×• ${placedTiles.length} ××¨×™×—×™×`, 'info');
        }

        // × ×™×§×•×™ ×›×œ ×”×¨×™×¦×•×£
        function clearTiling() {
            if (placedTiles.length === 0) {
                showStatus('××™×Ÿ ××¨×™×—×™× ×œ× ×™×§×•×™', 'info');
                return;
            }
            
            // ×©××™×¨×ª ×”××¦×‘ ×œ×¤× ×™ ×”×©×™× ×•×™
            saveState();
            
            placedTiles = [];
            
            // ××™×¤×•×¡ ××¦×‘ ×”×–×–×ª ××¨×™×—×™×
            tileMoveMode = false;
            selectedTileForMove = null;
            
            // × ×™×§×•×™ ××œ× ×©×œ ×›×œ ×”××¤×§×˜×™× ×”×•×™×–×•××œ×™×™×
            for (let i = 0; i < 30; i++) {
                for (let j = 0; j < 60; j++) {
                    const cellIndex = i * 60 + j;
                    const cell = document.getElementById('targetGrid').children[cellIndex];
                    
                    // ××™×¤×•×¡ ××œ× ×©×œ ×›×œ ×”×¡×˜×™×™×œ×™×
                    cell.style.backgroundColor = targetGridData[i][j];
                    cell.style.border = '1px solid #e5e7eb';
                    cell.style.borderTop = '';
                    cell.style.borderRight = '';
                    cell.style.borderBottom = '';
                    cell.style.borderLeft = '';
                    cell.style.boxShadow = 'none';
                    cell.style.cursor = 'pointer';
                    cell.style.transform = '';
                    cell.style.transition = '';
                    cell.style.animation = '';
                    cell.style.zIndex = '';
                    cell.style.opacity = '1';
                }
            }
            
            clearTilePreview();
            clearTileDragPreview();
            updateGridTitle();
            showStatus('×›×œ ×”××¨×™×—×™× ×”×•×¡×¨×• - ×©×˜×— ×”×¨×™×¦×•×£ × ×©××¨', 'info');
        }

        // ×‘×“×™×§×ª ×”×©×œ××ª ×¨×™×¦×•×£
        function checkTilingComplete() {
            const targetCells = [];
            for (let i = 0; i < 30; i++) {
                for (let j = 0; j < 60; j++) {
                    if (targetGridData[i][j] !== '#ffffff') {
                        targetCells.push([i, j]);
                    }
                }
            }
            
            const tiledCells = [];
            placedTiles.forEach(tile => {
                tile.positions.forEach(pos => tiledCells.push(pos));
            });
            
            const allCovered = targetCells.every(([row, col]) => 
                tiledCells.some(([tRow, tCol]) => tRow === row && tCol === col)
            );
            
            if (allCovered && targetCells.length > 0) {
                showStatus('ğŸ‰ ××–×œ ×˜×•×‘! ×”×¨×™×¦×•×£ ×”×•×©×œ× ×‘×”×¦×œ×—×”!', 'complete');
            }
        }

        // ×”×¦×’×ª ×”×•×“×¢×ª ×¡×˜×˜×•×¡
        function showStatus(message, type) {
            const statusDiv = document.getElementById('tilingStatus');
            statusDiv.textContent = message;
            
            const colors = {
                success: 'bg-green-100 text-green-800',
                error: 'bg-red-100 text-red-800',
                info: 'bg-blue-100 text-blue-800',
                complete: 'bg-purple-100 text-purple-800'
            };
            
            statusDiv.className = `mt-4 p-2 rounded text-center text-sm font-medium ${colors[type] || colors.info}`;
        }

        // ×¡×™×‘×•×‘ ××¨×™×— × ×‘×—×¨
        function rotateSelectedTile() {
            if (!selectedTileForMove) {
                showStatus('××™×Ÿ ××¨×™×— × ×‘×—×¨ ×œ×¡×™×‘×•×‘', 'error');
                return;
            }
            
            // ×©××™×¨×ª ×”××¦×‘ ×œ×¤× ×™ ×”×©×™× ×•×™
            saveState();
            
            const { tile } = selectedTileForMove;
            
            // ××¦×™××ª ××¨×›×– ×”××¨×™×—
            const bounds = getTileBounds(tile.positions);
            const centerRow = (bounds.minRow + bounds.maxRow) / 2;
            const centerCol = (bounds.minCol + bounds.maxCol) / 2;
            
            // ×¡×™×‘×•×‘ ×›×œ ×ª× ×‘××¨×™×— 90 ××¢×œ×•×ª ×¡×‘×™×‘ ×”××¨×›×–
            const rotatedPositions = tile.positions.map(([row, col]) => {
                const newRow = Math.round(centerRow + (col - centerCol));
                const newCol = Math.round(centerCol - (row - centerRow));
                return [newRow, newCol];
            });
            
            // ×‘×“×™×§×” ×©×”××™×§×•× ×”×—×“×© ×ª×§×™×Ÿ
            const isValidRotation = rotatedPositions.every(([row, col]) => {
                // ×‘×“×™×§×ª ×’×‘×•×œ×•×ª
                if (row < 0 || row >= 30 || col < 0 || col >= 60) return false;
                
                // ×‘×“×™×§×” ×©×”××™×§×•× ×”×•× ×—×œ×§ ××”×©×˜×— ×”××™×•×¢×“
                if (targetGridData[row][col] === '#ffffff') return false;
                
                // ×‘×“×™×§×” ×©××™×Ÿ ××¨×™×— ××—×¨ ×‘××™×§×•× (×œ××¢×˜ ×”××¨×™×— ×”× ×•×›×—×™)
                const otherTileAtPosition = placedTiles.find((otherTile) => 
                    otherTile !== tile && 
                    otherTile.positions.some(([oRow, oCol]) => oRow === row && oCol === col)
                );
                
                return !otherTileAtPosition;
            });
            
            if (!isValidRotation) {
                showStatus('âŒ ×œ× × ×™×ª×Ÿ ×œ×¡×•×‘×‘ ××ª ×”××¨×™×— ×‘××™×§×•× ×”× ×•×›×—×™', 'error');
                return;
            }
            
            // ×¢×“×›×•×Ÿ ××™×§×•× ×”××¨×™×—
            tile.positions = rotatedPositions;
            
            // ×¢×“×›×•×Ÿ ×”×ª×¦×•×’×”
            updateGridDisplay();
            
            showStatus('ğŸ”„ ×”××¨×™×— ×¡×•×‘×‘ ×‘×”×¦×œ×—×”!', 'success');
            
            // ×‘×“×™×§×ª ×”×©×œ××ª ×¨×™×¦×•×£
            checkTilingComplete();
            saveState();
        }

        // ×”×™×¤×•×š ××¨×™×— × ×‘×—×¨
        function flipSelectedTile() {
            if (!selectedTileForMove) {
                showStatus('××™×Ÿ ××¨×™×— × ×‘×—×¨ ×œ×”×™×¤×•×š', 'error');
                return;
            }
            
            // ×©××™×¨×ª ×”××¦×‘ ×œ×¤× ×™ ×”×©×™× ×•×™
            saveState();
            
            const { tile } = selectedTileForMove;
            
            // ××¦×™××ª ×’×‘×•×œ×•×ª ×”××¨×™×—
            const bounds = getTileBounds(tile.positions);
            const centerCol = (bounds.minCol + bounds.maxCol) / 2;
            
            // ×”×™×¤×•×š ××•×¤×§×™ ×©×œ ×›×œ ×ª× ×‘××¨×™×—
            const flippedPositions = tile.positions.map(([row, col]) => {
                const newCol = Math.round(2 * centerCol - col);
                return [row, newCol];
            });
            
            // ×‘×“×™×§×” ×©×”××™×§×•× ×”×—×“×© ×ª×§×™×Ÿ
            const isValidFlip = flippedPositions.every(([row, col]) => {
                // ×‘×“×™×§×ª ×’×‘×•×œ×•×ª
                if (row < 0 || row >= 30 || col < 0 || col >= 60) return false;
                
                // ×‘×“×™×§×” ×©×”××™×§×•× ×”×•× ×—×œ×§ ××”×©×˜×— ×”××™×•×¢×“
                if (targetGridData[row][col] === '#ffffff') return false;
                
                // ×‘×“×™×§×” ×©××™×Ÿ ××¨×™×— ××—×¨ ×‘××™×§×•× (×œ××¢×˜ ×”××¨×™×— ×”× ×•×›×—×™)
                const otherTileAtPosition = placedTiles.find((otherTile) => 
                    otherTile !== tile && 
                    otherTile.positions.some(([oRow, oCol]) => oRow === row && oCol === col)
                );
                
                return !otherTileAtPosition;
            });
            
            if (!isValidFlip) {
                showStatus('âŒ ×œ× × ×™×ª×Ÿ ×œ×”×¤×•×š ××ª ×”××¨×™×— ×‘××™×§×•× ×”× ×•×›×—×™', 'error');
                return;
            }
            
            // ×¢×“×›×•×Ÿ ××™×§×•× ×”××¨×™×—
            tile.positions = flippedPositions;
            
            // ×¢×“×›×•×Ÿ ×”×ª×¦×•×’×”
            updateGridDisplay();
            
            showStatus('ğŸ”ƒ ×”××¨×™×— ×”×•×¤×š ×‘×”×¦×œ×—×”!', 'success');
            
            // ×‘×“×™×§×ª ×”×©×œ××ª ×¨×™×¦×•×£
            checkTilingComplete();
            saveState();
        }

        // ××—×™×§×ª ××¨×™×— × ×‘×—×¨
        function deleteSelectedTile() {
            if (!selectedTileForMove) {
                showStatus('××™×Ÿ ××¨×™×— × ×‘×—×¨ ×œ××—×™×§×”', 'error');
                return;
            }
            
            // ×©××™×¨×ª ×”××¦×‘ ×œ×¤× ×™ ×”×©×™× ×•×™
            saveState();
            
            const { index } = selectedTileForMove;
            const deletedTile = placedTiles[index];
            
            // ×”×¡×¨×ª ×”××¨×™×— ××”×¨×©×™××”
            placedTiles.splice(index, 1);
            
            // ××™×¤×•×¡ ×”×‘×—×™×¨×” ×•×”×¡×ª×¨×ª ×›×¤×ª×•×¨×™ ×”×¢×¨×™×›×”
            selectedTileForMove = null;
            const deleteBtn = document.getElementById('deleteTileBtn');
            const rotateBtn = document.getElementById('rotateTileBtn');
            const flipBtn = document.getElementById('flipTileBtn');
            deleteBtn.style.display = 'none';
            rotateBtn.style.display = 'none';
            flipBtn.style.display = 'none';
            
            // ×¢×“×›×•×Ÿ ×”×ª×¦×•×’×”
            updateGridDisplay();
            
            showStatus(`ğŸ—‘ï¸ ××¨×™×— × ××—×§! × ×•×ª×¨×• ${placedTiles.length} ××¨×™×—×™×`, 'success');
            
            // ×‘×“×™×§×” ×× ×¢×“×™×™×Ÿ ×‘××¦×‘ ×”×–×–×ª ××¨×™×—×™×
            if (tileMoveMode && placedTiles.length === 0) {
                toggleTileMoveMode(); // ×™×¦×™××” ×××¦×‘ ×”×–×–×” ×× ××™×Ÿ ××¨×™×—×™×
            } else if (tileMoveMode) {
                highlightMovableTiles(); // ×”×“×’×©×” ××—×“×© ×©×œ ×”××¨×™×—×™× ×”× ×•×ª×¨×™×
            }
        }

        // ×××–×™×Ÿ ××§×œ×“×ª ×œ×¤×¢×•×œ×•×ª ×¢×œ ××¨×™×— × ×‘×—×¨
        document.addEventListener('keydown', function(event) {
            // ×¤×¢×•×œ×•×ª ×¨×§ ×× ×™×© ××¨×™×— × ×‘×—×¨ ×•×× ×—× ×• ×‘××¦×‘ ×”×–×–×ª ××¨×™×—×™×
            if (selectedTileForMove && tileMoveMode) {
                switch(event.key.toLowerCase()) {
                    case 'delete':
                    case 'backspace':
                        event.preventDefault();
                        deleteSelectedTile();
                        break;
                    case 'r':
                        event.preventDefault();
                        rotateSelectedTile();
                        break;
                    case 'f':
                        event.preventDefault();
                        flipSelectedTile();
                        break;
                }
            }
        });

        // ××ª×—×•×œ ×”×™×™×©×•××•×Ÿ
        initGrids();
        initZoomControls();
        
        // ×©××™×¨×ª ×”××¦×‘ ×”×¨××©×•× ×™
        saveState();
        
        showStatus('×¢×¦×‘ ××ª ×”×©×˜×— ×•×”××¨×™×— ×©×œ×š ×•×œ×—×¥ "×”×ª×—×œ ×¨×™×¦×•×£"', 'info');
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'980fab8057400bed',t:'MTc1ODE4NjIwNC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
