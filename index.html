<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>יישומון ריצוף צורות</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --cell-size: 16px; /* base cell size; adjusted by zoom */
        }
        .grid-cell {
            width: var(--cell-size);
            height: var(--cell-size);
            border: 1px solid #e5e7eb;
            cursor: pointer;
            transition: all 0.1s;
        }
        .grid-cell:hover {
            border-color: #374151;
        }
        
        @keyframes pulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1.05);
            }
            50% {
                opacity: 0.8;
                transform: scale(1.02);
            }
        }
        .color-btn {
            width: 30px;
            height: 30px;
            border: 2px solid #374151;
            cursor: pointer;
            transition: all 0.2s;
        }
        .color-btn:hover {
            transform: scale(1.1);
        }
        .color-btn.selected {
            border-width: 3px;
            border-color: #000;
        }
        .tile-cell {
            width: var(--cell-size);
            height: var(--cell-size);
            border: 1px solid #d1d5db;
            cursor: pointer;
            transition: all 0.1s;
        }
        .tile-cell:hover {
            border-color: #374151;
        }
        .control-btn {
            background: #3b82f6;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        .control-btn:hover {
            background: #2563eb;
            transform: translateY(-1px);
        }
        .control-btn:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
        }
        
        /* סטיילים רספונסיביים למובייל */
        @media (max-width: 768px) {
            .max-w-7xl {
                max-width: 100%;
                padding: 0 5px;
            }
            
            .bg-white {
                margin: 0 2px 10px 2px;
                padding: 10px 8px;
            }
            
            .flex {
                flex-wrap: wrap;
                gap: 4px;
                justify-content: center;
            }
            
            .control-btn {
                padding: 4px 8px;
                font-size: 10px;
                min-width: auto;
                white-space: nowrap;
            }
            
            .color-btn {
                width: 20px;
                height: 20px;
            }
            
            input[type="number"] {
                width: 40px;
                padding: 2px;
                font-size: 10px;
            }
            
            .text-3xl {
                font-size: 1.2rem;
                margin-bottom: 10px;
            }
            
            :root {
                --cell-size: 8px; /* smaller default on tablets/phones */
            }
            .grid-cell, .tile-cell {
                border-width: 0.5px;
            }
            
            #targetGrid {
                max-height: 200px;
                overflow: auto;
                width: 100%;
                max-width: calc(100vw - 20px);
            }
            
            .flex-1 {
                width: 100%;
                margin-top: 10px;
            }
            
            .gap-6 {
                gap: 0;
                flex-direction: column;
            }
            
            /* התאמה מיוחדת לגריד במובייל */
            #targetGrid .grid-cell {
                min-width: 4px;
                min-height: 4px;
            }
            
            /* התאמת כפתורים למובייל */
            .flex.items-center.gap-3 {
                gap: 2px;
                flex-wrap: wrap;
                justify-content: center;
            }
            
            .flex.items-center.gap-2 {
                gap: 1px;
                flex-wrap: wrap;
                justify-content: center;
            }
            
            .flex.gap-2 {
                gap: 2px;
                flex-wrap: wrap;
                justify-content: center;
            }
        }
        
        @media (max-width: 480px) {
            .max-w-7xl {
                padding: 0 2px;
            }
            
            :root {
                --cell-size: 6px; /* smallest default on narrow phones */
            }
            .grid-cell, .tile-cell {
                border-width: 0.5px;
            }
            
            .control-btn {
                padding: 3px 6px;
                font-size: 9px;
            }
            
            .color-btn {
                width: 18px;
                height: 18px;
            }
            
            #targetGrid {
                max-height: 150px;
                max-width: calc(100vw - 10px);
            }
            
            input[type="number"] {
                width: 35px;
                padding: 1px;
                font-size: 9px;
            }
        }
    </style>
</head>
<body class="bg-gray-50 p-6 font-sans">
    <div class="max-w-7xl mx-auto">
        <h1 class="text-3xl font-bold text-center mb-8 text-gray-800">יישומון ריצוף צורות מאת ים רון</h1>
        
        <!-- כלי בקרה עליונים -->
        <div class="bg-white p-4 rounded-lg shadow-lg mb-6">
            <div class="flex flex-wrap items-center justify-center gap-6">
                <!-- פלטת צבעים -->
                <div class="flex items-center gap-3">
                    <span class="text-sm font-medium text-gray-700">צבע:</span>
                    <div class="flex gap-2">
                        <div class="color-btn selected" style="background-color: #fecaca" data-color="#fecaca"></div>
                        <div class="color-btn" style="background-color: #bfdbfe" data-color="#bfdbfe"></div>
                        <div class="color-btn" style="background-color: #bbf7d0" data-color="#bbf7d0"></div>
                        <div class="color-btn" style="background-color: #fde68a" data-color="#fde68a"></div>
                        <div class="color-btn" style="background-color: #ddd6fe" data-color="#ddd6fe"></div>
                        <div class="color-btn" style="background-color: #fbcfe8" data-color="#fbcfe8"></div>
                        <div class="color-btn" style="background-color: #ffffff; border-color: #374151" data-color="#ffffff"></div>
                    </div>
                </div>
                
                <!-- יצירת שטח אוטומטי -->
                <div class="flex items-center gap-2">
                    <span class="text-sm font-medium text-gray-700">יצירת שטח:</span>
                    <input type="number" id="shapeWidth" value="10" min="1" max="30" class="w-16 px-2 py-1 border border-gray-300 rounded text-center">
                    <span class="text-xs text-gray-500">×</span>
                    <input type="number" id="shapeHeight" value="10" min="1" max="30" class="w-16 px-2 py-1 border border-gray-300 rounded text-center">
                    <button class="control-btn bg-purple-600 hover:bg-purple-700" onclick="createAutoShape()">צור שטח ריצוף</button>
                    <button class="control-btn bg-orange-600 hover:bg-orange-700" onclick="finishShapeCreation()">סיים יצירת שטח</button>
                    <button class="control-btn bg-red-600 hover:bg-red-700" id="deleteShapeBtn" onclick="deleteSelectedShape()" style="display: none;">🗑️ מחק שטח</button>
                </div>
                
                <!-- כפתורי בקרה -->
                <div class="flex gap-2">
                    <button class="control-btn" onclick="clearTarget()">נקה שטח</button>
                    <button class="control-btn" onclick="clearTile()">נקה אריח</button>
                    <button class="control-btn" onclick="rotateTile()">סובב 90°</button>
                    <button class="control-btn" onclick="flipTile()">הפוך</button>
                </div>
                
                <!-- כפתורי ריצוף -->
                <div class="flex gap-2">
                    <button class="control-btn bg-green-600 hover:bg-green-700" onclick="startTiling()">התחל ריצוף</button>
                    <button class="control-btn bg-red-600 hover:bg-red-700" onclick="stopTiling()">בטל ריצוף</button>
                    <button class="control-btn bg-yellow-600 hover:bg-yellow-700" onclick="toggleTileMoveMode()">🔄 הזזת אריחים</button>
                    <button class="control-btn bg-red-500 hover:bg-red-600" onclick="deleteSelectedTile()" id="deleteTileBtn" style="display: none;">🗑️ מחק אריח</button>
                    <button class="control-btn bg-blue-500 hover:bg-blue-600" onclick="rotateSelectedTile()" id="rotateTileBtn" style="display: none;">🔄 סובב אריח</button>
                    <button class="control-btn bg-green-500 hover:bg-green-600" onclick="flipSelectedTile()" id="flipTileBtn" style="display: none;">🔃 הפוך אריח</button>
                    <button class="control-btn" onclick="clearTiling()">נקה ריצוף</button>
                </div>
                
                <!-- כפתורי ביטול וחזרה -->
                <div class="flex gap-2">
                    <button class="control-btn bg-gray-600 hover:bg-gray-700" onclick="undo()" id="undoBtn">↶ ביטול</button>
                    <button class="control-btn bg-gray-600 hover:bg-gray-700" onclick="redo()" id="redoBtn">↷ חזרה</button>
                    <button class="control-btn bg-indigo-600 hover:bg-indigo-700" onclick="showInstructions()">📖 הוראות שימוש</button>
                </div>
            </div>
            
            <!-- סטטוס -->
            <div id="tilingStatus" class="mt-3 p-2 rounded text-center text-sm font-medium"></div>
        </div>
        
        <div class="flex gap-6">
            <!-- עיצוב האריח -->
            <div class="bg-white p-4 rounded-lg shadow-lg">
                <h3 class="text-lg font-bold mb-3 text-gray-700 text-center">עיצוב האריח</h3>
                
                <!-- גריד עיצוב האריח -->
                <div class="border-2 border-gray-300 p-2 bg-white inline-block mb-3">
                    <div id="tileGrid" class="grid gap-0" style="grid-template-columns: repeat(10, var(--cell-size));"></div>
                </div>
                
                <!-- תצוגת כל תצורות האריח -->
                <div class="text-center">
                    <p class="text-sm text-gray-600 mb-2">כל תצורות האריח:</p>
                    <div id="allTileVariations" class="flex flex-wrap gap-2 justify-center max-w-xs"></div>
                </div>
            </div>
            
            <!-- שטח היעד -->
            <div class="bg-white p-4 rounded-lg shadow-lg flex-1">
                <h3 id="gridTitle" class="text-lg font-bold mb-3 text-gray-700 text-center">שטח הריצוף (30×60)</h3>
                
                <!-- גריד היעד -->
                <div class="border-2 border-gray-300 p-2 bg-white inline-block overflow-auto max-h-96">
                    <div id="targetGrid" class="grid gap-0" style="grid-template-columns: repeat(60, var(--cell-size));"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- חלון הוראות שימוש -->
    <div id="instructionsModal" class="fixed inset-0 bg-black bg-opacity-50 z-50 hidden flex items-center justify-center p-4">
        <div class="bg-white rounded-lg max-w-4xl max-h-[90vh] overflow-y-auto p-6 relative">
            <button onclick="hideInstructions()" class="absolute top-4 left-4 text-gray-500 hover:text-gray-700 text-2xl font-bold">×</button>
            
            <h2 class="text-2xl font-bold text-center mb-6 text-gray-800">📖 הוראות שימוש ביישומון ריצוף צורות</h2>
            
            <div class="space-y-6 text-right">
                <div class="bg-blue-50 p-4 rounded-lg">
                    <h3 class="text-lg font-bold text-blue-800 mb-2">🎯 מטרת היישומון</h3>
                    <p class="text-gray-700">יישומון זה מאפשר לך ליצור שטחי ריצוף מותאמים אישית ולרצף אותם באמצעות אריחים שעיצבת בעצמך.</p>
                </div>
                
                <div class="bg-green-50 p-4 rounded-lg">
                    <h3 class="text-lg font-bold text-green-800 mb-3">🏗️ שלב 1: יצירת שטח ריצוף</h3>
                    <ul class="space-y-2 text-gray-700">
                        <li><strong>יצירה אוטומטית:</strong> הזן רוחב וגובה (1-30) ולחץ "צור שטח ריצוף" ליצירת מלבן צבעוני</li>
                        <li><strong>יצירה ידנית:</strong> בחר צבע ולחץ על תאים בגריד הימני ליצירת צורות חופשיות (רק במצב יצירת שטח)</li>
                        <li><strong>גרירה:</strong> ניתן לגרור שטחים קיימים למיקומים חדשים על ידי לחיצה וגרירה בתוך השטח</li>
                        <li><strong>שכבות:</strong> שטחים יכולים לחפוף זה את זה - השטח האחרון שנוצר יהיה עליון</li>
                        <li><strong>צבעים:</strong> כל שטח נוצר בצבע שנבחר בפלטת הצבעים</li>
                        <li><strong>מחיקת שטח:</strong> כששטח נבחר במצב יצירת שטח יופיע כפתור "🗑️ מחק שטח" למחיקתו</li>
                        <li><strong>ציור ידני נשמר:</strong> ריבועים בודדים שציירת ידנית נשמרים גם כשמזיזים או מוחקים שטחים אוטומטיים</li>
                        <li><strong>חשוב:</strong> חובה ללחוץ "סיים יצירת שטח" לפני מעבר לריצוף!</li>
                    </ul>
                </div>
                
                <div class="bg-purple-50 p-4 rounded-lg">
                    <h3 class="text-lg font-bold text-purple-800 mb-3">🧩 שלב 2: עיצוב האריח</h3>
                    <ul class="space-y-2 text-gray-700">
                        <li><strong>עיצוב:</strong> לחץ על תאים בגריד השמאלי (10×10) ליצירת צורת האריח - תאים נבחרים יהיו אפורים</li>
                        <li><strong>סיבוב:</strong> לחץ "סובב 90°" לסיבוב האריח בכיוון השעון</li>
                        <li><strong>היפוך:</strong> לחץ "הפוך" להיפוך האריח אופקית</li>
                        <li><strong>תצוגה:</strong> כל תצורות האריח (בסיס, סיבובים, היפוכים) מוצגות למטה עם תוויות</li>
                        <li><strong>בחירה:</strong> לחץ על אחת מהתצורות למטה לבחירת האריח הפעיל לריצוף</li>
                        <li><strong>ניקוי:</strong> לחץ "נקה אריח" למחיקת עיצוב האריח הנוכחי</li>
                    </ul>
                </div>
                
                <div class="bg-orange-50 p-4 rounded-lg">
                    <h3 class="text-lg font-bold text-orange-800 mb-3">🎨 שלב 3: ריצוף השטח</h3>
                    <ul class="space-y-2 text-gray-700">
                        <li><strong>התחלה:</strong> לחץ "התחל ריצוף" (רק אחרי לחיצה על "סיים יצירת שטח"!)</li>
                        <li><strong>תצוגה מקדימה:</strong> העבר עכבר על הגריד לראות איפה האריח יונח - ירוק = תקין, אדום = לא תקין</li>
                        <li><strong>הנחה:</strong> לחץ במיקום הרצוי להנחת האריח - האריח יקבל צבע אוטומטי</li>
                        <li><strong>הזזה:</strong> לחץ "🔄 הזזת אריחים", בחר אריח (יהבהב באדום) וגרור/לחץ למיקום חדש. הסמן מיושר למרכז האריח</li>
                        <li><strong>סיבוב:</strong> במצב הזזת אריחים, בחר אריח ולחץ "🔄 סובב אריח" או מקש R</li>
                        <li><strong>היפוך:</strong> במצב הזזת אריחים, בחר אריח ולחץ "🔃 הפוך אריח" או מקש F</li>
                        <li><strong>מחיקה:</strong> במצב הזזת אריחים, בחר אריח ולחץ "🗑️ מחק אריח" או Delete/Backspace</li>
                        <li><strong>ניקוי:</strong> "נקה ריצוף" מסיר את כל האריחים אבל שומר על השטחים</li>
                        <li><strong>ביטול ריצוף:</strong> "בטל ריצוף" חוזר למצב עיצוב רגיל</li>
                        <li><strong>השלמה:</strong> כשכל השטח הצבעוני מכוסה באריחים תקבל הודעת הצלחה!</li>
                        <li><strong>חשוב:</strong> אריחים מונחים רק על שטחים צבעוניים ולא יכולים לחפוף</li>
                        <li><strong>מובייל/דסקטופ:</strong> גרירת האריח נעצרת בשחרור, אין צורך בהקשה נוספת</li>
                    </ul>
                </div>
                
                <div class="bg-gray-50 p-4 rounded-lg">
                    <h3 class="text-lg font-bold text-gray-800 mb-3">⚙️ כלים נוספים</h3>
                    <ul class="space-y-2 text-gray-700">
                        <li><strong>ביטול/חזרה:</strong> כפתורי ↶ ו-↷ לביטול וחזרה על פעולות (עד 50 פעולות)</li>
                        <li><strong>ניקוי שטח:</strong> "נקה שטח" מוחק את כל השטחים והאריחים</li>
                        <li><strong>ניקוי אריח:</strong> "נקה אריח" מוחק רק את עיצוב האריח בגריד השמאלי</li>
                        <li><strong>ניקוי ריצוף:</strong> "נקה ריצוף" מוחק רק את האריחים המונחים, שומר על השטחים</li>
                        <li><strong>צבעים:</strong> 7 צבעים זמינים לשטחים - כל שטח נוצר בצבע הנבחר</li>
                        <li><strong>צבעי אריחים:</strong> אריחים מקבלים צבעים אוטומטיים מגוונים לפי סדר ההנחה</li>
                    </ul>
                </div>
                
                <div class="bg-red-50 p-4 rounded-lg">
                    <h3 class="text-lg font-bold text-red-800 mb-3">⚠️ הערות חשובות</h3>
                    <ul class="space-y-2 text-gray-700">
                        <li><strong>סדר פעולות:</strong> יצירת שטח → סיום יצירת שטח → עיצוב אריח → התחלת ריצוף</li>
                        <li><strong>מגבלות מיקום:</strong> אריחים מונחים רק על שטחים צבעוניים (לא על רקע לבן)</li>
                        <li><strong>אי-חפיפה:</strong> אריחים לא יכולים לחפוף זה את זה או לצאת מגבולות הגריד</li>
                        <li><strong>שמירת נתונים:</strong> השטחים נשמרים גם אחרי ניקוי הריצוף, וציור ידני נשמר גם אחרי הזזת שטחים</li>
                        <li><strong>אופן הנחה:</strong> אריחים מונחים בלחיצה פשוטה - אין צורך בגרירה</li>
                        <li><strong>גרירת שטחים:</strong> ניתן לגרור שטחים רק במצב יצירת שטח</li>
                        <li><strong>עריכת אריחים:</strong> ניתן לגרור, לסובב ולהפוך אריחים רק במצב הזזת אריחים</li>
                        <li><strong>מקשי קיצור:</strong> R לסיבוב, F להיפוך, Delete/Backspace למחיקה (רק כשאריח נבחר)</li>
                    </ul>
                </div>
            </div>
            
            <div class="text-center mt-6">
                <button onclick="hideInstructions()" class="control-btn bg-blue-600 hover:bg-blue-700">הבנתי - בואו נתחיל!</button>
            </div>
        </div>
    </div>

    <!-- שורת זכויות יוצרים -->
    <div class="text-center mt-6 py-2 text-xs text-gray-400 border-t border-gray-200">
        כל הזכויות שמורות לאושרת וים רון
    </div>

    <script>
        let selectedColor = '#fecaca';
        let targetGridData = [];
        let tileGridData = [];
        let currentTile = [];
        let tilingMode = false;
        let placedTiles = [];
        let previewPosition = null;
        let shapeCreationMode = false;
        let isDragging = false;
        let dragStartPos = null;
        let createdShapes = [];
        // שכבת ציור ידני שתישמר גם כשמזיזים שטחים אוטומטיים
        let manualPaintLayer = [];
        let draggedShape = null;
        let selectedShape = null; // בחירת שטח אוטומטי לעריכה/מחיקה
        let removeMode = false;
        let actionHistory = [];
        let historyIndex = -1;
        let tileMoveMode = false;
        let selectedTileForMove = null;
        let draggedTile = null;

        // Zoom controls for grid and tiles
        let zoom = 1;
        const zoomMin = 0.5;
        const zoomMax = 3.0;
        const zoomStep = 0.1;
        let baseCellSize = null; // detected from CSS variable on load

        function initZoomControls() {
            const root = document.documentElement;
            const raw = getComputedStyle(root).getPropertyValue('--cell-size').trim();
            const numeric = parseFloat(raw || '16');
            baseCellSize = isNaN(numeric) ? 16 : numeric;

            // Ensure controls exist; if not, create them in the top toolbar
            let slider = document.getElementById('zoomSlider');
            let zoomOutBtn = document.getElementById('zoomOutBtn');
            let zoomInBtn = document.getElementById('zoomInBtn');
            let zoomValue = document.getElementById('zoomValue');

            if (!slider || !zoomOutBtn || !zoomInBtn || !zoomValue) {
                const toolbar = document.querySelector('.bg-white.p-4.rounded-lg.shadow-lg.mb-6 .flex.flex-wrap.items-center.justify-center.gap-6');
                if (toolbar) {
                    const wrap = document.createElement('div');
                    wrap.className = 'flex items-center gap-2';
                    wrap.innerHTML = `
                        <span class="text-sm font-medium text-gray-700">זום:</span>
                        <button id="zoomOutBtn" class="control-btn" title="Zoom Out">-</button>
                        <input id="zoomSlider" type="range" min="0.5" max="3" step="0.1" value="1" class="w-40 align-middle" />
                        <button id="zoomInBtn" class="control-btn" title="Zoom In">+</button>
                        <span id="zoomValue" class="text-sm text-gray-600">100%</span>
                    `;
                    toolbar.appendChild(wrap);
                }
                // re-query after injection
                slider = document.getElementById('zoomSlider');
                zoomOutBtn = document.getElementById('zoomOutBtn');
                zoomInBtn = document.getElementById('zoomInBtn');
                zoomValue = document.getElementById('zoomValue');
            }

            function applyZoom() {
                const size = (baseCellSize * zoom).toFixed(2) + 'px';
                root.style.setProperty('--cell-size', size);
                if (slider) slider.value = String(zoom);
                if (zoomValue) zoomValue.textContent = Math.round(zoom * 100) + '%';
            }

            function setZoom(z) {
                zoom = Math.min(zoomMax, Math.max(zoomMin, z));
                applyZoom();
            }

            // expose setter for keyboard handler
            window.__setZoom = setZoom;

            // init UI with current zoom
            applyZoom();

            if (slider) slider.addEventListener('input', (e) => {
                const v = parseFloat(e.target.value);
                if (!isNaN(v)) setZoom(v);
            });
            if (zoomOutBtn) zoomOutBtn.addEventListener('click', () => {
                setZoom(Math.round((zoom - zoomStep) * 10) / 10);
            });
            if (zoomInBtn) zoomInBtn.addEventListener('click', () => {
                setZoom(Math.round((zoom + zoomStep) * 10) / 10);
            });

            const targetGridEl = document.getElementById('targetGrid');
            if (targetGridEl) {
                targetGridEl.addEventListener('wheel', (e) => {
                    if (e.ctrlKey || e.altKey) {
                        e.preventDefault();
                        const dir = e.deltaY > 0 ? -1 : 1;
                        setZoom(Math.round((zoom + dir * zoomStep) * 10) / 10);
                    }
                }, { passive: false });
            }
        }

        // keyboard +/- zoom (skip when typing in inputs)
        document.addEventListener('keydown', function(evt){
            const tag = (evt.target && evt.target.tagName || '').toLowerCase();
            if (tag === 'input' || tag === 'textarea' || evt.metaKey || evt.ctrlKey) return;
            if (evt.key === '+' || evt.key === '=') { evt.preventDefault(); if (window.__setZoom) window.__setZoom(zoom + zoomStep); }
            if (evt.key === '-' || evt.key === '_') { evt.preventDefault(); if (window.__setZoom) window.__setZoom(zoom - zoomStep); }
        });


        // אתחול הגרידים
        function initGrids() {
            // גריד היעד 30x60
            const targetGrid = document.getElementById('targetGrid');
            targetGridData = Array(30).fill().map(() => Array(60).fill('#ffffff'));
            manualPaintLayer = Array(30).fill().map(() => Array(60).fill(null));
            
            for (let i = 0; i < 30; i++) {
                for (let j = 0; j < 60; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.style.backgroundColor = '#ffffff';
                    cell.onclick = () => paintTargetCell(i, j);
                    cell.onmousedown = (e) => handleMouseDown(i, j, e);
                    cell.ontouchstart = (e) => {
                        e.preventDefault();
                        handleMouseDown(i, j, e);
                    };
                    cell.onmouseenter = () => {
                        if (tilingMode && currentTile.length > 0) {
                            showTilePreview(i, j);
                        } else if (isDragging && shapeCreationMode) {
                            handleDrag(i, j);
                        } else if (tileMoveMode && selectedTileForMove) {
                            // תצוגה מקדימה חלקה בזמן גרירת אריח
                            showSmoothTileDragPreview(i, j);
                        }
                    };
                    cell.onmouseleave = () => {
                        if (tilingMode) {
                            clearTilePreview();
                        }
                    };
                    
                    // מאזיני מגע משופרים לגרירה חלקה
                    let cellTouchStartTime = 0;
                    let cellTouchMoved = false;
                    let cellTouchStartPos = null;
                    
                    cell.ontouchstart = (e) => {
                        e.preventDefault();
                        cellTouchStartTime = Date.now();
                        cellTouchMoved = false;
                        cellTouchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                        handleMouseDown(i, j, e);
                    };
                    
                    cell.ontouchmove = (e) => {
                        e.preventDefault();
                        const touch = e.touches[0];
                        
                        // בדיקת מרחק גרירה
                        if (cellTouchStartPos) {
                            const deltaX = Math.abs(touch.clientX - cellTouchStartPos.x);
                            const deltaY = Math.abs(touch.clientY - cellTouchStartPos.y);
                            if (deltaX > dragThreshold || deltaY > dragThreshold) {
                                cellTouchMoved = true;
                            }
                        }
                        
                        const element = document.elementFromPoint(touch.clientX, touch.clientY);
                        if (element && element.classList.contains('grid-cell')) {
                            const cellIndex = Array.from(element.parentNode.children).indexOf(element);
                            const touchRow = Math.floor(cellIndex / 60);
                            const touchCol = cellIndex % 60;
                            
                            if (tilingMode && currentTile.length > 0) {
                                showTilePreview(touchRow, touchCol);
                            } else if (isDragging && shapeCreationMode) {
                                handleDrag(touchRow, touchCol);
                            } else if (tileMoveMode && selectedTileForMove) {
                                // גרירה אוטומטית של אריח במובייל
                                if (cellTouchMoved) {
                                    moveTileToPositionAuto(touchRow, touchCol);
                                } else {
                                    showSmoothTileDragPreview(touchRow, touchCol);
                                }
                            }
                        }
                    };
                    
                    cell.ontouchend = (e) => {
                        e.preventDefault();
                        const touchDuration = Date.now() - cellTouchStartTime;
                        
                        // אם זה היה טאפ קצר (לא גרירה), בצע את הפעולה המתאימה
                        if (!cellTouchMoved && touchDuration < 500) {
                            if (tilingMode) {
                                placeTileAt(i, j);
                            } else if (tileMoveMode) {
                                if (selectedTileForMove) {
                                    // במובייל - הזזה אוטומטית ללא צורך בלחיצה נוספת
                                    moveTileToPositionAuto(i, j);
                                } else {
                                    selectTileForMove(i, j);
                                }
                            } else if (shapeCreationMode) {
                                paintTargetCell(i, j);
                            }
                        } else if (cellTouchMoved) {
                            // אם היתה גרירה, הפעולה כבר בוצעה במהלך touchmove
                            if (tileMoveMode && selectedTileForMove) {
                                // שמירת המצב החדש אחרי הגרירה
                                saveState();
                                
                                // איפוס הבחירה אחרי הזזה מוצלחת
                                selectedTileForMove = null;
                                const deleteBtn = document.getElementById('deleteTileBtn');
                                deleteBtn.style.display = 'none';
                                clearTileDragPreview();
                                showStatus('האריח הוזז בהצלחה!', 'success');
                                checkTilingComplete();
                            } else if (shapeCreationMode && draggedShape) {
                                // שמירת מצב אחרי גרירת שטח
                                saveState();
                            }
                        }
                        
                        handleMouseUp();
                        clearTilePreview();
                        cellTouchStartPos = null;
                    };
                    targetGrid.appendChild(cell);
                }
            }
            
            // גריד עיצוב האריח 10x10
            const tileGrid = document.getElementById('tileGrid');
            tileGridData = Array(10).fill().map(() => Array(10).fill(false));
            
            for (let i = 0; i < 10; i++) {
                for (let j = 0; j < 10; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'tile-cell';
                    cell.style.backgroundColor = '#ffffff';
                    cell.onclick = () => toggleTileCell(i, j);
                    
                    // הוספת תמיכה במגע לגריד האריח
                    cell.ontouchstart = (e) => {
                        e.preventDefault();
                    };
                    
                    cell.ontouchend = (e) => {
                        e.preventDefault();
                        toggleTileCell(i, j);
                    };
                    
                    tileGrid.appendChild(cell);
                }
            }
            
            updateCurrentTile();
            
            // הוספת מאזיני עכבר ומגע גלובליים
            document.addEventListener('mouseup', handleMouseUp);
            document.addEventListener('touchend', handleMouseUp);
            document.addEventListener('touchcancel', handleMouseUp);
        }

        // בחירת צבע עם תמיכה במגע
        document.querySelectorAll('.color-btn').forEach(btn => {
            btn.onclick = () => {
                document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                selectedColor = btn.dataset.color;
            };
            
            // תמיכה במגע
            btn.ontouchend = (e) => {
                e.preventDefault();
                document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                selectedColor = btn.dataset.color;
            };
        });

        // פונקציות טיפול בעכבר ומגע
        let touchStartTime = 0;
        let touchMoved = false;
        let lastTouchPos = null;
        let dragThreshold = 5; // מינימום פיקסלים לזיהוי גרירה

        function handleMouseDown(row, col, e) {
            if (shapeCreationMode) {
                // בדיקה אם לוחצים על שטח קיים
                const clickedShape = findShapeAtPosition(row, col);
                if (clickedShape) {
                    // תמיד מאפשר גרירה של שטח קיים
                    isDragging = true;
                    draggedShape = clickedShape;
                    selectedShape = clickedShape;
                    const deleteShapeBtn = document.getElementById('deleteShapeBtn');
                    if (deleteShapeBtn) deleteShapeBtn.style.display = 'inline-block';
                    
                    // שמירת המיקום המדויק של הלחיצה בתוך השטח
                    dragStartPos = [row, col];
                    
                    // הזזת השטח לשכבה העליונה
                    const shapeIndex = createdShapes.indexOf(clickedShape);
                    if (shapeIndex > -1) {
                        createdShapes.splice(shapeIndex, 1);
                        createdShapes.push(clickedShape);
                    }
                } else {
                    // יצירת שטח חדש בגרירה
                    isDragging = true;
                    dragStartPos = [row, col];
                    selectedShape = null;
                    const deleteShapeBtn = document.getElementById('deleteShapeBtn');
                    if (deleteShapeBtn) deleteShapeBtn.style.display = 'none';
                }
                
                // שמירת נתוני מגע
                if (e.touches && e.touches[0]) {
                    lastTouchPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    touchStartTime = Date.now();
                    touchMoved = false;
                }
                
                e.preventDefault();
            }
        }

        function handleMouseUp() {
            if (isDragging && draggedShape) {
                // סיום גרירה - עדכון סופי של המיקום
                updateGridDisplay();
                saveState(); // שמירת המצב החדש
            }
            isDragging = false;
            dragStartPos = null;
            draggedShape = null;
            lastTouchPos = null;
            touchMoved = false;
            // אחרי שחרור, כפתור מחיקת שטח נשאר אם יש בחירה
            const deleteShapeBtn = document.getElementById('deleteShapeBtn');
            if (deleteShapeBtn) deleteShapeBtn.style.display = selectedShape ? 'inline-block' : 'none';
        }

        function handleDrag(row, col) {
            if (!isDragging || !dragStartPos) return;
            
            if (draggedShape) {
                // גרירת שטח קיים - השטח יזוז כך שהתא שלחצנו עליו יישאר תחת הסמן
                const deltaRow = row - dragStartPos[0];
                const deltaCol = col - dragStartPos[1];
                
                // חישוב המיקום החדש של כל תא בשטח
                const newCells = draggedShape.cells.map(([r, c]) => [r + deltaRow, c + deltaCol]);
                
                // בדיקה שכל התאים החדשים בתוך הגבולות
                const isValidMove = newCells.every(([r, c]) => 
                    r >= 0 && r < 30 && c >= 0 && c < 60
                );
                
                if (isValidMove) {
                    // עדכון המיקום החדש מיידית
                    draggedShape.cells = newCells;
                    
                    // עדכון מיידי של התצוגה עם אפקט ויזואלי חלק
                    updateGridDisplaySmooth();
                    
                    // עדכון dragStartPos למיקום הנוכחי כדי שהגרירה תהיה חלקה
                    dragStartPos = [row, col];
                }
            } else {
                // יצירת שטח חדש
                const startRow = Math.min(dragStartPos[0], row);
                const endRow = Math.max(dragStartPos[0], row);
                const startCol = Math.min(dragStartPos[1], col);
                const endCol = Math.max(dragStartPos[1], col);
                
                // צביעת האזור הנגרר עם אפקט חלק
                for (let i = startRow; i <= endRow; i++) {
                    for (let j = startCol; j <= endCol; j++) {
                        // ציור ידני בזמן גרירה נשמר כשכבה ידנית
                        manualPaintLayer[i][j] = selectedColor;
                        targetGridData[i][j] = selectedColor;
                        const cellIndex = i * 60 + j;
                        const cell = document.getElementById('targetGrid').children[cellIndex];
                        cell.style.backgroundColor = selectedColor;
                        cell.style.border = '2px solid #374151';
                        cell.style.transition = 'all 0.1s ease'; // אפקט מעבר חלק
                    }
                }
            }
        }

        // עדכון תצוגה חלק לגרירה
        function updateGridDisplaySmooth() {
            // עדכון targetGridData תחילה לפי השטחים הקיימים
            for (let i = 0; i < 30; i++) {
                for (let j = 0; j < 60; j++) {
                    targetGridData[i][j] = '#ffffff'; // איפוס לרקע לבן
                }
            }
            
            // עדכון targetGridData לפי השטחים הקיימים (לפי סדר יצירה)
            createdShapes.forEach(shape => {
                shape.cells.forEach(([row, col]) => {
                    targetGridData[row][col] = shape.color;
                });
            });

            // החלת שכבת ציור ידני מעל השטחים (כמו ב-updateGridDisplay)
            for (let i = 0; i < 30; i++) {
                for (let j = 0; j < 60; j++) {
                    if (manualPaintLayer[i][j]) {
                        targetGridData[i][j] = manualPaintLayer[i][j];
                    }
                }
            }

            // החלת שכבת ציור ידני מעל השטחים - לא למחוק ידני בעת הזזת שטחים
            for (let i = 0; i < 30; i++) {
                for (let j = 0; j < 60; j++) {
                    if (manualPaintLayer[i][j]) {
                        targetGridData[i][j] = manualPaintLayer[i][j];
                    }
                }
            }
            
            // עכשיו עדכון התצוגה הויזואלית עם אפקטים חלקים
            for (let i = 0; i < 30; i++) {
                for (let j = 0; j < 60; j++) {
                    const cellIndex = i * 60 + j;
                    const cell = document.getElementById('targetGrid').children[cellIndex];
                    
                    // איפוס כל הסטיילים
                    cell.style.backgroundColor = targetGridData[i][j];
                    cell.style.border = '1px solid #e5e7eb';
                    cell.style.transition = 'all 0.05s ease'; // מעבר מהיר וחלק
                    
                    // בורדר מיוחד במצב יצירת שטח
                    if (shapeCreationMode && targetGridData[i][j] !== '#ffffff') {
                        cell.style.border = '2px solid #374151';
                    }
                }
            }
            
            // עדכון אריחים מונחים (תמיד בשכבה העליונה)
            placedTiles.forEach(tile => {
                tile.positions.forEach(([row, col]) => {
                    const cellIndex = row * 60 + col;
                    const cell = document.getElementById('targetGrid').children[cellIndex];
                    cell.style.backgroundColor = tile.color || '#0ea5e9';
                    cell.style.transition = 'all 0.05s ease';
                    
                    // קביעת הבורדר
                    const isEdge = isEdgeOfTile(row, col, tile.positions);
                    const borderColor = tile.borderColor || '#075985';
                    
                    cell.style.borderTop = isEdge.top ? `2px solid ${borderColor}` : '1px solid #ffffff';
                    cell.style.borderRight = isEdge.right ? `2px solid ${borderColor}` : '1px solid #ffffff';
                    cell.style.borderBottom = isEdge.bottom ? `2px solid ${borderColor}` : '1px solid #ffffff';
                    cell.style.borderLeft = isEdge.left ? `2px solid ${borderColor}` : '1px solid #ffffff';
                });
            });
            
            // הדגשה במצב הזזת אריחים
            if (tileMoveMode) {
                highlightMovableTiles();
            }
        }

        // מציאת שטח במיקום - השטח העליון ביותר
        function findShapeAtPosition(row, col) {
            // חיפוש מהשטח האחרון (העליון) לראשון
            for (let i = createdShapes.length - 1; i >= 0; i--) {
                const shape = createdShapes[i];
                if (shape.cells.some(([r, c]) => r === row && c === col)) {
                    return shape;
                }
            }
            return null;
        }
        // מחיקת שטח אוטומטי נבחר
        function deleteSelectedShape() {
            if (!selectedShape) {
                showStatus('אין שטח נבחר למחיקה', 'error');
                return;
            }
            // שמירת מצב
            saveState();

            // הסרת השטח מהמערך
            const idx = createdShapes.indexOf(selectedShape);
            if (idx >= 0) {
                createdShapes.splice(idx, 1);
            }

            // ניקוי הבחירה והסתרת כפתור מחיקה
            selectedShape = null;
            const deleteShapeBtn = document.getElementById('deleteShapeBtn');
            if (deleteShapeBtn) deleteShapeBtn.style.display = 'none';

            // רענון התצוגה - שכבת הידני תישמר
            updateGridDisplay();
            showStatus('🗑️ שטח נמחק', 'success');
        }



        // בדיקה אם נקודה נמצאת בתוך האריח או בסביבתו הקרובה (1 מ"מ)
        function isWithinTileDragArea(row, col, tile) {
            if (!tile || tile.length === 0) return false;
            
            const bounds = getTileBounds(tile);
            const margin = 1; // 1 מ"מ סביב האריח
            
            return row >= bounds.minRow - margin && 
                   row <= bounds.maxRow + margin && 
                   col >= bounds.minCol - margin && 
                   col <= bounds.maxCol + margin;
        }
        
        // קבלת הצבע הנכון לתא לפי שכבות
        function getTopLayerColor(row, col) {
            // חיפוש מהשטח האחרון (העליון) לראשון
            for (let i = createdShapes.length - 1; i >= 0; i--) {
                const shape = createdShapes[i];
                if (shape.cells.some(([r, c]) => r === row && c === col)) {
                    return shape.color;
                }
            }
            return '#ffffff'; // צבע רקע אם אין שטח
        }

        // קבלת הצבע הנכון לתא לפי שכבות, למעט שטח מסוים
        function getTopLayerColorExcluding(row, col, excludeShape) {
            // חיפוש מהשטח האחרון (העליון) לראשון, למעט השטח שמוחרג
            for (let i = createdShapes.length - 1; i >= 0; i--) {
                const shape = createdShapes[i];
                if (shape !== excludeShape && shape.cells.some(([r, c]) => r === row && c === col)) {
                    return shape.color;
                }
            }
            return '#ffffff'; // צבע רקע אם אין שטח
        }

        // הזזת שטח
        function moveShape(shape, newRow, newCol) {
            // השטח יזוז כך שהתא שלחצנו עליו יהיה בדיוק במיקום הסמן
            const clickedCellInShape = dragStartPos;
            
            // חישוב ההפרש בין התא שלחצנו עליו לכל תא אחר בשטח
            const shapeOffsets = shape.cells.map(([r, c]) => [r - clickedCellInShape[0], c - clickedCellInShape[1]]);
            
            // חישוב המיקום החדש של כל תא בשטח - התא שלחצנו עליו יהיה בדיוק במיקום הסמן
            const newCells = shapeOffsets.map(([offsetR, offsetC]) => [newRow + offsetR, newCol + offsetC]);
            
            // בדיקה שכל התאים החדשים בתוך הגבולות
            const isValidMove = newCells.every(([r, c]) => 
                r >= 0 && r < 30 && c >= 0 && c < 60
            );
            
            if (!isValidMove) return;
            
            // עדכון המיקום החדש בלבד; הרינדור המלא ידאג לשכבות הידני/שטחים/אריחים
            shape.cells = newCells;

            // רענון תצוגה חלק שמכבד שכבות ידני
            updateGridDisplaySmooth();
        }

        // צביעת תא בגריד היעד
        function paintTargetCell(row, col) {
            if (tileMoveMode) {
                // מצב הזזת אריחים
                if (selectedTileForMove) {
                    // אריח נבחר - נסה להזיז אותו
                    moveTileToPosition(row, col);
                } else {
                    // אין אריח נבחר - נסה לבחור אריח
                    selectTileForMove(row, col);
                }
                return;
            }
            
            if (tilingMode) {
                placeTileAt(row, col);
                return;
            }
            
            if (shapeCreationMode) {
                // ציור ידני נשמר בשכבה נפרדת כדי שלא יימחק בהזזת שטחים
                manualPaintLayer[row][col] = selectedColor;
                targetGridData[row][col] = selectedColor;
                const cellIndex = row * 60 + col;
                const cell = document.getElementById('targetGrid').children[cellIndex];
                if (cell) {
                    cell.style.backgroundColor = selectedColor;
                    cell.style.border = '2px solid #374151';
                }
                return;
            }
            
            // מצב רגיל - צביעה פשוטה גם נשמרת בשכבה הידנית
            manualPaintLayer[row][col] = selectedColor;
            targetGridData[row][col] = selectedColor;
            const cellIndex = row * 60 + col;
            const cell = document.getElementById('targetGrid').children[cellIndex];
            if (cell) {
                cell.style.backgroundColor = selectedColor;
            }
        }

        // יצירת שטח אוטומטי
        function createAutoShape() {
            const widthInput = document.getElementById('shapeWidth');
            const heightInput = document.getElementById('shapeHeight');
            
            if (!widthInput || !heightInput) {
                showStatus('שגיאה בקריאת נתוני הגודל', 'error');
                return;
            }
            
            const width = parseInt(widthInput.value) || 10;
            const height = parseInt(heightInput.value) || 10;
            
            if (width < 1 || width > 30 || height < 1 || height > 30) {
                showStatus('גודל השטח חייב להיות בין 1 ל-30', 'error');
                return;
            }
            
            // שמירת המצב לפני השינוי
            saveState();
            
            shapeCreationMode = true;
            updateGridTitle();
            
            // מציאת מיקום פנוי - התחלה מהמרכז
            let startRow = Math.max(0, Math.floor((30 - height) / 2));
            let startCol = Math.max(0, Math.floor((60 - width) / 2));
            
            // אם המיקום תפוס, מצא מיקום פנוי
            let attempts = 0;
            while (isAreaOccupied(startRow, startCol, width, height) && attempts < 100) {
                startRow = Math.floor(Math.random() * Math.max(1, 30 - height));
                startCol = Math.floor(Math.random() * Math.max(1, 60 - width));
                attempts++;
            }
            
            // יצירת השטח החדש
            const newShape = {
                id: Date.now(),
                startRow: startRow,
                startCol: startCol,
                width: width,
                height: height,
                color: selectedColor,
                cells: []
            };
            
            // צביעת המלבן והוספת התאים לשטח (לא לדרוס ידני)
            for (let i = startRow; i < startRow + height && i < 30; i++) {
                for (let j = startCol; j < startCol + width && j < 60; j++) {
                    if (!manualPaintLayer[i][j]) {
                        targetGridData[i][j] = selectedColor;
                    }
                    const cellIndex = i * 60 + j;
                    const cell = document.getElementById('targetGrid').children[cellIndex];
                    if (cell) {
                        cell.style.backgroundColor = manualPaintLayer[i][j] ? manualPaintLayer[i][j] : selectedColor;
                        cell.style.border = '2px solid #374151';
                    }
                    newShape.cells.push([i, j]);
                }
            }
            
            createdShapes.push(newShape);
            showStatus(`נוצר שטח ${width}×${height} - ניתן לגרור ולהוסיף שטחים נוספים`, 'success');
        }

        // בדיקה אם אזור תפוס
        function isAreaOccupied(startRow, startCol, width, height) {
            for (let i = startRow; i < startRow + height && i < 30; i++) {
                for (let j = startCol; j < startCol + width && j < 30; j++) {
                    if (targetGridData[i][j] !== '#ffffff') {
                        return true;
                    }
                }
            }
            return false;
        }

        // עדכון כותרת הגריד
        function updateGridTitle() {
            const title = document.getElementById('gridTitle');
            if (shapeCreationMode) {
                title.textContent = '🎨 מצב יצירת שטחי ריצוף (30×60) - ניתן לגרור ולהוסיף';
                title.className = 'text-lg font-bold mb-3 text-blue-700 text-center';
            } else if (tileMoveMode) {
                title.textContent = '🔄 מצב הזזת אריחים (30×60) - לחץ על אריח ואז על מיקום חדש';
                title.className = 'text-lg font-bold mb-3 text-yellow-700 text-center';
            } else if (tilingMode) {
                title.textContent = '🧩 מצב ריצוף פעיל (30×60) - השטח מקובע';
                title.className = 'text-lg font-bold mb-3 text-green-700 text-center';
            } else {
                title.textContent = 'שטח הריצוף (30×60)';
                title.className = 'text-lg font-bold mb-3 text-gray-700 text-center';
            }
        }





        // סיום יצירת שטח
        function finishShapeCreation() {
            shapeCreationMode = false;
            isDragging = false;
            dragStartPos = null;
            draggedShape = null;
            selectedShape = null;
            const deleteShapeBtn = document.getElementById('deleteShapeBtn');
            if (deleteShapeBtn) deleteShapeBtn.style.display = 'none';
            
            // הסרת הבורדר המיוחד מכל השטחים
            createdShapes.forEach(shape => {
                shape.cells.forEach(([row, col]) => {
                    const cellIndex = row * 60 + col;
                    const cell = document.getElementById('targetGrid').children[cellIndex];
                    cell.style.border = '1px solid #e5e7eb';
                });
            });
            
            updateGridTitle();
            showStatus('יצירת שטח הושלמה - השטח מוכן לריצוף', 'info');
        }

        // החלפת מצב תא באריח
        function toggleTileCell(row, col) {
            tileGridData[row][col] = !tileGridData[row][col];
            const cellIndex = row * 10 + col;
            const cell = document.getElementById('tileGrid').children[cellIndex];
            cell.style.backgroundColor = tileGridData[row][col] ? '#374151' : '#ffffff';
            updateCurrentTile();
        }

        // עדכון האריח הנוכחי
        function updateCurrentTile() {
            const newTile = [];
            for (let i = 0; i < 10; i++) {
                for (let j = 0; j < 10; j++) {
                    if (tileGridData[i][j]) {
                        newTile.push([i, j]);
                    }
                }
            }
            currentTile = newTile;
            generateAllTileVariations();
        }

        // יצירת כל תצורות האריח
        function generateAllTileVariations() {
            const container = document.getElementById('allTileVariations');
            container.innerHTML = '';
            
            if (currentTile.length === 0) {
                container.innerHTML = '<div class="text-gray-500 text-sm">אין אריח</div>';
                return;
            }
            
            const variations = [];
            let baseTile = normalizeTile(currentTile);
            
            // תצורה בסיסית
            variations.push({ tile: baseTile, label: 'בסיס' });
            
            // סיבוב 90 מעלות
            let rotated90 = normalizeTile(rotateTileArray(baseTile, 1));
            if (!isTileEqual(baseTile, rotated90)) {
                variations.push({ tile: rotated90, label: '90°' });
            }
            
            // סיבוב 180 מעלות
            let rotated180 = normalizeTile(rotateTileArray(baseTile, 2));
            if (!variations.some(v => isTileEqual(v.tile, rotated180))) {
                variations.push({ tile: rotated180, label: '180°' });
            }
            
            // סיבוב 270 מעלות
            let rotated270 = normalizeTile(rotateTileArray(baseTile, 3));
            if (!variations.some(v => isTileEqual(v.tile, rotated270))) {
                variations.push({ tile: rotated270, label: '270°' });
            }
            
            // היפוך אופקי
            let flippedH = normalizeTile(flipTileArray(baseTile, 'horizontal'));
            if (!variations.some(v => isTileEqual(v.tile, flippedH))) {
                variations.push({ tile: flippedH, label: 'היפוך' });
            }
            
            // היפוך אנכי
            let flippedV = normalizeTile(flipTileArray(baseTile, 'vertical'));
            if (!variations.some(v => isTileEqual(v.tile, flippedV))) {
                variations.push({ tile: flippedV, label: 'היפוך ↕' });
            }
            
            // שילובים של היפוך וסיבוב
            [flippedH, flippedV].forEach((flipped, idx) => {
                for (let rot = 1; rot <= 3; rot++) {
                    let combined = normalizeTile(rotateTileArray(flipped, rot));
                    if (!variations.some(v => isTileEqual(v.tile, combined))) {
                        variations.push({ 
                            tile: combined, 
                            label: `${idx === 0 ? 'היפוך' : 'היפוך↕'}+${rot * 90}°` 
                        });
                    }
                }
            });
            
            // הצגת כל התצורות
            variations.forEach((variation, index) => {
                const tileDiv = createTilePreview(variation.tile, variation.label, index);
                container.appendChild(tileDiv);
            });
        }

        // יצירת תצוגה מקדימה של אריח
        function createTilePreview(tile, label, index) {
            const container = document.createElement('div');
            container.className = 'flex flex-col items-center p-1 border border-gray-300 rounded cursor-pointer hover:bg-blue-50 transition-colors';
            container.onclick = () => selectTileVariation(tile, index);
            
            const bounds = getTileBounds(tile);
            const rows = bounds.maxRow - bounds.minRow + 1;
            const cols = bounds.maxCol - bounds.minCol + 1;
            
            const grid = document.createElement('div');
            grid.className = 'grid gap-0 mb-1';
            grid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
            
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'w-1.5 h-1.5 border-0';
                    const isPartOfTile = tile.some(pos => 
                        pos[0] === bounds.minRow + i && pos[1] === bounds.minCol + j
                    );
                    cell.style.backgroundColor = isPartOfTile ? '#374151' : 'transparent';
                    grid.appendChild(cell);
                }
            }
            
            const labelDiv = document.createElement('div');
            labelDiv.className = 'text-xs text-gray-600 text-center';
            labelDiv.textContent = label;
            
            container.appendChild(grid);
            container.appendChild(labelDiv);
            
            return container;
        }

        // בחירת תצורת אריח
        function selectTileVariation(tile, index) {
            currentTile = [...tile];
            
            // סימון הבחירה
            document.querySelectorAll('#allTileVariations > div').forEach((div, i) => {
                if (i === index) {
                    div.classList.add('bg-blue-100', 'border-blue-500');
                } else {
                    div.classList.remove('bg-blue-100', 'border-blue-500');
                }
            });
        }

        // פונקציות עזר לעיבוד אריחים
        function normalizeTile(tile) {
            if (tile.length === 0) return [];
            const bounds = getTileBounds(tile);
            return tile.map(([row, col]) => [row - bounds.minRow, col - bounds.minCol]);
        }

        function getTileBounds(tile) {
            if (tile.length === 0) return { minRow: 0, maxRow: 0, minCol: 0, maxCol: 0 };
            return {
                minRow: Math.min(...tile.map(pos => pos[0])),
                maxRow: Math.max(...tile.map(pos => pos[0])),
                minCol: Math.min(...tile.map(pos => pos[1])),
                maxCol: Math.max(...tile.map(pos => pos[1]))
            };
        }

        function rotateTileArray(tile, times) {
            let result = [...tile];
            for (let t = 0; t < times; t++) {
                const bounds = getTileBounds(result);
                const centerRow = (bounds.maxRow + bounds.minRow) / 2;
                const centerCol = (bounds.maxCol + bounds.minCol) / 2;
                
                result = result.map(([row, col]) => [
                    Math.round(centerRow + (col - centerCol)),
                    Math.round(centerCol - (row - centerRow))
                ]);
            }
            return result;
        }

        function flipTileArray(tile, direction) {
            const bounds = getTileBounds(tile);
            if (direction === 'horizontal') {
                return tile.map(([row, col]) => [row, bounds.maxCol - col + bounds.minCol]);
            } else {
                return tile.map(([row, col]) => [bounds.maxRow - row + bounds.minRow, col]);
            }
        }

        function isTileEqual(tile1, tile2) {
            if (tile1.length !== tile2.length) return false;
            const sorted1 = tile1.map(p => p.join(',')).sort();
            const sorted2 = tile2.map(p => p.join(',')).sort();
            return sorted1.every((p, i) => p === sorted2[i]);
        }

        // ניקוי שטח היעד
        function clearTarget() {
            targetGridData = Array(30).fill().map(() => Array(60).fill('#ffffff'));
            document.querySelectorAll('#targetGrid .grid-cell').forEach(cell => {
                cell.style.backgroundColor = '#ffffff';
                cell.style.border = '1px solid #e5e7eb';
            });
            clearTiling();
            shapeCreationMode = false;
            createdShapes = [];
            updateGridTitle();
        }

        // ניקוי האריח
        function clearTile() {
            tileGridData = Array(10).fill().map(() => Array(10).fill(false));
            document.querySelectorAll('#tileGrid .tile-cell').forEach(cell => {
                cell.style.backgroundColor = '#ffffff';
            });
            updateCurrentTile();
            
            // הוספת מאזיני עכבר ומגע גלובליים
            document.addEventListener('mouseup', handleMouseUp);
            document.addEventListener('touchend', handleMouseUp);
            document.addEventListener('touchcancel', handleMouseUp);
        }

        // ניקוי גריד האריח בלבד
        function clearTileGrid() {
            tileGridData = Array(10).fill().map(() => Array(10).fill(false));
            document.querySelectorAll('#tileGrid .tile-cell').forEach(cell => {
                cell.style.backgroundColor = '#ffffff';
            });
        }

        // סיבוב האריח
        function rotateTile() {
            if (currentTile.length === 0) return;
            
            // מציאת מרכז הסיבוב
            const centerRow = Math.max(...currentTile.map(pos => pos[0])) / 2 + Math.min(...currentTile.map(pos => pos[0])) / 2;
            const centerCol = Math.max(...currentTile.map(pos => pos[1])) / 2 + Math.min(...currentTile.map(pos => pos[1])) / 2;
            
            // סיבוב 90 מעלות
            const rotatedTile = currentTile.map(([row, col]) => {
                const newRow = Math.round(centerRow + (col - centerCol));
                const newCol = Math.round(centerCol - (row - centerRow));
                return [newRow, newCol];
            });
            
            // נרמול המיקום
            const minRow = Math.min(...rotatedTile.map(pos => pos[0]));
            const minCol = Math.min(...rotatedTile.map(pos => pos[1]));
            
            const normalizedTile = rotatedTile.map(([row, col]) => [row - minRow, col - minCol]);
            
            // עדכון הגריד
            clearTileGrid();
            normalizedTile.forEach(([row, col]) => {
                if (row >= 0 && row < 10 && col >= 0 && col < 10) {
                    tileGridData[row][col] = true;
                    const cellIndex = row * 10 + col;
                    const cell = document.getElementById('tileGrid').children[cellIndex];
                    cell.style.backgroundColor = '#374151';
                }
            });
            
            // עדכון currentTile ישירות עם הערכים החדשים
            currentTile = normalizedTile;
            generateAllTileVariations();
        }

        // היפוך האריח
        function flipTile() {
            if (currentTile.length === 0) return;
            
            const maxCol = Math.max(...currentTile.map(pos => pos[1]));
            const flippedTile = currentTile.map(([row, col]) => [row, maxCol - col]);
            
            // נרמול המיקום
            const minRow = Math.min(...flippedTile.map(pos => pos[0]));
            const minCol = Math.min(...flippedTile.map(pos => pos[1]));
            
            const normalizedTile = flippedTile.map(([row, col]) => [row - minRow, col - minCol]);
            
            // עדכון הגריד
            clearTileGrid();
            normalizedTile.forEach(([row, col]) => {
                if (row >= 0 && row < 10 && col >= 0 && col < 10) {
                    tileGridData[row][col] = true;
                    const cellIndex = row * 10 + col;
                    const cell = document.getElementById('tileGrid').children[cellIndex];
                    cell.style.backgroundColor = '#374151';
                }
            });
            
            // עדכון currentTile ישירות עם הערכים החדשים
            currentTile = normalizedTile;
            generateAllTileVariations();
        }

        // שמירת מצב לביטול/חזרה
        function saveState() {
            // הסרת כל המצבים שאחרי המצב הנוכחי (אם עשינו ביטול ועכשיו עושים פעולה חדשה)
            actionHistory = actionHistory.slice(0, historyIndex + 1);
            
            // שמירת המצב הנוכחי
            const state = {
                placedTiles: JSON.parse(JSON.stringify(placedTiles)),
                targetGridData: JSON.parse(JSON.stringify(targetGridData)),
                createdShapes: JSON.parse(JSON.stringify(createdShapes)),
                tilingMode: tilingMode,
                shapeCreationMode: shapeCreationMode
            };
            
            // Avoid pushing duplicate snapshots
            const last = actionHistory.length > 0 ? actionHistory[actionHistory.length - 1] : null;
            let isDuplicate = false;
            if (last) {
                try {
                    isDuplicate = JSON.stringify(last) === JSON.stringify(state);
                } catch (e) {
                    isDuplicate = false;
                }
            }
            if (!isDuplicate) {
                actionHistory.push(state);
                historyIndex++;
            }
            
            // שמירה על מקסימום 50 פעולות
            if (actionHistory.length > 50) {
                actionHistory.shift();
                historyIndex--;
            }
            
            updateUndoRedoButtons();
        }

        // ביטול פעולה אחרונה
        function undo() {
            if (historyIndex <= 0) {
                showStatus('אין פעולות לביטול', 'error');
                return;
            }
            
            historyIndex--;
            const state = actionHistory[historyIndex];
            
            // שחזור המצב
            placedTiles = JSON.parse(JSON.stringify(state.placedTiles));
            targetGridData = JSON.parse(JSON.stringify(state.targetGridData));
            createdShapes = JSON.parse(JSON.stringify(state.createdShapes));
            
            // שחזור מצבי המערכת
            if (state.tilingMode !== undefined) tilingMode = state.tilingMode;
            if (state.shapeCreationMode !== undefined) shapeCreationMode = state.shapeCreationMode;
            
            // עדכון התצוגה
            updateGridDisplay();
            updateGridTitle();
            updateUndoRedoButtons();
            showStatus('פעולה בוטלה', 'info');
        }

        // חזרה על פעולה
        function redo() {
            if (historyIndex >= actionHistory.length - 1) {
                showStatus('אין פעולות לחזרה', 'error');
                return;
            }
            
            historyIndex++;
            const state = actionHistory[historyIndex];
            
            // שחזור המצב
            placedTiles = JSON.parse(JSON.stringify(state.placedTiles));
            targetGridData = JSON.parse(JSON.stringify(state.targetGridData));
            createdShapes = JSON.parse(JSON.stringify(state.createdShapes));
            
            // שחזור מצבי המערכת
            if (state.tilingMode !== undefined) tilingMode = state.tilingMode;
            if (state.shapeCreationMode !== undefined) shapeCreationMode = state.shapeCreationMode;
            
            // עדכון התצוגה
            updateGridDisplay();
            updateGridTitle();
            updateUndoRedoButtons();
            showStatus('פעולה שוחזרה', 'info');
        }

        // עדכון כפתורי ביטול וחזרה
        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            
            undoBtn.disabled = historyIndex <= 0;
            redoBtn.disabled = historyIndex >= actionHistory.length - 1;
        }

        // עדכון תצוגת הגריד עם מערכת שכבות
        function updateGridDisplay() {
            // עדכון targetGridData תחילה לפי השטחים הקיימים
            for (let i = 0; i < 30; i++) {
                for (let j = 0; j < 60; j++) {
                    targetGridData[i][j] = '#ffffff'; // איפוס לרקע לבן
                }
            }
            
            // עדכון targetGridData לפי השטחים הקיימים (לפי סדר יצירה)
            createdShapes.forEach(shape => {
                shape.cells.forEach(([row, col]) => {
                    targetGridData[row][col] = shape.color;
                });
            });

            // החלת שכבת ציור ידני מעל השטחים
            for (let i = 0; i < 30; i++) {
                for (let j = 0; j < 60; j++) {
                    if (manualPaintLayer[i][j]) {
                        targetGridData[i][j] = manualPaintLayer[i][j];
                    }
                }
            }
            
            // עכשיו עדכון התצוגה הויזואלית
            for (let i = 0; i < 30; i++) {
                for (let j = 0; j < 60; j++) {
                    const cellIndex = i * 60 + j;
                    const cell = document.getElementById('targetGrid').children[cellIndex];
                    
                    // איפוס כל הסטיילים
                    cell.style.backgroundColor = targetGridData[i][j];
                    cell.style.border = '1px solid #e5e7eb';
                    cell.style.borderTop = '';
                    cell.style.borderRight = '';
                    cell.style.borderBottom = '';
                    cell.style.borderLeft = '';
                    cell.style.boxShadow = 'none';
                    cell.style.cursor = 'pointer';
                    cell.style.transform = '';
                    cell.style.transition = '';
                    cell.style.animation = '';
                    cell.style.zIndex = '';
                    cell.style.opacity = '1';
                    
                    // בורדר מיוחד במצב יצירת שטח
                    if (shapeCreationMode && targetGridData[i][j] !== '#ffffff') {
                        cell.style.border = '2px solid #374151';
                    }
                }
            }
            
            // עדכון אריחים מונחים (תמיד בשכבה העליונה)
            placedTiles.forEach(tile => {
                tile.positions.forEach(([row, col]) => {
                    const cellIndex = row * 60 + col;
                    const cell = document.getElementById('targetGrid').children[cellIndex];
                    cell.style.backgroundColor = tile.color || '#0ea5e9';
                    
                    // קביעת הבורדר - צבע הבורדר של האריח לקווי המתאר החיצוניים, לבן לקווים הפנימיים
                    const isEdge = isEdgeOfTile(row, col, tile.positions);
                    const borderColor = tile.borderColor || '#075985';
                    
                    // בניית הבורדר המותאם אישית
                    cell.style.borderTop = isEdge.top ? `2px solid ${borderColor}` : '1px solid #ffffff';
                    cell.style.borderRight = isEdge.right ? `2px solid ${borderColor}` : '1px solid #ffffff';
                    cell.style.borderBottom = isEdge.bottom ? `2px solid ${borderColor}` : '1px solid #ffffff';
                    cell.style.borderLeft = isEdge.left ? `2px solid ${borderColor}` : '1px solid #ffffff';
                });
            });
            
            // הדגשה במצב הזזת אריחים
            if (tileMoveMode) {
                highlightMovableTiles();
            }
        }

        // הצגת הוראות שימוש
        function showInstructions() {
            document.getElementById('instructionsModal').classList.remove('hidden');
        }

        // הסתרת הוראות שימוש
        function hideInstructions() {
            document.getElementById('instructionsModal').classList.add('hidden');
        }

        // התחלת מצב ריצוף
        function startTiling() {
            if (currentTile.length === 0) {
                showStatus('עליך לעצב אריח תחילה!', 'error');
                return;
            }
            
            // בדיקה אם עדיין במצב יצירת שטח
            if (shapeCreationMode) {
                showStatus('יש לסיים תחילה את מצב יצירת שטחי הריצוף על ידי לחיצה על כפתור "סיים יצירת שטח"', 'error');
                return;
            }
            
            // שמירת המצב הנוכחי
            saveState();
            
            // סיום מצב יצירת שטח אוטומטית
            shapeCreationMode = false;
            isDragging = false;
            dragStartPos = null;
            draggedShape = null;
            removeMode = false;
            
            // הסרת הבורדר המיוחד מכל השטחים
            createdShapes.forEach(shape => {
                shape.cells.forEach(([row, col]) => {
                    const cellIndex = row * 60 + col;
                    const cell = document.getElementById('targetGrid').children[cellIndex];
                    cell.style.border = '1px solid #e5e7eb';
                });
            });
            
            tilingMode = true;
            updateGridTitle();
            showStatus('מצב ריצוף פעיל - השטח מקובע, לחץ על הגריד להנחת אריחים', 'success');
        }

        // ביטול מצב ריצוף
        function stopTiling() {
            tilingMode = false;
            tileMoveMode = false;
            selectedTileForMove = null;
            clearTilePreview();
            updateGridTitle();
            showStatus('מצב ריצוף בוטל - חזרה למצב עיצוב', 'info');
        }

        // החלפת מצב הזזת אריחים
        function toggleTileMoveMode() {
            if (placedTiles.length === 0) {
                showStatus('אין אריחים להזזה - הנח אריחים תחילה', 'error');
                return;
            }
            
            tileMoveMode = !tileMoveMode;
            selectedTileForMove = null;
            clearTilePreview();
            
            // הסתרת כפתורי עריכת האריח
            const deleteBtn = document.getElementById('deleteTileBtn');
            const rotateBtn = document.getElementById('rotateTileBtn');
            const flipBtn = document.getElementById('flipTileBtn');
            deleteBtn.style.display = 'none';
            rotateBtn.style.display = 'none';
            flipBtn.style.display = 'none';
            
            if (tileMoveMode) {
                tilingMode = false; // כיבוי מצב ריצוף רגיל
                updateGridTitle();
                showStatus('מצב הזזת אריחים פעיל - לחץ על אריח להזזה', 'success');
                highlightMovableTiles();
            } else {
                updateGridTitle();
                showStatus('מצב הזזת אריחים בוטל', 'info');
                updateGridDisplay();
            }
        }

        // הדגשת אריחים הניתנים להזזה
        function highlightMovableTiles() {
            placedTiles.forEach((tile, index) => {
                tile.positions.forEach(([row, col]) => {
                    const cellIndex = row * 60 + col;
                    const cell = document.getElementById('targetGrid').children[cellIndex];
                    cell.style.boxShadow = '0 0 0 2px #fbbf24 inset'; // הדגשה בצהוב
                    cell.style.cursor = 'pointer';
                });
            });
        }

        // מציאת אריח לפי מיקום תא
        function findTileByPosition(row, col) {
            for (let i = 0; i < placedTiles.length; i++) {
                const tile = placedTiles[i];
                if (tile.positions.some(([tRow, tCol]) => tRow === row && tCol === col)) {
                    return { tile, index: i };
                }
            }
            return null;
        }

        // בחירת אריח להזזה
        function selectTileForMove(row, col) {
            const tileData = findTileByPosition(row, col);
            if (!tileData) return false;
            
            selectedTileForMove = tileData;
            
            // הצגת כפתורי עריכת האריח
            const deleteBtn = document.getElementById('deleteTileBtn');
            const rotateBtn = document.getElementById('rotateTileBtn');
            const flipBtn = document.getElementById('flipTileBtn');
            deleteBtn.style.display = 'inline-block';
            rotateBtn.style.display = 'inline-block';
            flipBtn.style.display = 'inline-block';
            
            // הדגשת האריח הנבחר עם אנימציה
            updateGridDisplay();
            tileData.tile.positions.forEach(([tRow, tCol]) => {
                const cellIndex = tRow * 60 + tCol;
                const cell = document.getElementById('targetGrid').children[cellIndex];
                
                // הדגשה חזקה עם אנימציה פועמת
                cell.style.boxShadow = '0 0 0 4px #ef4444 inset, 0 0 10px rgba(239, 68, 68, 0.5)';
                cell.style.cursor = 'grab';
                cell.style.transform = 'scale(1.05)';
                cell.style.transition = 'all 0.2s ease';
                cell.style.zIndex = '10';
                
                // אנימציה פועמת
                cell.style.animation = 'pulse 1.5s infinite';
            });
            
            // הודעה מותאמת למכשיר
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            if (isMobile) {
                showStatus(`🔄 אריח נבחר - גרור להזזה או השתמש בכפתורים לסיבוב/היפוך/מחיקה`, 'info');
            } else {
                showStatus(`🔄 אריח נבחר - גרור להזזה, R לסיבוב, F להיפוך, Delete למחיקה`, 'info');
            }
            return true;
        }

        // הזזת אריח למיקום חדש עם גרירה
        function moveTileToPosition(targetRow, targetCol) {
            if (!selectedTileForMove) return false;
            
            const { tile, index } = selectedTileForMove;
            
            // חישוב ההפרש כך שמרכז האריח יתיישר עם הסמן
            const currentBounds = getTileBounds(tile.positions.map(([r, c]) => [r, c]));
            const currentCenterRow = Math.floor((currentBounds.minRow + currentBounds.maxRow) / 2);
            const currentCenterCol = Math.floor((currentBounds.minCol + currentBounds.maxCol) / 2);
            const deltaRow = targetRow - currentCenterRow;
            const deltaCol = targetCol - currentCenterCol;
            
            // חישוב המיקומים החדשים
            const newPositions = tile.positions.map(([row, col]) => [
                row + deltaRow,
                col + deltaCol
            ]);
            
            // בדיקה שהמיקום החדש תקין
            const isValidMove = newPositions.every(([row, col]) => {
                // בדיקת גבולות
                if (row < 0 || row >= 30 || col < 0 || col >= 60) return false;
                
                // בדיקה שהמיקום הוא חלק מהשטח המיועד
                if (targetGridData[row][col] === '#ffffff') return false;
                
                // בדיקה שאין אריח אחר במיקום (למעט האריח הנוכחי)
                const otherTileAtPosition = placedTiles.find((otherTile, otherIndex) => 
                    otherIndex !== index && 
                    otherTile.positions.some(([oRow, oCol]) => oRow === row && oCol === col)
                );
                
                return !otherTileAtPosition;
            });
            
            if (!isValidMove) {
                showTileDragPreview(targetRow, targetCol, false); // תצוגה מקדימה אדומה
                return false;
            }
            
            // שמירת המצב לפני השינוי
            saveState();
            
            // עדכון מיקום האריח
            tile.positions = newPositions;
            
            // עדכון התצוגה
            updateGridDisplay();
            clearTileDragPreview();
            
            // איפוס הבחירה
            selectedTileForMove = null;
            
            showStatus('האריח הוזז בהצלחה!', 'success');
            
            // בדיקת השלמת ריצוף
            checkTilingComplete();
            
            return true;
        }

        // הזזה אוטומטית במובייל - ללא צורך בלחיצה נוספת
        function moveTileToPositionAuto(targetRow, targetCol) {
            if (!selectedTileForMove) return false;
            
            const { tile, index } = selectedTileForMove;
            
            // חישוב ההפרש כך שמרכז האריח יתיישר עם הסמן
            const currentBounds = getTileBounds(tile.positions.map(([r, c]) => [r, c]));
            const currentCenterRow = Math.floor((currentBounds.minRow + currentBounds.maxRow) / 2);
            const currentCenterCol = Math.floor((currentBounds.minCol + currentBounds.maxCol) / 2);
            const deltaRow = targetRow - currentCenterRow;
            const deltaCol = targetCol - currentCenterCol;
            
            // חישוב המיקומים החדשים
            const newPositions = tile.positions.map(([row, col]) => [
                row + deltaRow,
                col + deltaCol
            ]);
            
            // בדיקה שהמיקום החדש תקין
            const isValidMove = newPositions.every(([row, col]) => {
                // בדיקת גבולות
                if (row < 0 || row >= 30 || col < 0 || col >= 60) return false;
                
                // בדיקה שהמיקום הוא חלק מהשטח המיועד
                if (targetGridData[row][col] === '#ffffff') return false;
                
                // בדיקה שאין אריח אחר במיקום (למעט האריח הנוכחי)
                const otherTileAtPosition = placedTiles.find((otherTile, otherIndex) => 
                    otherIndex !== index && 
                    otherTile.positions.some(([oRow, oCol]) => oRow === row && oCol === col)
                );
                
                return !otherTileAtPosition;
            });
            
            if (!isValidMove) {
                // רק הצגת תצוגה מקדימה אדומה, ללא הזזה
                showSmoothTileDragPreview(targetRow, targetCol);
                return false;
            }
            
            // עדכון מיקום האריח מיידית ללא שמירת מצב (יישמר בסוף הגרירה)
            tile.positions = newPositions;
            
            // עדכון התצוגה מיידית
            updateGridDisplay();
            
            return true;
        }

        // תצוגה מקדימה חלקה ומדויקת בזמן גרירת אריח
        function showSmoothTileDragPreview(targetRow, targetCol) {
            if (!selectedTileForMove) return;
            
            clearTileDragPreview();
            
            const { tile, index } = selectedTileForMove;
            const currentBounds = getTileBounds(tile.positions.map(([r, c]) => [r, c]));
            const currentCenterRow = Math.floor((currentBounds.minRow + currentBounds.maxRow) / 2);
            const currentCenterCol = Math.floor((currentBounds.minCol + currentBounds.maxCol) / 2);
            const deltaRow = targetRow - currentCenterRow;
            const deltaCol = targetCol - currentCenterCol;
            
            const newPositions = tile.positions.map(([row, col]) => [
                row + deltaRow,
                col + deltaCol
            ]);
            
            // בדיקת תקינות המיקום החדש
            const isValidMove = newPositions.every(([row, col]) => {
                if (row < 0 || row >= 30 || col < 0 || col >= 60) return false;
                if (targetGridData[row][col] === '#ffffff') return false;
                
                const otherTileAtPosition = placedTiles.find((otherTile, otherIndex) => 
                    otherIndex !== index && 
                    otherTile.positions.some(([oRow, oCol]) => oRow === row && oCol === col)
                );
                
                return !otherTileAtPosition;
            });
            
            // הצגת התצוגה המקדימה עם צבעים ברורים
            newPositions.forEach(([row, col]) => {
                if (row >= 0 && row < 30 && col >= 0 && col < 60) {
                    const cellIndex = row * 60 + col;
                    const cell = document.getElementById('targetGrid').children[cellIndex];
                    
                    if (isValidMove) {
                        // ירוק בהיר עם בורדר ירוק כהה - מיקום תקין
                        cell.style.backgroundColor = '#bbf7d0';
                        cell.style.border = '3px solid #16a34a';
                        cell.style.opacity = '0.9';
                        cell.style.transform = 'scale(0.95)';
                        cell.style.transition = 'all 0.1s ease';
                    } else {
                        // אדום בהיר עם בורדר אדום כהה - מיקום לא תקין
                        cell.style.backgroundColor = '#fecaca';
                        cell.style.border = '3px solid #dc2626';
                        cell.style.opacity = '0.8';
                        cell.style.transform = 'scale(0.9)';
                        cell.style.transition = 'all 0.1s ease';
                    }
                }
            });
            
            // עדכון הודעת הסטטוס
            if (isValidMove) {
                showStatus('✅ מיקום תקין - לחץ להנחה', 'success');
            } else {
                showStatus('❌ מיקום לא תקין - בחר מיקום אחר', 'error');
            }
        }

        // תצוגה מקדימה בזמן גרירת אריח (גרסה ישנה - לתאימות)
        function showTileDragPreview(targetRow, targetCol, isValid = true) {
            showSmoothTileDragPreview(targetRow, targetCol);
        }

        // ניקוי תצוגה מקדימה של גרירת אריח
        function clearTileDragPreview() {
            document.querySelectorAll('#targetGrid .grid-cell').forEach(cell => {
                // ניקוי כל האפקטים של התצוגה המקדימה
                if (cell.style.backgroundColor === 'rgb(187, 247, 208)' || // ירוק בהיר
                    cell.style.backgroundColor === 'rgb(254, 202, 202)' || // אדום בהיר
                    cell.style.boxShadow.includes('#10b981') || 
                    cell.style.boxShadow.includes('#ef4444') ||
                    cell.style.boxShadow.includes('#16a34a') ||
                    cell.style.boxShadow.includes('#dc2626')) {
                    
                    // איפוס לערכי ברירת מחדל
                    cell.style.boxShadow = '';
                    cell.style.opacity = '1';
                    cell.style.transform = '';
                    cell.style.transition = '';
                    
                    // שחזור הצבע המקורי
                    const row = Math.floor(Array.from(cell.parentNode.children).indexOf(cell) / 60);
                    const col = Array.from(cell.parentNode.children).indexOf(cell) % 60;
                    
                    // בדיקה אם יש אריח במיקום זה
                    const tileAtPosition = placedTiles.find(tile => 
                        tile.positions.some(([tRow, tCol]) => tRow === row && tCol === col)
                    );
                    
                    if (tileAtPosition) {
                        // שחזור צבע האריח
                        cell.style.backgroundColor = tileAtPosition.color;
                        const isEdge = isEdgeOfTile(row, col, tileAtPosition.positions);
                        const borderColor = tileAtPosition.borderColor;
                        
                        const borderParts = [];
                        borderParts.push(isEdge.top ? `2px solid ${borderColor}` : '1px solid #ffffff');
                        borderParts.push(isEdge.right ? `2px solid ${borderColor}` : '1px solid #ffffff');
                        borderParts.push(isEdge.bottom ? `2px solid ${borderColor}` : '1px solid #ffffff');
                        borderParts.push(isEdge.left ? `2px solid ${borderColor}` : '1px solid #ffffff');
                        
                        cell.style.borderTop = borderParts[0];
                        cell.style.borderRight = borderParts[1];
                        cell.style.borderBottom = borderParts[2];
                        cell.style.borderLeft = borderParts[3];
                    } else {
                        // שחזור צבע הרקע המקורי, תוך העדפת שכבת ציור ידני אם קיימת
                        const manualColor = manualPaintLayer[row][col];
                        const baseColor = manualColor ? manualColor : targetGridData[row][col];
                        cell.style.backgroundColor = baseColor;
                        cell.style.border = '1px solid #e5e7eb';
                    }
                }
            });
        }

        // הצגת תצוגה מקדימה של האריח
        function showTilePreview(hoverRow, hoverCol) {
            clearTilePreview();
            
            // האריח יוצב כך שהתא הראשון שלו יהיה בדיוק במיקום הסמן
            previewPosition = [hoverRow, hoverCol];
            
            // מציאת התא הראשון באריח (הקרוב ביותר לפינה השמאלית העליונה)
            if (currentTile.length === 0) return;
            
            const minRow = Math.min(...currentTile.map(pos => pos[0]));
            const minCol = Math.min(...currentTile.map(pos => pos[1]));
            
            currentTile.forEach(([tileRow, tileCol]) => {
                const targetRow = hoverRow + (tileRow - minRow);
                const targetCol = hoverCol + (tileCol - minCol);
                
                if (targetRow >= 0 && targetRow < 30 && targetCol >= 0 && targetCol < 60) {
                    const cellIndex = targetRow * 60 + targetCol;
                    const cell = document.getElementById('targetGrid').children[cellIndex];
                    
                    const canPlace = canPlaceTileAt(hoverRow, hoverCol);
                    
                    if (canPlace) {
                        cell.style.border = '2px solid #10b981';
                        cell.style.opacity = '0.7';
                    } else {
                        cell.style.border = '2px solid #ef4444';
                        cell.style.opacity = '0.7';
                    }
                }
            });
        }

        // ניקוי תצוגה מקדימה
        function clearTilePreview() {
            document.querySelectorAll('#targetGrid .grid-cell').forEach(cell => {
                cell.style.border = '1px solid #e5e7eb';
                cell.style.opacity = '1';
            });
            previewPosition = null;
        }

        // בדיקה אם ניתן להניח אריח במיקום
        function canPlaceTileAt(clickRow, clickCol) {
            if (currentTile.length === 0) {
                console.log('canPlaceTileAt: no current tile');
                return false;
            }
            
            // מציאת התא הראשון באריח
            const minRow = Math.min(...currentTile.map(pos => pos[0]));
            const minCol = Math.min(...currentTile.map(pos => pos[1]));
            
            console.log('canPlaceTileAt: checking positions for tile at', clickRow, clickCol);
            
            const result = currentTile.every(([tileRow, tileCol]) => {
                const targetRow = clickRow + (tileRow - minRow);
                const targetCol = clickCol + (tileCol - minCol);
                
                console.log('Checking position:', targetRow, targetCol);
                
                if (targetRow < 0 || targetRow >= 30 || targetCol < 0 || targetCol >= 60) {
                    console.log('Position out of bounds');
                    return false;
                }
                
                // בדיקה שהמיקום הוא חלק מהשטח המיועד ולא תפוס
                const targetColor = targetGridData[targetRow][targetCol];
                const isOccupied = isCellOccupied(targetRow, targetCol);
                
                console.log('Target color:', targetColor, 'Is occupied:', isOccupied);
                
                const isValid = targetColor !== '#ffffff' && !isOccupied;
                if (!isValid) {
                    console.log('Position invalid - color:', targetColor, 'occupied:', isOccupied);
                }
                
                return isValid;
            });
            
            console.log('canPlaceTileAt result:', result);
            return result;
        }



        // בדיקה אם תא תפוס על ידי אריח אחר
        function isCellOccupied(row, col) {
            return placedTiles.some(tile => 
                tile.positions.some(pos => pos[0] === row && pos[1] === col)
            );
        }

        // בדיקה אם תא הוא קצה של האריח
        function isEdgeOfTile(row, col, tilePositions) {
            const isPartOfTile = (r, c) => tilePositions.some(([tr, tc]) => tr === r && tc === c);
            
            return {
                top: !isPartOfTile(row - 1, col),
                right: !isPartOfTile(row, col + 1),
                bottom: !isPartOfTile(row + 1, col),
                left: !isPartOfTile(row, col - 1)
            };
        }

        // מערך צבעי אריחים מגוונים
        const tileColors = [
            { bg: '#fef3c7', border: '#f59e0b' }, // צהוב זהב
            { bg: '#ddd6fe', border: '#8b5cf6' }, // סגול
            { bg: '#fce7f3', border: '#ec4899' }, // ורוד
            { bg: '#d1fae5', border: '#10b981' }, // ירוק
            { bg: '#fed7d7', border: '#ef4444' }, // אדום
            { bg: '#e0f2fe', border: '#0ea5e9' }, // תכלת
            { bg: '#fef2e2', border: '#f97316' }, // כתום
            { bg: '#f3e8ff', border: '#a855f7' }, // סגול בהיר
            { bg: '#ecfdf5', border: '#22c55e' }, // ירוק בהיר
            { bg: '#fdf2f8', border: '#f472b6' }  // ורוד בהיר
        ];

        // Override tileColors to use darker tones for placed tiles
        try {
            if (Array.isArray(tileColors)) {
                tileColors.splice(0, tileColors.length,
                    { bg: '#f59e0b', border: '#92400e' },
                    { bg: '#8b5cf6', border: '#5b21b6' },
                    { bg: '#ec4899', border: '#9d174d' },
                    { bg: '#10b981', border: '#065f46' },
                    { bg: '#ef4444', border: '#7f1d1d' },
                    { bg: '#0ea5e9', border: '#075985' },
                    { bg: '#f97316', border: '#7c2d12' },
                    { bg: '#a855f7', border: '#581c87' },
                    { bg: '#22c55e', border: '#14532d' },
                    { bg: '#f43f5e', border: '#9f1239' }
                );
            }
        } catch (e) {
            console.warn('Failed to override tileColors', e);
        }

        // הנחת אריח במיקום
        function placeTileAt(clickRow, clickCol) {
            console.log('placeTileAt called:', clickRow, clickCol, 'tilingMode:', tilingMode, 'currentTile length:', currentTile.length);
            
            if (!tilingMode) {
                console.log('Not in tiling mode');
                return;
            }
            
            // בדיקה אם עדיין במצב יצירת שטח
            if (shapeCreationMode) {
                showStatus('יש לסיים תחילה את מצב יצירת שטחי הריצוף על ידי לחיצה על כפתור "סיים יצירת שטח"', 'error');
                return;
            }
            
            // הנחת אריח חדש
            if (currentTile.length === 0) {
                console.log('No current tile defined');
                showStatus('עליך לעצב אריח תחילה!', 'error');
                return;
            }
            
            // האריח יונח כך שהתא הראשון שלו יהיה בדיוק במיקום הלחיצה
            const canPlace = canPlaceTileAt(clickRow, clickCol);
            console.log('Can place tile:', canPlace);
            
            if (!canPlace) {
                showStatus('לא ניתן להניח אריח במיקום זה - ודא שהמיקום על שטח צבעוני ולא תפוס', 'error');
                return;
            }
            
            // שמירת המצב לפני השינוי
            saveState();
            
            // מציאת התא הראשון באריח
            const minRow = Math.min(...currentTile.map(pos => pos[0]));
            const minCol = Math.min(...currentTile.map(pos => pos[1]));
            
            const tilePositions = currentTile.map(([tileRow, tileCol]) => [
                clickRow + (tileRow - minRow),
                clickCol + (tileCol - minCol)
            ]);
            
            console.log('Tile positions:', tilePositions);
            
            // בחירת צבע אריח (מחזורי לפי מספר האריחים)
            const colorIndex = placedTiles.length % tileColors.length;
            const tileColor = tileColors[colorIndex];
            
            // הוספת האריח לרשימת האריחים המונחים
            placedTiles.push({
                positions: tilePositions,
                color: tileColor.bg,
                borderColor: tileColor.border
            });

            saveState();
            
            console.log('Tile placed successfully, total tiles:', placedTiles.length);
            
            clearTilePreview();
            showStatus(`אריח הונח! סה"כ ${placedTiles.length} אריחים`, 'success');
            
            // בדיקה אם הריצוף הושלם
            checkTilingComplete();
            updateGridDisplay();
        }

        // הסרת אריח אחרון
        function removeTile() {
            if (placedTiles.length === 0) {
                showStatus('אין אריחים להסרה', 'error');
                return;
            }
            
            const lastTile = placedTiles.pop();
            
            lastTile.positions.forEach(([row, col]) => {
                const cellIndex = row * 60 + col;
                const cell = document.getElementById('targetGrid').children[cellIndex];
                cell.style.backgroundColor = targetGridData[row][col];
                cell.style.border = '1px solid #e5e7eb';
            });
            
            showStatus(`אריח הוסר! נותרו ${placedTiles.length} אריחים`, 'info');
        }

        // ניקוי כל הריצוף
        function clearTiling() {
            if (placedTiles.length === 0) {
                showStatus('אין אריחים לניקוי', 'info');
                return;
            }
            
            // שמירת המצב לפני השינוי
            saveState();
            
            placedTiles = [];
            
            // איפוס מצב הזזת אריחים
            tileMoveMode = false;
            selectedTileForMove = null;
            
            // ניקוי מלא של כל האפקטים הויזואליים
            for (let i = 0; i < 30; i++) {
                for (let j = 0; j < 60; j++) {
                    const cellIndex = i * 60 + j;
                    const cell = document.getElementById('targetGrid').children[cellIndex];
                    
                    // איפוס מלא של כל הסטיילים
                    cell.style.backgroundColor = targetGridData[i][j];
                    cell.style.border = '1px solid #e5e7eb';
                    cell.style.borderTop = '';
                    cell.style.borderRight = '';
                    cell.style.borderBottom = '';
                    cell.style.borderLeft = '';
                    cell.style.boxShadow = 'none';
                    cell.style.cursor = 'pointer';
                    cell.style.transform = '';
                    cell.style.transition = '';
                    cell.style.animation = '';
                    cell.style.zIndex = '';
                    cell.style.opacity = '1';
                }
            }
            
            clearTilePreview();
            clearTileDragPreview();
            updateGridTitle();
            showStatus('כל האריחים הוסרו - שטח הריצוף נשמר', 'info');
        }

        // בדיקת השלמת ריצוף
        function checkTilingComplete() {
            const targetCells = [];
            for (let i = 0; i < 30; i++) {
                for (let j = 0; j < 60; j++) {
                    if (targetGridData[i][j] !== '#ffffff') {
                        targetCells.push([i, j]);
                    }
                }
            }
            
            const tiledCells = [];
            placedTiles.forEach(tile => {
                tile.positions.forEach(pos => tiledCells.push(pos));
            });
            
            const allCovered = targetCells.every(([row, col]) => 
                tiledCells.some(([tRow, tCol]) => tRow === row && tCol === col)
            );
            
            if (allCovered && targetCells.length > 0) {
                showStatus('🎉 מזל טוב! הריצוף הושלם בהצלחה!', 'complete');
            }
        }

        // הצגת הודעת סטטוס
        function showStatus(message, type) {
            const statusDiv = document.getElementById('tilingStatus');
            statusDiv.textContent = message;
            
            const colors = {
                success: 'bg-green-100 text-green-800',
                error: 'bg-red-100 text-red-800',
                info: 'bg-blue-100 text-blue-800',
                complete: 'bg-purple-100 text-purple-800'
            };
            
            statusDiv.className = `mt-4 p-2 rounded text-center text-sm font-medium ${colors[type] || colors.info}`;
        }

        // סיבוב אריח נבחר
        function rotateSelectedTile() {
            if (!selectedTileForMove) {
                showStatus('אין אריח נבחר לסיבוב', 'error');
                return;
            }
            
            // שמירת המצב לפני השינוי
            saveState();
            
            const { tile } = selectedTileForMove;
            
            // מציאת מרכז האריח
            const bounds = getTileBounds(tile.positions);
            const centerRow = (bounds.minRow + bounds.maxRow) / 2;
            const centerCol = (bounds.minCol + bounds.maxCol) / 2;
            
            // סיבוב כל תא באריח 90 מעלות סביב המרכז
            const rotatedPositions = tile.positions.map(([row, col]) => {
                const newRow = Math.round(centerRow + (col - centerCol));
                const newCol = Math.round(centerCol - (row - centerRow));
                return [newRow, newCol];
            });
            
            // בדיקה שהמיקום החדש תקין
            const isValidRotation = rotatedPositions.every(([row, col]) => {
                // בדיקת גבולות
                if (row < 0 || row >= 30 || col < 0 || col >= 60) return false;
                
                // בדיקה שהמיקום הוא חלק מהשטח המיועד
                if (targetGridData[row][col] === '#ffffff') return false;
                
                // בדיקה שאין אריח אחר במיקום (למעט האריח הנוכחי)
                const otherTileAtPosition = placedTiles.find((otherTile) => 
                    otherTile !== tile && 
                    otherTile.positions.some(([oRow, oCol]) => oRow === row && oCol === col)
                );
                
                return !otherTileAtPosition;
            });
            
            if (!isValidRotation) {
                showStatus('❌ לא ניתן לסובב את האריח במיקום הנוכחי', 'error');
                return;
            }
            
            // עדכון מיקום האריח
            tile.positions = rotatedPositions;
            
            // עדכון התצוגה
            updateGridDisplay();
            
            showStatus('🔄 האריח סובב בהצלחה!', 'success');
            
            // בדיקת השלמת ריצוף
            checkTilingComplete();
            saveState();
        }

        // היפוך אריח נבחר
        function flipSelectedTile() {
            if (!selectedTileForMove) {
                showStatus('אין אריח נבחר להיפוך', 'error');
                return;
            }
            
            // שמירת המצב לפני השינוי
            saveState();
            
            const { tile } = selectedTileForMove;
            
            // מציאת גבולות האריח
            const bounds = getTileBounds(tile.positions);
            const centerCol = (bounds.minCol + bounds.maxCol) / 2;
            
            // היפוך אופקי של כל תא באריח
            const flippedPositions = tile.positions.map(([row, col]) => {
                const newCol = Math.round(2 * centerCol - col);
                return [row, newCol];
            });
            
            // בדיקה שהמיקום החדש תקין
            const isValidFlip = flippedPositions.every(([row, col]) => {
                // בדיקת גבולות
                if (row < 0 || row >= 30 || col < 0 || col >= 60) return false;
                
                // בדיקה שהמיקום הוא חלק מהשטח המיועד
                if (targetGridData[row][col] === '#ffffff') return false;
                
                // בדיקה שאין אריח אחר במיקום (למעט האריח הנוכחי)
                const otherTileAtPosition = placedTiles.find((otherTile) => 
                    otherTile !== tile && 
                    otherTile.positions.some(([oRow, oCol]) => oRow === row && oCol === col)
                );
                
                return !otherTileAtPosition;
            });
            
            if (!isValidFlip) {
                showStatus('❌ לא ניתן להפוך את האריח במיקום הנוכחי', 'error');
                return;
            }
            
            // עדכון מיקום האריח
            tile.positions = flippedPositions;
            
            // עדכון התצוגה
            updateGridDisplay();
            
            showStatus('🔃 האריח הופך בהצלחה!', 'success');
            
            // בדיקת השלמת ריצוף
            checkTilingComplete();
            saveState();
        }

        // מחיקת אריח נבחר
        function deleteSelectedTile() {
            if (!selectedTileForMove) {
                showStatus('אין אריח נבחר למחיקה', 'error');
                return;
            }
            
            // שמירת המצב לפני השינוי
            saveState();
            
            const { index } = selectedTileForMove;
            const deletedTile = placedTiles[index];
            
            // הסרת האריח מהרשימה
            placedTiles.splice(index, 1);
            
            // איפוס הבחירה והסתרת כפתורי העריכה
            selectedTileForMove = null;
            const deleteBtn = document.getElementById('deleteTileBtn');
            const rotateBtn = document.getElementById('rotateTileBtn');
            const flipBtn = document.getElementById('flipTileBtn');
            deleteBtn.style.display = 'none';
            rotateBtn.style.display = 'none';
            flipBtn.style.display = 'none';
            
            // עדכון התצוגה
            updateGridDisplay();
            
            showStatus(`🗑️ אריח נמחק! נותרו ${placedTiles.length} אריחים`, 'success');
            
            // בדיקה אם עדיין במצב הזזת אריחים
            if (tileMoveMode && placedTiles.length === 0) {
                toggleTileMoveMode(); // יציאה ממצב הזזה אם אין אריחים
            } else if (tileMoveMode) {
                highlightMovableTiles(); // הדגשה מחדש של האריחים הנותרים
            }
        }

        // מאזין מקלדת לפעולות על אריח נבחר
        document.addEventListener('keydown', function(event) {
            // פעולות רק אם יש אריח נבחר ואנחנו במצב הזזת אריחים
            if (selectedTileForMove && tileMoveMode) {
                switch(event.key.toLowerCase()) {
                    case 'delete':
                    case 'backspace':
                        event.preventDefault();
                        deleteSelectedTile();
                        break;
                    case 'r':
                        event.preventDefault();
                        rotateSelectedTile();
                        break;
                    case 'f':
                        event.preventDefault();
                        flipSelectedTile();
                        break;
                }
            }
        });

        // אתחול היישומון
        initGrids();
        initZoomControls();
        
        // שמירת המצב הראשוני
        saveState();
        
        showStatus('עצב את השטח והאריח שלך ולחץ "התחל ריצוף"', 'info');
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'980fab8057400bed',t:'MTc1ODE4NjIwNC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
